<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/Blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/Blog/css/main.css">


<link rel="stylesheet" href="/Blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gitee.com","root":"/Blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="蚂蚁的博客">
<meta property="og:url" content="https://gitee.com/iversoncurry/Blog.git/page/3/index.html">
<meta property="og:site_name" content="蚂蚁的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="蚂蚁">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gitee.com/iversoncurry/Blog.git/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>蚂蚁的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">蚂蚁的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/03/20/cookie%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/03/20/cookie%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">cookie</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-20 20:27:08" itemprop="dateCreated datePublished" datetime="2020-03-20T20:27:08+08:00">2020-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:37:54" itemprop="dateModified" datetime="2020-05-31T10:37:54+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为解决HTTP无状态导致的问题，出现了cookie。但Cookie的存在也不是为了解决通讯协议无状态的问题，只是为了解决客户端与服务端会话状态的问题，这个状态是指后端服务的状态而非通讯协议的状态。</p>
<h2 id="Cookie介绍"><a href="#Cookie介绍" class="headerlink" title="Cookie介绍"></a>Cookie介绍</h2><p>Cookie（复数形式为Cookies），类型为[小型文本文件]，指某些网站为了辨别用户身份而储存在用户本地终端上的数据。<br>作为一段一般不超过4kb的小型文本数据，它有一个名称（Name），一个值（Value）和其他几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。</p>
<p>Cookie文件不仅可以保存在浏览器中还可以保存在存放在本地文件中，这样的好处是即使关闭了浏览器，Cookie依然可以生效。</p>
<h2 id="Cookie的保质期"><a href="#Cookie的保质期" class="headerlink" title="Cookie的保质期"></a>Cookie的保质期</h2><p>有永久的也有临时的，每个浏览器都含有自己的Cookie，每次请求的时候都会根据domain来发送相应的Cookie，可通过设置expries、max-age来设定保存日期，不设置的话默认是临时存储，即关闭浏览器就消失。</p>
<h2 id="满足同源策略"><a href="#满足同源策略" class="headerlink" title="满足同源策略"></a>满足同源策略</h2><p>虽然网站images.google.com和网站<a href="http://www.google.com同属Google，但是域名不一样，二者同样不能相互操作彼此的Cookie。而且path也必须一样才能相互访问彼此的Cookie。需要注意不同浏览器对path的访问规定不一样，对于chorme，path必须为当前目录，设置为其他目录无效，**只能当前页面访问当前目录及以上的cookie" target="_blank" rel="noopener">www.google.com同属Google，但是域名不一样，二者同样不能相互操作彼此的Cookie。而且path也必须一样才能相互访问彼此的Cookie。需要注意不同浏览器对path的访问规定不一样，对于chorme，path必须为当前目录，设置为其他目录无效，**只能当前页面访问当前目录及以上的cookie</a>**</p>
<h2 id="Cookie的设置"><a href="#Cookie的设置" class="headerlink" title="Cookie的设置"></a>Cookie的设置</h2><p>1.客户端发送HTTP请求到服务器<br>2.当服务器收到HTTP请求时，在响应头里添加一个Set-Cookie字段<br>3.浏览器收到响应后保存在Cookie<br>4.之后对该服务器每一次请求中都通过Cookie字段将Cookie信息发送给服务器。</p>
<h2 id="前端使用cookie操作cookie"><a href="#前端使用cookie操作cookie" class="headerlink" title="前端使用cookie操作cookie"></a>前端使用cookie操作cookie</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">'name=xiaoming;expires='</span>+oDate</span><br></pre></td></tr></table></figure>

<h2 id="Cookies的属性"><a href="#Cookies的属性" class="headerlink" title="Cookies的属性"></a>Cookies的属性</h2><p>1.name字段：一个cookie的名称<br>2.value字段：一个cookie的值</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires用于设置Cookie时间。比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure>
<p>当Expires属性缺省时，表示是绘画性Cookie，例如，当Expires属性的值为Session，表示的就是绘画性Cookie。党委绘画性Cookie的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来。<br>与会话性Cookie相对的是持久性Cookie，持久性Cookies会保存在用户的硬盘中，直至过期或者清除Cookie。值得注意的是，设定的日期和事件至于客户端相关，而不是服务端。</p>
<h3 id="max-age"><a href="#max-age" class="headerlink" title="max-age"></a>max-age</h3><p>max-age用于设置在Cookie失效之前需要经过的秒数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: id=a3fWa; Max-Age=<span class="number">604800</span>;</span><br></pre></td></tr></table></figure>
<p>max-age可以为正数，负数，甚至是0<br>如果max-age属性为正数时，浏览器会将其持久化，即写到对应的Cookie文件中<br>当max-age属性为负数，则表示Cookie只是一个会话性Cookie<br>当max-age为0时，则会立即删除这个Cookie<br>假如max-age和expires都存在，max-age优先级更高</p>
<h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>domain指定了Cookie可以送达的主机名。假如没有指定，那么默认值为当前文档访问地址中的主机部分（但不包含子域名）<br>想淘宝首页设置的domain就是.taobao.com，这样无论是a.taobao.com还是b.taobao.com都可以使用Cookie<br>这里需要注意的是，不能跨域设置Cookie，比如阿里域名下的页面把domain设置成百度是无效的</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>path指定了一个URL路径，这个路径必须出现在要请求的资源的路径中才可以发送Cookie首部。<br>比如设置**Path=/docs，/docs/Web/下的资源才会带Cookie首部，/test则不会懈怠Cookie首部<br>domain和path标示共同定义了Cookie的作用域：即Cookie该发送给哪些URL</p>
<h3 id="Secure属性"><a href="#Secure属性" class="headerlink" title="Secure属性"></a>Secure属性</h3><p>标记为Secure的Cookie只应通过被HTTPs协议吉阿米果的请求发送给服务端。使用HTTPs安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程不被窃取和篡改。</p>
<h3 id="HTTPOnly"><a href="#HTTPOnly" class="headerlink" title="HTTPOnly"></a>HTTPOnly</h3><p>设置HTTPOnly属性可以防止客户端脚本通过document.cookie等方式访问Cookie，有助于避免XSS攻击。</p>
<h3 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h3><p>作用<br>SameSite属性可以让Cookie在跨站请求时不会被发送，从而可以组织跨站请求伪造攻击（CSRF）</p>
<p>属性值<br>SameSite可以有下面三种值<br>1.Strict：仅允许一方请求懈怠Cookie，即浏览器将只发送相同站点请求的Cookie，即当前网页URL与请求目标URL完全一致。<br>2.Lax：允许比分第三方请求懈怠Cookie<br>3.None： 无论是否跨站都会发送Cookie</p>
<p>之前默认是None的，Chorme80后默认是Lax</p>
<h3 id="跨域和跨站"><a href="#跨域和跨站" class="headerlink" title="跨域和跨站"></a>跨域和跨站</h3><p>首先要理解的一点就是跨站和跨域是不同的。同站（same-site）、跨站（cross-site）和第一方（first-party）、第三方（third-party）是等价的。但是与浏览器同源策略（SOP）中的同源（same-origin）、跨域（corss-origin）是完全不同的概念。</p>
<p>同源策略的同源是指两个URL的协议、主机名、端口一致。<br>同源策略作为浏览器的安全基石，其同源判断是比较严格的，相对而言，Cookie中的同站判断就比较宽松：只要两个URL的eTLD+1相同即可，不需要考虑协议和端口。其中，eTLD表示有效顶级域名，注册于Mozilla维护的公共后缀列表中。例如.come,.co.uk,.github.io等。eTLD+1则表示，有效顶级域名+二级域名。例如taobao.com等。</p>
<p>举几个例子，<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> 和 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 是跨站，<a href="http://www.a.taobao.com" target="_blank" rel="noopener">www.a.taobao.com</a> 和 <a href="http://www.b.taobao.com" target="_blank" rel="noopener">www.b.taobao.com</a> 是同站，a.github.io 和 b.github.io 是跨站(注意是跨站)。</p>
<h3 id="由此带来的改变"><a href="#由此带来的改变" class="headerlink" title="由此带来的改变"></a>由此带来的改变</h3><p><strong>此处有图</strong><br>从上图可以看出，对大部分 web 应用而言，Post 表单，iframe，AJAX，Image 这四种情况从以前的跨站会发送三方 Cookie，变成了不发送。<br>Post表单：应该的，学 CSRF 总会举表单的例子。<br>iframe：iframe 嵌入的 web 应用有很多是跨站的，都会受到影响。<br>AJAX：可能会影响部分前端取值的行为和结果。<br>Image：图片一般放 CDN，大部分情况不需要 Cookie，故影响有限。但如果引用了需要鉴权的图片，可能会受到影响。<br>除了这些还有 script 的方式，这种方式也不会发送 Cookie，像淘宝的大部分请求都是 jsonp，如果涉及到跨站也有可能会被影响。</p>
<h2 id="带来问题"><a href="#带来问题" class="headerlink" title="带来问题"></a>带来问题</h2><p>我们再看看会出现什么的问题？举几个例子：</p>
<p>天猫和飞猪的页面靠请求淘宝域名下的接口获取登录信息，由于 Cookie 丢失，用户无法登录，页面还会误判断成是由于用户开启了浏览器的“禁止第三方 Cookie”功能导致而给与错误的提示</p>
<p>淘宝部分页面内嵌支付宝确认付款和确认收货页面、天猫内嵌淘宝的登录页面等，由于 Cookie 失效，付款、登录等操作都会失败</p>
<p>阿里妈妈在各大网站比如今日头条，网易，微博等投放的广告，也是用 iframe 嵌入的，没有了 Cookie，就不能准确的进行推荐</p>
<p>一些埋点系统会把用户 id 信息埋到 Cookie 中，用于日志上报，这种系统一般走的都是单独的域名，与业务域名分开，所以也会受到影响。</p>
<p>一些用于防止恶意请求的系统，对判断为恶意请求的访问会弹出验证码让用户进行安全验证，通过安全验证后会在请求所在域种一个Cookie，请求中带上这个Cookie之后，短时间内不再弹安全验证码。在Chrome80以上如果因为Samesite的原因请求没办法带上这个Cookie，则会出现一直弹出验证码进行安全验证。</p>
<p>天猫商家后台请求了跨域的接口，因为没有 Cookie，接口不会返回数据</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方案就是设置 SameSite 为 none。<br>不过也会有两点要注意的地方：</p>
<p>1.HTTP 接口不支持 SameSite=none<br>如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。</p>
<p>2.需要 UA 检测，部分浏览器不能加 SameSite=none<br>IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性</p>
<h2 id="新的解决方式"><a href="#新的解决方式" class="headerlink" title="新的解决方式"></a>新的解决方式</h2><h3 id="cookie存在问题"><a href="#cookie存在问题" class="headerlink" title="cookie存在问题"></a>cookie存在问题</h3><p>1.网络请求耗费资源<br>2.安全性</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session是服务端存储用户信息，当用户登录后返回sessionId，客户端将sessionID存储在cookie中，客户端在请求时携带sessionID，服务端通过sessionId以及相关映射关系获取用户登录状态。</p>
<p>解决了传递cookie的资源浪费问题，但仍存在安全性的问题。同时服务端需要存储用户状态，增大服务端压力。</p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><p>token在session的基础上，解决了服务端存储的问题，同时防止 CSRF攻击。<br>token和sessionId类似不过由用户名和一个服务端提供的数字签名组成。用户成功登陆后，服务端返回token，token可以存在cookie或localstorage等中。token不是随请求自动发送，需要在请求头中添加，即使token放在cookie中，但服务端不是通过cookie中的token进行验证，而是通过请求头中的token进行验证，由此防止了 CSRF攻击。同时token是无状态的，</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/03/17/https/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/03/17/https/" class="post-title-link" itemprop="url">HTTPS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-17 20:27:08" itemprop="dateCreated datePublished" datetime="2020-03-17T20:27:08+08:00">2020-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:40:17" itemprop="dateModified" datetime="2020-05-31T10:40:17+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>HTTPS协议是基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护。HTTPS协议不是明文。</p>
<p>HTTPS有以下特定：<br>1.内容加密：采用混合加密技术，中间者无法直接查看明文内容；<br>2.验证身份：通过证书认证客户端访问的是自己的服务器；<br>3.保护数据完整性：防止传输的内容被中间人冒充或者篡改</p>
<p><strong>混合加密：</strong>结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。</p>
<p><strong>数字摘要：</strong>通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。</p>
<p><strong>数字签名技术：</strong>数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。</p>
<p>收方能够证实发送方的真实身份；<br>发送方事后不能否认所发送过的报文；<br>收方或非法者不能伪造、篡改报文。</p>
<h2 id="HTTPS请求过程"><a href="#HTTPS请求过程" class="headerlink" title="HTTPS请求过程"></a>HTTPS请求过程</h2><p><strong>客户端首次发出请求</strong></p>
<p>由于客户端(如浏览器)对一些加解密算法的支持程度不一样，但是在TLS协议传输过程中必须使用同一套加解密算法才能保证数据能够正常的加解密。在TLS握手阶段，客户端首先要告知服务端，自己支持哪些加密算法，所以客户端需要将本地支持的加密套件(Cipher Suite)的列表传送给服务端。除此之外，客户端还要产生一个随机数，这个随机数一方面需要在客户端保存，另一方面需要传送给服务端，客户端的随机数需要跟服务端产生的随机数结合起来产生后面要讲到的 Master Secret 。</p>
<p>客户端需要提供如下信息：</p>
<p>支持的协议版本，比如TLS 1.0版</p>
<p>一个客户端生成的随机数，稍后用于生成”对话密钥”</p>
<p>支持的加密方法，比如RSA公钥加密</p>
<p>支持的压缩方法</p>
<p><strong>服务端首次回应</strong></p>
<p>服务端在接收到客户端的Client Hello之后，服务端需要确定加密协议的版本，以及加密的算法，然后也生成一个随机数，以及将自己的证书发送给客户端一并发送给客户端，这里的随机数是整个过程的第二个随机数。</p>
<p>服务端需要提供的信息：协议的版本、加密的算法、随机数、服务器证书</p>
<p><strong>客户端再次回应</strong></p>
<p>客户端首先会对服务器下发的证书进行验证，验证通过之后，则会继续下面的操作，客户端再次产生一个随机数（第三个随机数），然后使用服务器证书中的公钥进行加密，以及放一个ChangeCipherSpec消息即编码改变的消息，还有整个前面所有消息的hash值，进行服务器验证，然后用新秘钥加密一段数据一并发送到服务器，确保正式通信前无误。</p>
<p>客户端使用前面的两个随机数以及刚刚新生成的新随机数，使用与服务器确定的加密算法，生成一个Session Secret。</p>
<p>ChangeCipherSpec</p>
<p>ChangeCipherSpec是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了。</p>
<p><strong>服务器再次响应</strong></p>
<p>服务端在接收到客户端传过来的第三个随机数的 加密数据之后，使用私钥对这段加密数据进行解密，并对数据进行验证，也会使用跟客户端同样的方式生成秘钥，一切准备好之后，也会给客户端发送一个 ChangeCipherSpec，告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了。之后，服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。</p>
<p><strong>后续客户端与服务器间通信</strong></p>
<p>确定秘钥之后，服务器与客户端之间就会通过商定的秘钥加密消息了，进行通讯了。整个握手过程也就基本完成了。</p>
<p><strong>值得特别提出的是：</strong></p>
<p>SSL协议在握手阶段使用的是非对称加密，在传输阶段使用的是对称加密，也就是说在SSL上传送的数据是使用对称密钥加密的！因为非对称加密的速度缓慢，耗费资源。其实当客户端和主机使用非对称加密方式建立连接后，客户端和主机已经决定好了在传输过程使用的对称加密算法和关键的对称加密密钥，由于这个过程本身是安全可靠的，也即对称加密密钥是不可能被窃取盗用的，因此，保证了在传输过程中对数据进行对称加密也是安全可靠的，因为除了客户端和主机之外，不可能有第三方窃取并解密出对称加密密钥！如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">TCP协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-15 20:27:08" itemprop="dateCreated datePublished" datetime="2020-03-15T20:27:08+08:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:24:22" itemprop="dateModified" datetime="2020-05-31T10:24:22+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TCP连接被称为是面向连接的，这是因为在一个应用进程可以开始面向另一个应用进程发送数据之前，这两个进程必须先相互握手，即它们必须相互发送某些预备报文段，已建立确保数据传输的参数。</p>
<p>TCP的三次握手和四次挥手<br>其中涉及几个比较重要的字段<br>1.序号（sequlize number）：seq字段，占32位，用来标示从TCP源端向目的端口发送的字节流，发起方发送数据时对此进行标记</p>
<p>2.确认号（acknowledgement number）：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1；</p>
<p>3.标志位（flags）：共6个即URG、ACK、PSH、RST、SYN、FiN等。具体含义如下：<br>URG：紧急指针有效<br>ACK：确认序号有效<br>PSH：接收方应该尽快将这个报文交给应用层。<br>RST：重置连接<br>SYN：发起一个新连接。<br>FIN：释放一个新连接。</p>
<p>TCP是一个面向连接的协议，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接，建立一条连接有以下过程。</p>
<p>1.首先客户端向服务器端发送一段TCP报文，其中：<br>标记位为SYN=1表示“请求建立新连接”<br>序号为seq=cliend_isn（随机生成）</p>
<p>2.服务器端接收到来自客户端的TCP报文之后，返回一段TCP报文：<br>标志位为SYN=1和ACK=1，表示确认客户端的报文seq序号有效，服务器能正常接收客户端发送的数据，并且同意创建新连接。<br>序号seq=sever_isn；<br>确认序号为ack=client_isn+1，表示收到客户端的序号seq并且将其值加1作为自己确认号的ack值</p>
<p>3.客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，返回最后一段TCP报文。其中：<br>标志位为ACK=1，SYN=0，表示确认收到服务器端同一连接的信号<br>序号seq = client_isn+1,表示收到服务器端的确认号ack=sever_isn+，并将其值作为自己的序号值</p>
<p>四次挥手<br>1.首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：<br>标记位为FIN=1，表示请求释放连接<br>序号为seq=client_isn1<br>随后客户端进入半关闭阶段。并且停止在客户端到服务器端方向发送数据，但是客户端仍然能接收到从服务器端传输过来的数据。</p>
<p>2.服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端进入半关闭状态，返回一段TCP报文<br>标记位ACK=1，表示接收到客户端发送的释放连接请求<br>序号为seq=sever_isn1<br>确认号为ack=client_isn1+1,表示是在收到客户端报文的基础上，将其序号seq加1作为本段报文确认号ack的值<br>随后服务器端开始准备释放服务器端到客户端方向上的连接。</p>
<p>3.服务器端锁好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中<br>标记位FIN=1，ACK=1，表示已经准备好释放连接了。<br>序号为seq=sever_isn2<br>确认号为ack=client1+1，表示是在接收到客户端报文的基础上，将其序号seq值加1作为本段报文确认号ack的值。</p>
<p>4.客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，并向服务器端发送一段报文：<br>标记位为ACK=1，表示接收到服务器准备好释放连接的信号<br>序号为client_isn1+1,表示是在收到了服务器端报文的基础上，将其却热号ack值作为本段报文序号的值<br>确认号为ack=sever_isn2+1表示是在收到了服务气短报文的基础上，将其序号值seq作为本段报文确认号的值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">http协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-10 20:27:08" itemprop="dateCreated datePublished" datetime="2020-03-10T20:27:08+08:00">2020-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:40:43" itemprop="dateModified" datetime="2020-05-31T10:40:43+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>http是无状态的协议。<br>持续连接和非持续连接指的是TCP连接持续还是非持续，长轮询和短轮询指的是http的请求方式。<br>非持续连接：每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他对象而持续下来，每个TCP连接只传输一个请求报文和一个响应报文。<br>持续连接，服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传递。当一条连接经过一定时间间隔未被使用就关闭。</p>
<h2 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h2><p>http请求报文的第一行叫做请求行，其后继的行叫做首部行。<br>如下为一个典型的HTTP请求报文<br>GET /somedir/page.html HTTP/1.1<br>Host: <a href="http://www.someschool.edu" target="_blank" rel="noopener">www.someschool.edu</a><br>connecttion: close<br>User-agent: Mozilla/5.0<br>Accept-language: fr<br>请求行有三个字段：方法字段、URL字段和HTTP版本字段。方法字段可以的取值有GET，POST，HEAD，PUT和DELETE。绝大部分的HTTP请求报文使用GET方法。</p>
<p>首部行<br>Host: ww.someschool.edu指明了对象所在的主机。<br>Connecttion：是否使用持续连接<br>User-agent：指明用户代理，即浏览器类型</p>
<p>HTTP响应报文<br>如下为典型响应报文<br>HTTP1.1 200 ok<br>Connection： close<br>Date: Tue, 09 Aug 2011 15:44:04 GMT<br>Sever: Apache/2.2.3(Centos)<br>Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT<br>Content-Length: 6821<br>Content-Type: text/html<br>由三部分组成一个初始状态行，6个首部行，然后是实体体。实体体部分值报文的主要部分，它包含了请求的对象本身。状态行有三个字段：协议版本字段、状态码和相应状态信息。<br>首部行<br>Connection：发送完报文后将关闭TCP连接<br>Date：服务器从他的文件系统中检索到该对象，插入到响应报文的事件<br>Sever：报文由什么服务器产生。<br>Last-Modified：对象创建或者最后修改的日期和时间。<br>Content-Length：被发送对象中的字节数。<br>Content-Type：指示实体体中的对象的类型</p>
<p>首部行扩展<br>http为无状态协议，引入cookie将用户和内容联系起来<br>由此请求首部行将加入cookie，响应首部行将加入Set-cookie</p>
<p><strong>与缓存相关引入的请求首部行if-Modified-Since</strong></p>
<p>请求状态码<br><strong>2开头 （请求成功）表示成功处理了请求的状态代码。</strong></p>
<p>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求。</p>
<p><strong>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong></p>
<p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<p><strong>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</strong></p>
<p>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p>
<p><strong>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</strong></p>
<p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
<h2 id="http1-0、http1-1、http2-0对比"><a href="#http1-0、http1-1、http2-0对比" class="headerlink" title="http1.0、http1.1、http2.0对比"></a>http1.0、http1.1、http2.0对比</h2><h3 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h3><p>1.1 长连接(Persistent Connection)<br>       HTTP1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。</p>
<p>1.2 节约带宽<br>       HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</p>
<p>1.3 HOST域<br>       在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</p>
<p>1.4缓存处理<br>       在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
<p>1.5错误通知的管理<br>       在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<h3 id="HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.1和HTTP2.0的区别"></a>HTTP1.1和HTTP2.0的区别</h3><p>2.1 多路复用<br>       HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p>2.2 头部数据压缩<br>       在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</p>
<pre><code>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</code></pre><p>2.3 服务器推送<br>       服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。</p>
<pre><code>为了改善延迟，HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/03/06/CSS%E5%B8%83%E5%B1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/03/06/CSS%E5%B8%83%E5%B1%80/" class="post-title-link" itemprop="url">CSS布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-06 20:27:08" itemprop="dateCreated datePublished" datetime="2020-03-06T20:27:08+08:00">2020-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:23:29" itemprop="dateModified" datetime="2020-05-31T10:23:29+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="布局的基本概念"><a href="#布局的基本概念" class="headerlink" title="布局的基本概念"></a>布局的基本概念</h2><p>多栏布局有三种基本的实现方案：固定宽度、流动、弹性。<br>固定宽度布局的大小不会随用户调整浏览器窗口大小而变化（不适用）。<br>流动布局的大小会随用户调整浏览器窗口大小而变化。这种布局能更好的适应屏幕变化。但同时也意味着放弃对页面某些方面的控制，比如随着页面宽度变化，文本行的长度和页面元素之间的位置关系可能变化。<br>弹性布局与流动布局类似，在浏览器窗口变宽时，不仅布局变宽，而且所有内容元素的大小也会变化，让人产生一种所有东西都变大了的感觉。（很难控制）</p>
<h3 id="布局高度和布局宽度"><a href="#布局高度和布局宽度" class="headerlink" title="布局高度和布局宽度"></a>布局高度和布局宽度</h3><p>布局高度和布局宽度两者的控制方法很不一样<br>1.布局高度<br>多数情况下，布局中结构化元素（乃至任何元素）的高度是不必设定的。只有这样元素才能随着自己包含内容的增加而在垂直方向上扩展。这样扩展的元素会把下面的元素向下推，而布局也能随着内容数量的增减而垂直伸缩。假如明确设定了元素的高度，那么超出的内容要么被剪掉，要么会跑到容器之外————取决于元素overflow属性的的设定。</p>
<p>2.布局宽度<br>与高度不同，我们需要更精细的控制布局宽度，以便随着浏览器窗口宽度的合理变化，布局能够做出适当的调整，确保文本行不会过长或过短。如果随意给元素添加内边距、边框，或者元素本身过大，导致浮动元素的宽度超过包含元素的布局宽度，那浮动元素就可能“躲到”其他元素下方。<br>即使必须设定栏宽，也不要给包含在其中的内容元素设定宽度，应该让这些内容元素自动扩展到填满栏的宽度。简言之，就是让栏宽限制其中内容元素的宽度。</p>
<h2 id="三栏-固定宽度布局"><a href="#三栏-固定宽度布局" class="headerlink" title="三栏-固定宽度布局"></a>三栏-固定宽度布局</h2><p>为保证每一栏的高度看起来是相同的，可以<br>圣杯布局和双飞翼布局<br>圣杯布局来源于文章In Search of the Holy Grail，而双飞翼布局来源于淘宝UED。虽然两者的实现方法略有差异，不过都遵循了以下要点：</p>
<p>两侧宽度固定，中间宽度自适应<br>中间部分在DOM结构上优先，以便先行渲染<br>允许三列中的任意一列成为最高列<br>只需要使用一个额外的<div>标签<br>圣杯布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>csslayout<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">            body &#123;</span><br><span class="line">                min-width: 550px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">                padding-left: 200px; </span><br><span class="line">                padding-right: 150px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#container</span> <span class="selector-class">.column</span> &#123;</span></span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#center</span> &#123;</span></span><br><span class="line">                width: 100%;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#left</span> &#123;</span></span><br><span class="line">                width: 200px; </span><br><span class="line">                margin-left: -100%;</span><br><span class="line">                position: relative;</span><br><span class="line">                right: 200px;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#right</span> &#123;</span></span><br><span class="line">                width: 150px; </span><br><span class="line">                margin-right: -150px; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">            <span class="selector-id">#footer</span> &#123;</span></span><br><span class="line">                clear: both;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>双飞翼布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>another test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-id">#container</span> &#123;</span></span><br><span class="line">		  width: 100%;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-class">.column</span> &#123;</span></span><br><span class="line">		  float: left;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-id">#center</span> &#123;</span></span><br><span class="line">		  margin-left: 200px;</span><br><span class="line">		  margin-right: 150px;</span><br><span class="line">		  background: yellow;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-id">#left</span> &#123;</span></span><br><span class="line">		  width: 200px; </span><br><span class="line">		  margin-left: -100%;</span><br><span class="line"><span class="css">		  <span class="selector-tag">margin-right</span><span class="selector-pseudo">:1px</span>;</span></span><br><span class="line">		  background: blue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-id">#right</span> &#123;</span></span><br><span class="line">		  width: 150px; </span><br><span class="line">		  background: green;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="css">		<span class="selector-id">#footer</span> &#123;</span></span><br><span class="line">		  clear: both;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="对于float-负外边距的理解"><a href="#对于float-负外边距的理解" class="headerlink" title="对于float+负外边距的理解"></a>对于float+负外边距的理解</h3><p>浮动的作用：<br>1.将里面的元素包裹（紧紧包裹）<br>2.将元素尽可能向上向左移动</p>
<p>当元素使用float: left时，当时用margin-left: -x时，若x&lt;元素宽度时，元素响应缩短x，当x&gt;元素宽度时，元素会向上一行移动，覆盖上一行的元素，移动距离为x；<br>当元素使用float: left时，当时用margin-right: -x时，若x&lt;元素宽度时，元素相应缩短x，当x&gt;元素宽度时，元素会向上一行移动，放到上一行的尾部。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/03/02/css%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/03/02/css%E7%9B%B8%E5%85%B3/" class="post-title-link" itemprop="url">CSS相关基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-02 20:27:08" itemprop="dateCreated datePublished" datetime="2020-03-02T20:27:08+08:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:23:16" itemprop="dateModified" datetime="2020-05-31T10:23:16+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CSS工作原理"><a href="#CSS工作原理" class="headerlink" title="CSS工作原理"></a>CSS工作原理</h2><p>每个HTML元素都有一组样式属性，可以通过CSS来设定。这些属性涉及元素在屏幕上显示时的不同方面，比如在屏幕上位置，边框宽度，文本内容的字体，字号和颜色等等。CSS就是一种先选择HTML元素，然后设定选中元素CSS属性的机制。<strong>CSS选择符要应用的样式构成了一条CSS规则。</strong><br><em>为文档添加样式的三种方法</em><br>1.行内样式<br>行内样式是写在特定HTML标签的style属性里的。行内样式的作用范围非常有限。行内样式只能影响它所在的标签，而且会覆盖嵌入样式和链接样式。<br>2.嵌入样式<br>嵌入的CSS样式是放在HTML文档的head元素中的。<em>嵌入样式的应用范围仅限于当前页面。</em>页面样式会覆盖外部样式表中的样式，但会被行内样式覆盖。<br>3.链接样式<br>在创建包含多个页面的网站时，需要把样式集中在一个单独的文件里，这个文件就叫样式表。样式表其实就是一个扩展名为.css的文本文件。可以在任意多个HTML页面中连接同一个样式表文件每个页面中只需要加入类似下面的这一行代码即可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>链接样式的作用范围可以是整个网站。只要使用<link>标签把样式表链接到每个页面，相应的页面就可以使用其中的样式。随后，只要修改了样式表中的样式，改动就会在所有被选中的元素上体现出来，无论这个元素在哪个页面里。这样，既可以做到全栈页面外观统一，又便于征战样式更新。<br>除了以上三种为页面添加样式的方法，还有一种在样式表中链接其他样式表的方法就是应用@import指令（是一种at规则）：<br>@import url(css/style2.css)<br>要注意的是，@import指令必须出现在样式表中其他样式之前，否则@import引用的样式表不会被加载。<strong>在加载页面方面，使用link的引用的文件，被同时加；@import引用的文件，要在页面加载完毕后才会被加载。</strong><br>有一点很重要，那就是 CSS 样式是通过<style>标签嵌入到页面里的。当浏览器遇到开标签<style>时，就会由解释 HTML 代码切换为解释 CSS 代码。等遇到闭标签</style>时，它会再切换回解释 HTML 代码。<br>对于写在样式表里的样式，就不需要<style>标签了。如果你在样式表里加上这个标签，样式表中的样式就不会被浏览器加了。</p>
<h3 id="上下文选择符"><a href="#上下文选择符" class="headerlink" title="上下文选择符"></a>上下文选择符</h3><p>上下文选择符的格式如下：<br>标签1 标签2 {声明}<br>其中，标签2就是我们想要选择的目标，而且只有在标签1是器祖先元素（不一定是父元素）的情况下才会被选中。<br>上下文选择符，严格来讲（也就是CSS规范里），叫后代组合式选择符（descendant combinator selector），就是一组以空格分隔的标签。用于选择作为指定祖先元素后代的标签。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123;<span class="attribute">font-weight</span>: bold;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊的上下文选择符"><a href="#特殊的上下文选择符" class="headerlink" title="特殊的上下文选择符"></a>特殊的上下文选择符</h3><p>上一节的上下文选择符是以某个祖先标签作为上下文。只要有标签在它的层次结构“上游”存在这么一个祖先，那么就会选中改标签。无论从该标签到作为祖先的上下文之间间隔着多少层次都没有关系。不过，有时候我们可能还会需要比“某些祖先”更具体的上下文。</p>
<h4 id="子选择符-gt"><a href="#子选择符-gt" class="headerlink" title="子选择符&gt;"></a>子选择符&gt;</h4><p>标签1&gt;标签2<br>标签2必须是标签1的子元素</p>
<h4 id="紧邻通报选择符"><a href="#紧邻通报选择符" class="headerlink" title="紧邻通报选择符+"></a>紧邻通报选择符+</h4><p>标签1+标签2<br>标签2必须紧跟在其同胞标签的后面</p>
<h4 id="一般同胞选"><a href="#一般同胞选" class="headerlink" title="一般同胞选"></a>一般同胞选</h4><p>标签1~标签2<br>标签2必须跟（不一定紧跟）在其同胞标签1后面</p>
<h4 id="通用选择符"><a href="#通用选择符" class="headerlink" title="通用选择符*"></a>通用选择符*</h4><p>通用选择符*（常被称为星号选择符）是一个通配符，它匹配任何元素，因此下面这条规则</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">color</span>: green;&#125;</span><br></pre></td></tr></table></figure>
<p>会导致所有元素（的文本和边框）都变成绿色。不过，一般在使用*选择符时，都会同时使用另一个选择符，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> * &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>
<p>这样只会把 p 包含的所有元素的文本变成红色。这个选择符有一个非常有意思的用法，即用它构成非子选择符，比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> * <span class="selector-tag">a</span> &#123;<span class="attribute">font-size</span>:<span class="number">1.3em</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>如图 2-13 所示，任何是 section 孙子元素，而非子元素的a 标签都会被选中。至于a的父元素是什么，没有关系。</p>
<h4 id="ID和类选择符"><a href="#ID和类选择符" class="headerlink" title="ID和类选择符"></a>ID和类选择符</h4><p>ID和类为选择元素提供了另一套手段，利用他们可以不用考虑文档的层次结构。只要在HTML标记中为元素添加了id和class属性就可以在CSS选择符中使用ID和类名，直接玄宗文档中特定的区域。<br>*可以给id和class属性设定任何值，但不能以数字或特殊符号开头。<br>雷属性就是HTML元素的class属性，body标签中包含的任何HTML元素都可添加这个属性。<br>1.类选择符<br>.类名  .my-class<br>注意类选择符前面是（.），紧跟着类名，两者之间没有空格。<br>2.标签带类选择符<br>p.specialtext {color:red;}<br>p.specialtext span {font-weight:bold;}<br>其中specialtext是p的一个子元素的类名，而span位于带有specialtext类的段落里。<br>2.多类选择符</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"specialtext featured"</span>&gt;</span>Here the span tag <span class="tag">&lt;<span class="name">span</span>&gt;</span>may or may not<span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line"> be styled.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 多个类名，如这里的 specialtext 和 featured，放在同一对引号里，用空格分隔。实际上，更准确的说法，就应该是 HTML 的 class 属性可以有多个空格分隔的值。要选择同时存在这两个类名的元素，可以这样写：<br> .specialtext.featured {font-size:120%;}<br> <strong>注意，CSS 选择符的两个类名之间没有空格，因为我们只想选择同时具有这两个类名的那个元素。如果你加了空格，那就变成了“祖先/后代”关系的上下文选择符了。</strong></p>
<h4 id="ID属性"><a href="#ID属性" class="headerlink" title="ID属性"></a>ID属性</h4><p> ID与类的写法相似，而且表示ID选择符的#的用法<br>如果有一个段落像下面这样设定了 ID 属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"specialtext"</span>&gt;</span>This is the special text.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，相应的 ID 选择符就是这样的：<br>#specialtext {CSS 样式声明}<br>或者这样的：<br>p#specialtext {CSS 样式声明}<br>用于页内导航的 ID<br>ID 也可以用在页内导航链接中。下面就是一个链接，其目标是同一页的另一个位置。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#bio"</span>&gt;</span>Biography<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>看到 href 属性值开头的#了吗？它表示这个链接的目标在当前页面中，因而不会触发浏览器加载页面（如果没有#，浏览器就会尝试加载 bio 目录下的默认页面了）。<br>使用与 CSS 选择符里相同的 #ID 名语法，可以把链接导航到同一页面中的目标 ID。在这个页<br>面的下方，应该有对应的目标元素。 </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"bio"</span>&gt;</span>Biography<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>I was born when I was very young…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同样要注意，作为目标的 ID 值前面是没有#的，就是一个普通的 ID 值。<br>用户单击前面的链接时，页面会向下滚动到 ID 值为 bio 的 h3 元素的位置。如果链接的 href<br>属性里只有一个#，那么点击该链接会返回页面顶部。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Back to Top<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>换句话说，要写一个“返回顶部”链接，根本不需要 ID 为#的目标元素。<br>另外，如果你暂时不知道某个 href 应该放什么 URL，也可以用#作为占位符，但不能把该属性<br>留空。因为 href 属性值为空的链接的行为跟正常链接不一样。这样，团队中的其他人将来可<br>以用中间层（比如 PHP）变量替换#，以便动态接收来自数据库的 URL。</p>
<h4 id="什么时候用ID，什么时候用类"><a href="#什么时候用ID，什么时候用类" class="headerlink" title="什么时候用ID，什么时候用类"></a>什么时候用ID，什么时候用类</h4><p>ID 的用途是在页面中唯一地标识一个元素。正因为如此，同一个页面中的每一个 ID属性，都必须有独一无二的值（名字）。<br>类的目的是为了标识一组具有相同特征的元素。</p>
<h3 id="属性选择符"><a href="#属性选择符" class="headerlink" title="属性选择符"></a>属性选择符</h3><h4 id="属性名选择符"><a href="#属性名选择符" class="headerlink" title="属性名选择符"></a>属性名选择符</h4><p>标签名[属性名] 例如：img[title] {border:2px solid blue;}</p>
<h4 id="属性值选择符"><a href="#属性值选择符" class="headerlink" title="属性值选择符"></a>属性值选择符</h4><p>标签名[属性名=”属性值”]  例如：img[title=”red flower”] {border:4px solid green;}</p>
<h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类这个叫法源自它们与类相似，但实际上没有类会附加到标记中的标签上。伪类分两种。<br>1.UI(User Interface, 用户界面)伪类会在HTML元素处于某个状态时（比如鼠标指针位于链接上），为该元素应用CSS样式。<br>2.结构化伪类会在标记中存在某种结构上的关系时（如某个元素是一组元素中的第一个或最后一个），为相应元素应用CSS样式。</p>
<h4 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h4><p>UI伪类会基于特定HTML元素的状态应用样式。最常使用UI伪类的元素是链接（a元素），利用UI伪类，链接可以在用户鼠标悬停时改变文本颜色，或者去掉文本的下划线。此外，还可以有其他响应方式，比如悬停时显示一个信息面板。<br>1.链接伪类<br>针对链接的伪类一共有 4 个，因为链接始终会处于如下 4 种状态之一。<br> Link。此时，链接就在那儿等着用户点击。<br> Visited。用户此前点击过这个链接。<br> Hover。鼠标指针正悬停在链接上。<br> Active。链接正在被点击（鼠标在元素上按下，还没有释放）。<br>以下就是这些状态对应的 4 个伪类选择符（使用了 a 选择符和一些示例声明）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:black;&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:gray;&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">text-decoration</span>:none;&#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>
<p>其中(:)表示伪类,一个冒号（:）表示伪类，两个冒号（::）表示 CSS3 新增的伪元素。<br>注意，有些伪类可以用于任何元素，而不仅仅是 a 元素。比如，下面这条规则能让段落背景在鼠标悬停时变成灰色：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">background-color</span>:gray;&#125;</span><br></pre></td></tr></table></figure>
<p>2.:focus 伪类<br>表单中的文本字段在用户单击它时会获得焦点，然后用户才能在其中输入字符。下面的规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid blue;&#125;</span><br></pre></td></tr></table></figure>
<p>会在光标位于 input 字段中时，为该字段添加一个蓝色边框。这样可以让用户明确地知道输入的字符会出现在哪里。<br>3.:target 伪类</p>
<p>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target 伪类选中它。对于下面这个链接:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#more_info"</span>&gt;</span>More Information<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>位于页面其他地方、ID 为 more_info 的那个元素就是目标。该元素可能是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"more_info"</span>&gt;</span>This is the information you are looking for.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么，如下 CSS 规则</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#more_info</span><span class="selector-pseudo">:target</span> &#123;<span class="attribute">background</span>:<span class="number">#eee</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>会在用户单击链接转向 ID 为 more_info 的元素时，为该元素添加浅灰色背景。</p>
<h4 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h4><p>结构化伪类可以根据标记的结构应用样式，比如根据某元素的父元素或前面的同胞元素是什么。<br>1.:first-child 和:last-child<br>:first-child 代表一组同胞元素中的第一个元素，而:last-child 则代表最后一个。<br>2.:nth-child<br>e:nth-child(n)<br>e 表示元素名，n 表示一个数值（也可以使用 odd 或 even）。<br>例如，<br>li:nth-child(3)  会选择一组列表项中的每个第三项。<br>:nth-child 伪类最常用于提高表格的可读性，比如像第 6 章中那样，对表格的所有行交替应用不同颜色。</p>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>顾名思义，伪元素就是你的文档中若有实无的元素。</p>
<ol>
<li>::first-letter 伪元素<br>p::first-letter {font-size:300%;}<br>可以得到段落首字符放大的效果。</li>
<li>::first-line 伪元素<br>e::first-line<br>可以选中文本段落（一般情况下是段落）的第一行。</li>
<li>::before 和::after 伪元素<br>以下两个伪元素<br>e::before<br>e::after<br>可用于在特定元素前面或后面添加特殊内容。<br>搜索引擎不会取得伪元素的信息（因为它在标记中并不存在）。因此，不要通过伪元素添加你想让搜索引擎索引的重要内容。</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>文档中的所有元素，无论它在层次结构中多么靠下，都将继承这些样式，以Helvetica 字体（或者在 Helvetica 字体无效时以其他字体代替）显示各自包含的文本。继承给我们带来的效率是显而易见的，全站的主字体只要在某个上层元素上指定即可，无须在每一个标签上分别指定。而对于个别想使用不同字体的元素，只要个别设定 font-family 属性就好了。<br>CSS 中有很多属性是可以继承的，其中相当一部分都跟文本有关，比如颜色、字体、字号。然而，也有很多 CSS 属性不能继承，因为继承这些属性没有意义。这些不能继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距。</p>
<h3 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h3><p>层叠，就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。<br>层叠是 CSS 的核心机制，理解了它才能以最经济的方式写出最容易改动的 CSS，让文档外观在达到设计要求的同时，也给用户留下一些空间，让他们能根据需要更改文档的显示效果（比如整体调整字号）。</p>
<h4 id="样式来源"><a href="#样式来源" class="headerlink" title="样式来源"></a>样式来源</h4><p>样式有多处来源。首先，如果告诉你浏览器有一个默认的样式表，你应该不会感到奇怪，因为你还没有写一行 CSS 呢，每个标签已经带了一定的样式。h1 是不是粗体，字号还挺大？em 是不是斜体？列表呢，是不是缩进而且还带项目符号或编号？<br>然后，有一个用户样式表。没错，用户也可以提供样式表，尽管这样的用户不多见。这个选择对于视障用户很有用，他们可以通过用户样式表，强制浏览器加载的所有网站都以更大的字号，更容易分辨的颜色显示内容。比如，某个视障用户可以增加如下样式：<br>再有，就是作者样式表，也就是网页设计师（你）写的样式表。前面我们已经讲了作者给网页添加样式的三种方法：链接样式、嵌入样式和行内样式。</p>
<h4 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a>层叠规则</h4><p><strong>层叠规则一：找到应用给每个元素和属性的所有声明。</strong>浏览器在加载每个页面时，都会据此查到每一条 CSS 规则，标识出所有受到影响的 HTML 元素。<br><strong>层叠规则二：按照顺序和权重排序。</strong>浏览器依次检查 5 个来源，并设定匹配的属性。如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环，直到检查完页面中所有标签受影响属性的全部 5 个来源为止。最终某个属性被设定成什么值，就用什么值来显示。声明也可以有权重。可以像下面这样为单独的声明增加权重：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:green <span class="meta">!important</span>; <span class="attribute">font-size</span>:<span class="number">12pt</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>空格!important 分号（;）用于加重声明的权重。<br><strong>层叠规则三：按特指度排序。</strong>除了有点拗口之外，特指度（specificity）其实表示一条规则有多明确。<br><strong>层叠规则四：顺序决定权重。</strong>如果两条规则都影响某元素的同一个属性，而且它们<br>的特指度也相同，则位置最靠下（或后声明）的规则胜出。</p>
<h4 id="计算特指度"><a href="#计算特指度" class="headerlink" title="计算特指度"></a>计算特指度</h4><p>下面我们具体讲一讲怎么计算选择符的特指度。首先，有一个简单的记分规则，即对每个选择符都要按下面的“ICE”公式计算三个值：<br>三个字母间的短横线是分隔符，并非减号。针对这个公式的计分办法如下：</p>
<ol>
<li>选择符中有一个 ID，就在 I 的位置上加 1；</li>
<li>选择符中有一个类，就在 C 的位置上加 1；</li>
<li>选择符中有一个元素（标签）名，就在 E 的位置上加 1；</li>
<li>得到一个三位数。<br>通过几个例子来理解特指度。<br>P 0-0-1 特指度=1<br>p.largetext 0-1-1 特指度=11<br>p#largetext 1-0-1 特指度=101<br>body p#largetext 1-0-2 特指度=102<br>body p#largetext ul.mylist 1-1-3 特指度=113<br>body p#largetext ul.mylist li 1-1-4 特指度=114<br>在此，每个选择符都比前一个选择符的特指度更高。</li>
</ol>
<p>简单层叠要点<br>在这个版本里，只要记住三条规则就够了。这三条规则适合所有情况。<br>规则一：包含 ID 的选择符胜过包含类的选择符，包含类的选择符胜过包含标签名的选择符。<br>规则二：如果几个不同来源都为同一个标签的同一个属性定义了样式，行内样式胜过嵌入样式，嵌入样式胜过链接样式。在链接的样式表中，具有相同特指度的样式，后声明的胜过先声明的。规则一胜过规则二。换句话说，如果选择符更明确（特指度更高），无论它在哪里，都会胜出。<br>规则三：设定的样式胜过继承的样式，此时不用考虑特指度（即显式设定优先）。下面简单<br>解释一下规则三。比如下面的标记</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"cascade_demo"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"inheritance_fact"</span>&gt;</span>Inheritance is <span class="tag">&lt;<span class="name">em</span>&gt;</span>weak<span class="tag">&lt;/<span class="name">em</span>&gt;</span> in the Cascade<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>和下面的规则<br>div#cascade_demo p#inheritance_fact {color:blue;}<br>2 - 0 - 2 （高特指度）<br>会导致单词“weak”变成蓝色，因为它从父元素 p 那里继承了这个颜色值。<br>但是，只要我们再给 em 添加一条规则<br>em {color:red;}<br>0 - 0 - 1 （低特指度）<br>em 就会变成红色。因为，虽然它的特指度低（0-0-1），但 em 继承的颜色值，会被为它明确（显式）指定的颜色值覆盖，就算（隐式）遗传该颜色值的规则的特指度高（2-0-2）也没有用。</p>
<h3 id="规则声明"><a href="#规则声明" class="headerlink" title="规则声明"></a>规则声明</h3><p>CSS 属性值主要分以下三类。<br><strong>文本值。</strong>例如，font-weight:bold 声明中的 bold 就一个文本值。文本值也叫做关键字。<br><strong>数字值。</strong>数字值后面都有一个单位，例如英寸或点。在声明 font-size:12px 中，12是数字值，而 px 是单位（像素）。如果数字值为 0，那么就不用带单位了。<br><strong>颜色值。</strong>颜色值可以用几种不同的格式来写，包括 RGB（Red, Green, Blue，红绿蓝）、<br>HSL（Hue, Saturation, Luminance，色相，饱和度，亮度）和十六进制值（例如color:#336699）。</p>
<h4 id="文本值"><a href="#文本值" class="headerlink" title="文本值"></a>文本值</h4><p>所有 CSS 属性都有文本值。例如，visibility 属性有 visible 和 hidden 值，border-style 属性有 solid、 dashed 以及 inset 值。</p>
<h4 id="数字值"><a href="#数字值" class="headerlink" title="数字值"></a>数字值</h4><p>数字值主要分两类：绝对值和相对值。<br>em 和 ex 都是字体大小的单位，但在 CSS 中，它们作为长度单位适用于任何元素。先说说 em ，它表示一种字体中字母 M 的宽度，因此它的具体大小取决于你使用的字体。而 ex 呢，等于给定字体中字母 x 的高度（小写字母 x 代表一种字体的字母中间部分的高度，不包括字母上、下突出的部分——如 d 和 p 上下都出头儿）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/02/28/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/02/28/%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">代理和反射接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-28 20:27:08" itemprop="dateCreated datePublished" datetime="2020-02-28T20:27:08+08:00">2020-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:31:12" itemprop="dateModified" datetime="2020-05-31T10:31:12+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ES5和ES6都推进了JS功能的公开。例如，JS运行环境包含一些不可枚举、不可写入的对象属性。ES5引入了Object.defineProperty()方法以便开发者在这方面能够像JS引擎那样做。<br>SE6让开发者能进一步接近JS引擎的能力，这些能力原先只存在于内置对象上。语言通过代理（proxy）暴露在对象上的内部工作，代理是一种封装，能够拦截并改变JS引擎的底层操作。</p>
<h2 id="数组问题"><a href="#数组问题" class="headerlink" title="数组问题"></a>数组问题</h2><p>在ES6之前，JS的数组对象拥有特定的行为方式，无法被开发者在自定义对象中进行模拟。当你给数组元素赋值时，数组的length属性会受到影响，同时也可以通过修改length属性来变更数组的元素。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(colors.length)       <span class="comment">//3</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">'black'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)       <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])           <span class="comment">//black</span></span><br><span class="line">colors.length = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)       <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">3</span>])           <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>])           <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">1</span>])           <span class="comment">//green</span></span><br></pre></td></tr></table></figure>
<h2 id="代理与反射是什么"><a href="#代理与反射是什么" class="headerlink" title="代理与反射是什么"></a>代理与反射是什么</h2><p>通过调用new Proxy()，可以创建一个代理用来替代另一个对象（被称为目标），这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。<br>代理允许拦截在目标对象上的底层操作。拦截行为使用了一个能够响应特定操作的函数（被称为陷阱）。<br>被Reflect对象所代表的反射接口，是给底层操作提供默认行为的方法的集合，这些操作是能够被代理重写的。每个代理陷阱都有一个对应的反射方法，每个方法都与对应的陷阱函数重名，并且接受的参数也与之一致。下表总结了这些行为：<br>每个陷阱函数都可以重写 JS 对象的一个特定内置行为，允许你拦截并修改它。如果你仍然需要使用原先的内置行为，则可使用对应的反射接口方法。一旦创建了代理，你就能清晰了解代理与反射接口之间的关系，因此我们最好通过一些例子来进行深入研究。</p>
<h2 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h2><p>当你使用 Proxy 构造器来创建一个代理时，需要传递两个参数：目标对象以及一个处理器（handler），后者是定义了一个或多个陷阱函数的对象。如果未提供陷阱函数，代理会对所有操作采取默认行为。为了创建一个仅进行传递的代理，你需要使用不包含任何陷阱函数的处理器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line">proxy.name = <span class="string">"proxy"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// "proxy"</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name); <span class="comment">// "proxy"</span></span><br><span class="line">target.name = <span class="string">"target"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// "target"</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name); <span class="comment">// "target"</span></span><br></pre></td></tr></table></figure>
<p>该例中的 proxy 对象将所有操作直接传递给 target 对象。当 proxy.name 属性被赋值为字符串 “proxy” 的时候， target.name 属性也同时被创建，代理对象 proxy 自身其实并没有存储该属性，它只是简单将值传递给 target 对象。同样， proxy.name 与 target.name 的属性值总是相等，因为它们都指向 target.name ，这就意味着：为 target.name 设置一个新值会在 proxy.name 上反映出相同的改变。当然，缺少陷阱函数的代理没什么用，那么若为其定义一个陷阱函数，又会如何？</p>
<h2 id="使用set陷阱函数验证属性值"><a href="#使用set陷阱函数验证属性值" class="headerlink" title="使用set陷阱函数验证属性值"></a>使用set陷阱函数验证属性值</h2><p>假设你想要创建一个对象，并要求其属性值只能是数值，这就意味着该对象的每个新增属性都要被验证，并且在属性值不为数值类型时应当抛出错误。为此你需要定义 set 陷阱函数来重写设置属性值时的默认行为，该陷阱函数能接受四个参数：</p>
<ol>
<li>trapTarget ：将接收属性的对象（即代理的目标对象）；</li>
<li>key ：需要写入的属性的键（字符串类型或符号类型）；</li>
<li>value ：将被写入属性的值；</li>
<li>receiver ：操作发生的对象（通常是代理对象）。<br>Reflect.set() 是 set 陷阱函数对应的反射方法，同时也是 set 操作的默认行为。<br>Reflect.set() 方法与 set 陷阱函数一样，能接受这四个参数，让该方法能在陷阱函数内部被方便使用。该陷阱函数需要在属性被设置完成的情况下返回 true ，否则就要返回 false，而 Reflect.set() 也会基于操作是否成功而返回相应的结果。你需要使用 set 陷阱函数来拦截传入的 value 值，以便对属性值进行验证。这里有个例子：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    name: <span class="string">"target"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="keyword">set</span>(trapTarget, key, value, receiver) &#123;</span><br><span class="line">    <span class="comment">// 忽略已有属性，避免影响它们</span></span><br><span class="line">        <span class="keyword">if</span> (!trapTarget.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property must be a number."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 添加一个新属性</span></span><br><span class="line">proxy.count = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.count) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.count) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 你可以为 name 赋一个非数值类型的值，因为该属性已经存在</span></span><br><span class="line">proxy.name = <span class="string">"proxy"</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// "proxy"</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// "proxy"</span></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">proxy.anotherName = <span class="string">"proxy"</span></span><br></pre></td></tr></table></figure>
这段代码定义了一个代理陷阱，用于对 target 对象新增属性的值进行验证。当执行proxy.count = 1 时， set 陷阱函数被调用，此时 trapTarget 的值等于 target 对象，key 的值是字符串 “count” ， value 的值是 1 ，而 receiver 的值是 proxy （该参数在本例中并没有被使用）。 target 对象上尚不存在名为 count 的属性，因此代理将value 参数传递给 isNaN() 方法进行验证；如果验证结果是 NaN ，表示传入的属性值不是一个数值，需要抛出错误；但由于这段代码将 count 参数设置为 1 ，验证通过，代理使用一致的四个参数去调用 Reflect.set() 方法，从而创建了一个新的属性。<br>当 proxy.name 被赋值为字符串时，操作成功完成。这是因为 target 对象已经拥有一个name 属性，因此验证时通过调用 trapTarget.hasOwnProperty() 会忽略该属性，这就确保允许在该对象的已有属性上使用非数值的属性值。<br>当 proxy.anotherName 被赋值为字符串时，抛出了一个错误。这是因为该对象上并不存在anotherName 属性，因此该属性的值必须被验证，而因为提供的值不是一个数值，验证过程就会抛出错误。<br>set 代理陷阱允许你在写入属性值的时候进行拦截，而 get 代理陷阱则允许你在读取属性<br>值的时候进行拦截。<h2 id="使用get陷阱函数进行对象外形验证"><a href="#使用get陷阱函数进行对象外形验证" class="headerlink" title="使用get陷阱函数进行对象外形验证"></a>使用get陷阱函数进行对象外形验证</h2></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/02/20/JS%E7%9A%84%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/02/20/JS%E7%9A%84%E7%B1%BB/" class="post-title-link" itemprop="url">JS的类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-20 20:27:08" itemprop="dateCreated datePublished" datetime="2020-02-20T20:27:08+08:00">2020-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:29:33" itemprop="dateModified" datetime="2020-05-31T10:29:33+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>与大多数正规的面向对象编程语言不同，JS从创建之初就不支持类，也没有把类继承作为定义相似对象以及关联对象的主要方式。而从ES1诞生之前知道ES5时期，很多库都创建了一些工具，让JS显得貌似能支持类。</p>
<h3 id="ES5中仿类结构"><a href="#ES5中仿类结构" class="headerlink" title="ES5中仿类结构"></a>ES5中仿类结构</h3><p>JS在ES5以及更早版本中都不存在类。与类最接近的是：创建一个构造器，然后将方法指派到该构造起的原型上。这种方式通常被称为创建一个自定义类型。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonType(<span class="string">'Nicholas'</span>)</span><br><span class="line">person.sayName()  <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonType)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>此代码中的 PersonType 是一个构造器函数，并创建了单个属性 name 。 sayName() 方法被指派到原型上，因此在 PersonType 对象的所有实例上都共享了此方法。接下来，使用 new运算符创建了 PersonType 的一个新实例 person ，此对象会被认为是一个通过原型继承了PersonType 与 Object 的实例。</p>
<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><p>类在ES6中最简单的形式就是类声明，看起来向其他语言中的类</p>
<h4 id="基本的类声明"><a href="#基本的类声明" class="headerlink" title="基本的类声明"></a>基本的类声明</h4><p>类声明以class关键字开始，其后是类的名称；其余部分的语法看起来就像对象字面量中的方法简写，并且在方法之间不需要使用逗号。下为简单类声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonCladd</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'Nicholas'</span>)</span><br><span class="line">person.sayName()   <span class="comment">//输出Nicholas</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)     <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName)  <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>这个PersonClass类声明的行为非常类似上个例子中的PersonType。类声明允许在其中使用特殊的constructor方法名称直接定义一个构造器，而不需要先定义一个函数再把它当做构造器使用。由于累的方法使用类间歇语法，于是就不再需要使用function关键字。constructor之外的方法名称则没有特别的含义。<br>自有属性（Own properties）：该属性出现在实力上而不是原型上，只能在类的构造器或方法内部进行创建。在本例中，name就是一个自有属性。建议应在构造器函数内创建所有可能出现的自有属性，这样在类中声明变量就会被限制在单一位置（有助于代码检查）<br>相对于已有的<strong>自定义类型声明方式</strong>来说，<strong>类声明</strong>仅仅是以它为基础的一个语法糖。PersonClass声明实际上创建了一个拥有constructor方法以及其行为的函数，这也是typeof PersonClass会得到“function”结果的原因。此例中的sayName()方法最终也成为PersonClass.prorotype上的一个方法，类似于上个例子中的sayName()与PersonType。prototype之间的关系。这些相似处允许把自定义类型与类混合使用，而不必考虑该使用哪一个。</p>
<h4 id="为何要使用类的语法"><a href="#为何要使用类的语法" class="headerlink" title="为何要使用类的语法"></a>为何要使用类的语法</h4><p>尽管类与自定义类型之间有相似性，但仍然要记住一些重要的区别：<br>1.类声明不会被提升，这与函数定义不同。类声明的行为与let相似，因此在程序执行到达声明处之前，类会存在于暂时性死区内。<br>2.类声明中的所有代码会自动运行在严格模式下，并且也无法退出严格模式。<br>3.类的所有方法都是不可枚举的，这是对于自定义类型的显著变化，后者必须用Object.defineProperty()才能将方法改变为不可枚举。<br>4.类的所有方法内部都没有[[Construct]]，因此使用new来调用它们会抛出错误。<br>5.调用类构造器时不使用new，会抛出错误。<br>6.试图在类的方法内部重写类名，会抛出错误。<br>这样看来，上例中的PersonClass声明实际上就直接等价于一下未使用类语法的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接等价于PersonClass</span></span><br><span class="line"><span class="keyword">let</span> PersonType2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="keyword">const</span> PersonType = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(PersonType2.prototype, <span class="string">'sayName'</span>, &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 确认函数被调用时没有使用new</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'method cannot be called with new'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="keyword">return</span> PersonType2</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>首先要注意这里有两个PersonType2声明：一个在外部作用的let声明，一个在IIFE内部的const声明。这就是为何类的方法不能对类名进行重写、而类外部的代码则被允许。构造器函数检查了new.target，以保证被调用时使用了new，否则就抛出错误。接下来，sayName()方法被定义为不可枚举，并且此方法也检查了new.target，它则要保证在被调用时没有使用new。最后一步是将构造器函数返回出去。<br>此例说明了尽管不使用新语法也能实现类的任何特性，但类语法显著简化了所有功能的代码。<br>不变的类名<br>只有在类的内部，类名才被视为是使用const声明的。这意味着你可以在外部重写类名但不能再累的方法内部这么做。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        Foo = <span class="string">'bar'</span> <span class="comment">//执行时抛出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但在类声明之后没问题</span></span><br><span class="line">Foo = <span class="string">'baz'</span></span><br></pre></td></tr></table></figure>

<p>在此代码中，类构造器内部的 Foo 与在类外部的 Foo 是不同的绑定。内部的 Foo 就像是用 const 定义的，不能被重写，当构造器尝试使用任何值重写 Foo 时，都会抛出错误。但由于外部的 Foo 就像是用 let 声明的，你可以随时重写类名。</p>
<h3 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h3><p>类与函数有相似之处，即它们都有两种形式：声明与表达式。函数声明与类声明都以适当的关键词为起始分别是（function与class），随后是标识符（即函数名或类名）。函数具有一种表达式形式，无需在function后面使用表示；类似的，类也有不需要表示符的表达式形式。类表达式被设计用于变量声明，或可作为参数传递给函数。<br>基本的类表达式<br>此处是与上例中的PersonCladd等效的类表达式，随后的代码使用了它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> PersonClass(<span class="string">'nicholas'</span>)</span><br><span class="line">person.sayName()  <span class="comment">//输出nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> PersonClass)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>)        <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)              <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass.prototype.sayName) <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p>正如磁力所示，类表达式不需要再class关键字后使用标识符。除了语法差异，类表达式的功能等价于类声明。<br>使用类声明还是类表达式，主要是代码风格的问题。相对于函数声明与函数表达式之间的区别，类声明与类表达式都不会被提升，因此对代码运行时的行为影响甚微。</p>
<h4 id="具名类表达式"><a href="#具名类表达式" class="headerlink" title="具名类表达式"></a>具名类表达式</h4><p>上一节的示例使用了一个匿名的类表达式，不过就像函数表达式那样，也可以为类表达式明明。为此需要在class关键字后添加标识符，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> PersonClass = calss PersonClass2 &#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass)   <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> PersonClass2)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>此例中的类表达式被命名为PersonClass2。PersonClass2标识符只在类定义内部存在，因此只能用在类方法内部（例如本例中的sayName()内）。在类的外部，typeof PersonClass2的结果为undefined，这是因为外部不存在PersonClass2绑定。要理解为何如此，请查看未使用类语法的等价声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接等价于PersonClass具名的类表达式</span></span><br><span class="line"><span class="keyword">let</span> PersonClass = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">const</span> = PersonClass2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    object.defineProperty(PersonClass2.prototype, <span class="string">'sayName'</span>, &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 确认函数被调用时没有使用new</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'method cannot be called with new'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> PersonClass2</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>创建具名的类表达式稍微改变了在JS引擎内部发生的事。对于类声明来说，外部绑定（用let定义）与内部绑定（用const定义）有着相同的名称。而类表达式可在内部使用const来定义它的不同名称，因此此处的PersonClass2只能在类的内部使用。<br>尽管具名类表达式的行为已于具名函数表达式，但它们之间仍有许多相似点。二者都能被当做值来使用，这开启了许多可能性。</p>
<h3 id="作为一级公民的类"><a href="#作为一级公民的类" class="headerlink" title="作为一级公民的类"></a>作为一级公民的类</h3><p>在编程中，能被当做值来使用的就称为一级公民（first-class citizen），意味着它能作为参数给函数、能作为函数返回值、能用来给变量赋值。JS的函数就是一级公民（它们有时又被称为一级函数），此特性让JS独一无二。<br>ES6延续了传统，让类同样成为一级公民。这就使得类可以被多种方式所使用。例如，它能作为参数传入函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crateObject</span>(<span class="params">classDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> classDef()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = createObject(<span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">obj.sayHi()      <span class="comment">//hi</span></span><br></pre></td></tr></table></figure>
<p>此例中的createObject()函数被调用时接收了一个匿名函数表达式作为参数，使用new创建了该类的一个实例，并将其返回出来。随后变量obj储存了所返回的实例。<br>类表达式的另一个又去用途是立即调用类构造器，以创建单例（Singleton）。为此，必须使用new来配合类表达式，并在表达式后面添加括号。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'nicholas'</span>)</span><br><span class="line">person.sayName()   <span class="comment">//nicholas</span></span><br></pre></td></tr></table></figure>
<p>此处创建了一个匿名类表达式，并立即执行了它。此模式允许你使用类语法来创建单例类，从而不留下任何可被探查的类引用（回忆一下PersonClass的例子，匿名类表达式只在类的内部创建了绑定，而外部无绑定）。<strong>类表达式后面的圆括号表示要调用前面的函数，并且还允许传入参数。</strong></p>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>自有属性需要在类构造器中创建，而类还允许在原型上定义访问器属性。为了创建一个getter，需要使用get关键字，并要与后方标识符之间留出空格；创建setter用相同方式，只是要换用set关键字。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> html() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> html(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">'html'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span> <span class="keyword">in</span> descriptor)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'set'</span> <span class="keyword">in</span> descriptor)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor,enumerable) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>此代码中的CustomHTMLElement类用于包装一个已存在的DOM元素，它的属性html拥有getter与setter，委托了元素自身的innerHTML方法。该访问器属性被创建在CUnstmHTMLElement.prototype上，并且像其他类属性那样被创建为不可枚举属性。非类的等价表示如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接等价于上个范例</span></span><br><span class="line"><span class="keyword">let</span> CustomHTMLElement = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="keyword">const</span> CustomHTMLElement = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 确认函数被调用时使用了new</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'constructor must be called with new'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(CustomHTMLElement.prototype, <span class="string">'html'</span>, &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> CunstomHTMLElement</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<h3 id="需计算的成员名"><a href="#需计算的成员名" class="headerlink" title="需计算的成员名"></a>需计算的成员名</h3><p>对象字面量与类之间的相似点还不仅前面那些。类方法与访问器属性也都能使用需计算的名称。㞏相同于对象字面量中的需计算名称：无需使用标识符，而是用方括号来包裹一个表达式。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">'sayName'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> </span>= PersonClass &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    [methodName]() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> PersonClass(<span class="string">'nicholas'</span>)</span><br><span class="line">me.sayName()                  <span class="comment">//'nicholas'</span></span><br></pre></td></tr></table></figure>
<p>此版本的PersonClass使用了一个变量来命名类定义内的方法。字符串”sayName“被赋值给了methodName变量，而methodName变量则被用于声明方法。sayName()方法在此后能被直接访问。<br>访问器属性能以相同方式使用需计算的名称，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">'html'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> [propertyName]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> [propertyName](value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.innerHTML = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处html的getter与setter被设置为需使用propertyName变量，使用.html依然能访问此属性，这里影响的只有定义方式。</p>
<h3 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    *createIterator() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Myclass()</span><br><span class="line"><span class="keyword">let</span> iterator = instance.createIterator()</span><br></pre></td></tr></table></figure>
<p>此处代码创建了一个拥有createIterator()生成器的MyClass类。该方法返回了一个迭代器，它的值在生成器内部用硬编码提供。当使用一个对象来表示值的集合、并要求能简单迭代这些值，那么生成器方法就非常有用。数组、Set与Map都拥有多个生成器方法，负责让开发者用多种方式来操作它们的项。<br>既然生成器方法很有用，那么在表示集合的自定义类中定义一个默认迭代器，那就更好。可以使用 Symbol.iterator 来定义生成器方法，从而定义出类的默认迭代器，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = []</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> collection = <span class="keyword">new</span> Collection()</span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例为生成器方法使用了一个需计算名称，并将此方法委托到this.items数组的values()迭代器上。任意管理集合的类都包含一个默认迭代器，这是因为一些集合专用的操作都要求目标集合具有迭代器。现在，Collection的任意实例都可以在for-of循环内被直接使用，也能配合扩展运算符使用。<br>当你想让方法与访问器属性在对象实例上出现时，把它们添加到类的原型上就会对此目的有帮助。而另一方面，若想让方法与访问器属性只存在于类自身，那么你就需要使用静态成员。</p>
<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>直接在构造器上添加额外方法来模拟静态成员，这在ES5及更早版本中是另一个通用的模式。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PersonType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line">PersonType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PersonType(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line">PersonType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = PersonType.create(<span class="string">'nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p>在其他编程语言中，工厂方法PersonType.create()会被认定为一个静态方法，它的数据不依赖PersonType的任何势力。ES6的类简化了静态成员的创建，只要在方法与访问器属性的名称前添加正式的static标注。作为一个例子，此处有个与上例等价的类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于PersonType构造器</span></span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.prototype.sayName</span></span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于PersonType.create</span></span><br><span class="line">    <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonClass(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = PersonClass.create(<span class="string">'nicholas'</span>)</span><br></pre></td></tr></table></figure>
<p>PersonClass 的定义拥有名为 create() 的单个静态方法，此语法与 sayName() 基本相同，只多了一个 static 关键字。你能在类中的任何方法与访问器属性上使用 static 关键字，唯一限制是不能将它用于 constructor 方法的定义。<br><strong>静态成员不能用实例来访问，始终需要直接用类自身来访问它们</strong></p>
<h3 id="使用派生类进行继承"><a href="#使用派生类进行继承" class="headerlink" title="使用派生类进行继承"></a>使用派生类进行继承</h3><p>ES6之前，实现自定义类型的继承是个繁琐的过程。严格的继承要求有多个步骤。例如，研究一下范例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length*<span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">    Rectangle.call(<span class="keyword">this</span>, length, length)</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Rectangle.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Square,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea())    <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Square继承了Rectangle，为此它必须使用Rectangle.prototype所创建的一个新对象来重写Square.prototype，并且还要调用Rectangle.call()方法。<br>类让继承工作变得更轻易，使用熟悉的extends关键字来指定当给钱类所需要的继承的函数即可。生成的类的原型会被自动调整，而你还能调用super()方法来访问基类的构造器。此处是与上个例子等价的ES6代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// 与Rectangle.call(this, length, length)相同</span></span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea)       <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square)   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>此次Square类使用了extends关键字继承了Rectangle。Square构造器使用了super()配合指定参数调用了Rectangle构造器。注意与ES5版本的代码不同，Rectangle标识符尽在类定义时被使用了（在extends之后）。<br>继承了其他类的类被称为派生类（derived classes）。如果派生类指定了构造器，就需要使用super(),否则就会造成错误。若不使用构造器，super()方法会被自动调用，并会使用创建新实例时提供的所有参数。例如，下列两个类是完全相同的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有构造器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="keyword">super</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例中的第二个类展示了与所有派生类默认构造器等价的写法，所有的参数都按顺序传递给了基类的构造器。在当前需求下，郑重做法并不完全准确，因为Square构造器只需要单个参数，因此最好手动定义构造器。<br>使用 super() 时需牢记以下几点：</p>
<ol>
<li>你只能在派生类中使用 super() 。若尝试在非派生的类（即：没有使用 extends关键字的类）或函数中使用它，就会抛出错误。</li>
<li>在构造器中，你必须在访问 this 之前调用 super() 。由于 super() 负责初始化this ，因此试图先访问 this 自然就会造成错误。</li>
<li>唯一能避免调用 super() 的办法，是从类构造器中返回一个对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name</span><br><span class="line">		<span class="keyword">this</span>.age = age</span><br><span class="line">	&#125;</span><br><span class="line">	sayAge() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(name, age, classNum) &#123;</span><br><span class="line">		<span class="keyword">super</span>(name, age)  <span class="comment">//注释之后报错，没有this</span></span><br><span class="line">		<span class="keyword">this</span>.classNum = classNum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaoHong = <span class="keyword">new</span> Student(<span class="string">'xiaohong'</span>, <span class="string">'12'</span>, <span class="string">'class3'</span>)</span><br><span class="line">xiaoHong.sayAge()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="屏蔽类方法"><a href="#屏蔽类方法" class="headerlink" title="屏蔽类方法"></a>屏蔽类方法</h4><p>派生类中的方法总是会屏蔽基类的同名方法。例如，可以将getArea()方法添加到Super类，以便重定义它的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于getArea()已经被定义为Square的一部分，Rectangle.prototype.getArea()方法就不能再Square的任何实例上被调用。当然，总可以使用super.getArea()方法来调用基类中的同名方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getArea()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="继承静态成员"><a href="#继承静态成员" class="headerlink" title="继承静态成员"></a>继承静态成员</h4><p>如果基类包含静态成员，那么这些静态成员在派生类中也是可用的。继承的工作方式类似于其他语言。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> create(length, width) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rectangle(length, width)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="comment">// 与Rectangle.call(this, length, length)相同</span></span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>)   </span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea())             <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square)     <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>在此代码中，一个新的静态方法 create() 被添加到 Rectangle 类中。通过继承，该方法会以 Square.create() 的形式存在，并且其行为方式与 Rectangle.create() 一样。</p>
<h4 id="从表达式中派生类"><a href="#从表达式中派生类" class="headerlink" title="从表达式中派生类"></a>从表达式中派生类</h4><p>在ES6中派生类的最强大能力，或许就是能够从表达式中派生类。只要一个表达式能够返回一个具有[[Construct]]属性以及原型的函数，就可以对其使用extends。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())             <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Rectangle被定义为ES5风格的构造器，而Square则是一个类。由于Rectangle具有[[Construct]]以及原型，Square类就能直接继承它。<br>extends后面能接受任意类型的表达式，这带来了巨大可能性，例如动态地决定所要继承的类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.length = length</span><br><span class="line">    <span class="keyword">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Rectangle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rectangle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">getBase</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())   <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(x <span class="keyword">instanceof</span> Rectangle)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>getBase()函数作为类声明的一部分被直接调用，它返回了Rectangle，是的此例的功能等价于前一个例子。并且由于可以动态地决定基类，就能创建不同的继承方式。例如可以有效地创建混入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> SerializableMixin = &#123;</span><br><span class="line">    serialize() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> AreaMixin = &#123;</span><br><span class="line">    getArea() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.length * <span class="keyword">this</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.assign(base.prototype, ...mixins)</span><br><span class="line">    <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">AreaMixin</span>, <span class="title">SerializableMixin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.length = length</span><br><span class="line">        <span class="keyword">this</span>.width = width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(x.getArea())</span><br><span class="line"><span class="built_in">console</span>.log(x.serialize())  <span class="comment">//&#123;length: 3, width: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>此例使用了混入（mixin）而不是传统继承。mixin()函数接受代表混入对象的任意数量的参数，它创建了一个名为base的函数，并将每个混入对象的属性都赋值到新函数的原型上。阐述随后返回，于是Square就能够对其使用extends关键字了。注意由于仍然使用了extends，就必须在构造器内调用super().<br>Square的实例既有来自AreaMixin的getArea()方法，又有来自SerilaizableMixin的serialize()方法，这是通过原型继承实现的。mixin()函数使用了混入对象的所有自有属性，动态地填充了新函数的原型（注意：若多个混入对象拥有相同的属性，则只有最后添加的属性会被保留）。<br>任意表达式都能在extends关键字后使用，但并非所有表达式的结果都是一个有效的类。特别的，下列表达式类型会导致错误：<br>null;<br>生成器函数<br>试图使用结果为上述值得表达式来创建一个新的类实例，都会抛出错误，因为不存在[[Construct]]可供调用。</p>
<h4 id="继承内置对象"><a href="#继承内置对象" class="headerlink" title="继承内置对象"></a>继承内置对象</h4><p>几乎从JS数组出现那天开始，开发者就像通过继承机制来创建它们自己的特殊数组类型。在ES5及早期版本中，这是不可能做到的。试图使用传统继承并不能产生功能正确的代码，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置数组的行为</span></span><br><span class="line"><span class="keyword">var</span> colors = []</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)</span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])  <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">// 在ES5中尝试继承数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">myArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: MyArray,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)  <span class="comment">//0</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])      <span class="comment">//red</span></span><br></pre></td></tr></table></figure>
<p>console.log()在此代码尾部的输出说明：对数组使用传统形式的JS继承，产生了预期外的行为。MyArray实例上的length属性以数值属性，其行为与内置数组并不一致，因为这些功能并未被涵盖在Array.apply()或数组原型中。<br>在ES6中的类，其设计目的之一就是允许从内置对象上进行继承。为了达成这个目的，类的继承模型与ES5或更早版本的传统继承模型有轻微差异：<br>在ES5的传统继承中，this的值会先被派生类（例如MyArray）创建，随后基类构造器（例如Array.apply()方法）才被调用。这意味着this一开始就是MyArray的实例，之后才使用了Array的附加属性对其进行了装饰。<br>在ES6基于类的继承中，this的值会先被基类（Array）创建，随后才被派生类的构造器（MyArray）所修改。结果是this初始就拥有作为基类的内置对象的所有功能，并能正确接收与之关联的所有功能。<br>一下范例实际展示了基于类的特殊数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">'red'</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length)    <span class="comment">//1</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>])    <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>MyArray直接继承了Array，因此工作方式与正规数组一致。与数值索引属性额互动更新了length属性，而操纵length属性也能更新索引属性。这意味着既能适当地继承Array来创建自己的派生数组类，也同样能继承其他的内置对象。</p>
<h4 id="Symbol-species属性"><a href="#Symbol-species属性" class="headerlink" title="Symbol.species属性"></a>Symbol.species属性</h4><p>继承内置对象一个有趣的方面是：任意能返回内置对象实例的方法，在派生类的实例。因此，若拥有类一个继承了Array的派生类MyArray，注入slice()之类的方法都会返回MyArray的实例。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">    subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray)  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>在此代码中，slice()方法返回了MyArray的一个实例。slice()方法是从Array上继承的，原本应当返回Array的一个实例。而Symbol.species属性在后台造成了这种变化。<br>Symbol.species是名符号被用于定义一个能返回函数的静态访问器属性。每当类实例的方法（构造器除外）必须常建一个实例时，前面返回的函数就被用为新实例的构造器。下列内置类型都定义了Symbol.species:<br>Array<br>ArrayBuffer<br>Map<br>Promise<br>RegExp<br>Set<br>类型化数组<br>以上每个类型都拥有默认的Symol.species属性，其返回值为this，意味着该属性总会返回自身的构造器函数。若准备在一个自定义类上实现此功能，代码就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 几个内置类型使用species的方式类似于此</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">    clone() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再此例中，Symbol.species知名符号被用于定义MyClass的一个静态访问器属性。注意此处只有getter而没有setter，这是因为修改累的species是不允许的。任何对this.constructor[Symbol.species]的调用都会返回MyClass，clone()方法使用了该定义来返回一个新的实例，而没有直接使用MyClass，这就允许派生类重写这个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    clone() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass1</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"><span class="comment">// 空代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDerivedClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> MyClass;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> MyDerivedClass1(<span class="string">"foo"</span>),</span><br><span class="line">clone1 = instance1.clone(),</span><br><span class="line">instance2 = <span class="keyword">new</span> MyDerivedClass2(<span class="string">"bar"</span>),</span><br><span class="line">clone2 = instance2.clone();</span><br><span class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyClass); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyDerivedClass1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyClass); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyDerivedClass2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>此处, MyDerivedClass1 继承了 MyClass ，并且未修改 Symbol.species 属性。由于this.constructor[Symbol.species] 会返回 MyDerivedClass1 ，当 clone() 被调用时，它就返回了 MyDerivedClass1 的一个实例。 MyDerivedClass2 类也继承了 MyClass ，但重写了Symbol.species ，让其返回 MyClass 。当 clone() 在 MyDerivedClass2 的一个实例上被调用时，返回值就变成 MyClass 的一个实例。使用 Symbol.species ，任意派生类在调用应当返回实例的方法时，都可以判断出需要返回什么类型的值。<br>例如， Array 使用了 Symbol.species 来指定方法所使用的类，让其返回值为一个数组。在Array 派生出的类中，你可以决定这些继承的方法应返回何种类型的对象，正如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">subitems = items.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>此代码重写了从 Array 派生的 MyArray 类上的 Symbol.species 。所有返回数组的继承方法现在都会使用 Array 的实例，而不是 MyArray 的实例。<br>一般而言，每当想在类方法中使用 this.constructor 时，你就应当设置类的Symbol.species 属性。这么做允许派生类轻易地重写方法的返回类型。此外，若你从一个拥有 Symbol.species 定义的类创建了派生类，要保证使用此属性，而不是直接使用构造器。</p>
<h4 id="在类构造器中使用new-target"><a href="#在类构造器中使用new-target" class="headerlink" title="在类构造器中使用new.target"></a>在类构造器中使用new.target</h4><p>在第三章你已学到了 new.target ，以及在调用函数的方式不同时它的值是如何变动的。你也可以在类构造器中使用 new.target ，来判断类是被如何被调用的。在简单情况下，new.target 就等于本类的构造器函数，正如下例；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target 就是 Rectangle</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
<p>此代码说明在 new Rectangle(3, 4) 被调用时， new.target 就等于 Rectangle 。类构造器被调用时不能缺少 new ，因此 new.target 属性就始终会在类构造器内被定义。不过这个值并不总是相同的。研究以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">        <span class="keyword">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new.target 就是 Square</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p>Square 调用了 Rectangle 构造器，因此当 Rectangle 构造器被调用时， new.target 等于Square 。这很重要，因为构造器能根据如何被调用而有不同行为，并且这给了更改这种行为的能力。例如，你可以使用 new.target 来创建一个抽象基类（一种不能被实例化的类），如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"This class cannot be instantiated directly."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape(); <span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 没有错误</span></span><br><span class="line"><span class="built_in">console</span>.log(y <span class="keyword">instanceof</span> Shape); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>此例中的 Shape 类构造器会在 new.target 为 Shape 的时候抛出错误，意味着 newShape() 永远都会抛出错误。然而，你依然可以将 Shape 用作一个基类，正如 Rectangle所做的那样。 super() 的调用执行了 Shape 构造器，而且 new.target 的值等于Rectangle ，因此该构造器能够无错误地继续执行。<br>由于调用类时不能缺少 new ，于是 new.target 属性在类构造器内部就绝不会是undefined 。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/02/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/02/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" class="post-title-link" itemprop="url">迭代器和生成器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-20 20:27:08" itemprop="dateCreated datePublished" datetime="2020-02-20T20:27:08+08:00">2020-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:30:53" itemprop="dateModified" datetime="2020-05-31T10:30:53+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="循环的问题"><a href="#循环的问题" class="headerlink" title="循环的问题"></a>循环的问题</h4><p>考虑如下代码区：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = colors.length; i &lt;len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(color[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个循环非常直观，然而当它被嵌套使用并要追踪多个变量时，情况就会变得非常复杂。额外的复杂度会引发错误，而for循环的样板性也增加了自身出错的可能性，因为相似的代码会被卸载多个地方。迭代器正式用来解决此问题的。</p>
<h4 id="何为迭代器"><a href="#何为迭代器" class="headerlink" title="何为迭代器"></a>何为迭代器</h4><p>迭代器是被设计专用于迭代的对象，带有特定接口。所有迭代器对象都拥有next()方法，会返回一个结果对象。该结果对象有两个属性，对应下一个值的value，一集一个布尔类型的done，其值为true时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了next()方法，迭代器就会返回相应的下一个值。<br>若在最后一个值返回后再调用next()，所返回的done属性值回事true，并且value属性值会是迭代器自身的返回值(return value，及时使用return语句明确返回值)。该“返回值”不是原数据集的一部分，去会成为相关数据的最后一个片段，或在迭代器未提供返回值时使用undefined。迭代器自身的返回值类似于函数的返回值，事项调用者返回信息的最后手段。<br>在ES5中床加一个迭代器代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= items.length)</span><br><span class="line">            <span class="keyword">var</span> value = !done?items[i++] : <span class="literal">undefined</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                valued: value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<h4 id="何为生成器"><a href="#何为生成器" class="headerlink" title="何为生成器"></a>何为生成器</h4><p><strong>生成器（generator）是能返回一个迭代器的函数。</strong>生成器函数由放在function关键字之后的一个星号（*)来表示，并能使用心得yield关键字。将星号紧跟在function关键字之后，或是在中间留出空格，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成器能想正规函数那样被调用，但会返回一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>createIterator()前面的星号让此函数变成一个生成器。yield关键字也是ES6新增的。<br>生成器函数最有意思的方面是在每个yield语句后停止执行。例如，此代码中yield 1执行后，该函数将不会再执行任何操作，直到迭代器的next()方法被调用，此时才继续执行yield 2。<br>yield关键字可以和值或是表达式一起使用，因此可以通过生成器给迭代器添加项目，而不是机械化地讲项目一个个列出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>生成器函数是ES6的一个重要特性，并且因为它就是函数，就能被用于所有可以使用函数的位置。<br>yield关键字只能用在生成器内部，用于其他任意位置都是语法错误，即使在生成器内部函数中也不行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 语法错误</span></span><br><span class="line">        <span class="keyword">yield</span> item + i</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管yield严格位于createIterator()内部，此代码仍然有语法错误，因为yield无法穿越函数边界。<strong>从这一点来说，yield和return非常相似，在一个被浅套的函数中无法将值返回给包含它的函数。</strong></p>
<h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>可以使用函数表达式来创建一个生成器，只要在function官架子与圆括号之间使用一个星号（*）即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;items.length; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> itertor = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>
<p>此例子中，createIterator()是一个生成器函数表达式，而不是一个函数声明。<br>**不能讲箭头函数创建为生成器。</p>
<h4 id="生成器对象方法"><a href="#生成器对象方法" class="headerlink" title="生成器对象方法"></a>生成器对象方法</h4><p>由于生成器就是函数，因此也可以被添加到对象中。例如，可以在ES5风格的对象字面量中使用函数表达式来创建一个生成器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    createIterator: <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下为ES6中语法</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    *createIterator(items) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> items[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h4 id="可迭代对象与for循环"><a href="#可迭代对象与for循环" class="headerlink" title="可迭代对象与for循环"></a>可迭代对象与for循环</h4><p>与迭代器紧密相关的是可迭代对象（iterable）是包含Symbol.iterator属性的对象。这个Symbol.iterator知名符号定义了未指定对象返回迭代器的函数。在ES6中，所有的集合对象（数组，Set和Map）一字符串都是可迭代对象。因此他们都被指定了默认的迭代器<br>之前提到过在for循环中追踪索引的问题。迭代器是解决此问题的第一部分；for-of循环则是第二部分：它完全删除了追踪集合索引的需要。代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> values) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在不可迭代对象、null、或者undefined上使用for-of语句会抛出错误TypeError: Cannot read property ‘Symbol(Symbol.iterator)’ of null。</p>
<h4 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h4><p>可以使用Symbol.iterator来访问对象上的默认迭代器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = values[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br></pre></td></tr></table></figure>

<p>既然Symbol.iterator指定了默认的迭代器，就可以使用它来检测一个对象是否能进行迭代：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'hello'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>()))</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>()))</span><br></pre></td></tr></table></figure>

<p>创建可迭代对象<br>利用Symbol.iterator属性， 让自定义的对象成为可迭代对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    items: [],</span><br><span class="line">    *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内置迭代器"><a href="#内置迭代器" class="headerlink" title="内置迭代器"></a>内置迭代器</h4><p>迭代器是ES6的一个重要部分，因此，无需为许多内置类型创建自己的迭代器。</p>
<h5 id="集合的迭代器"><a href="#集合的迭代器" class="headerlink" title="集合的迭代器"></a>集合的迭代器</h5><p>ES6具有三种集合对象类型：数组，Map与Set。这三种类型都拥有如下迭代器，有助于探索它们的内容：<br>entries(): 返回一个包含键值对的迭代器；<br>values(): 返回一个包含集合中的值得迭代器；<br>keys(): 返回一个包含集合中的键的迭代器</p>
<p>entries()迭代器<br>entries()迭代器会在每次next()被调用时返回一个双项数组，次数组代表了集合中每个元素的键与值：对于数组来说，第一项是数值索引；对于Set，第一项也是值（因为它的值也会被视为键）；对于Map，第一项就是键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'understanding es6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> colors.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> tracking.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用console.log()输出一下内容：<br>[0, “red”]<br>[1, “green”]<br>[2, “blue”]<br>[1234, 1234]<br>[5678, 5678]<br>[9012, 9012]<br>[“title”, “Understanding ES6”]<br>[“format”, “ebook”]<br>values()迭代器<br>values()迭代器仅仅能返回存储在集合内的值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'understanding es6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> tracking.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> data.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：<br>“red”<br>“green”<br>“blue”<br>12<br>34<br>56<br>“Understanding ES6”<br>“ebook”</p>
<p>keys()迭代器<br>keys()迭代器能返回集合中的每个键。对于数组来说，只返回数值类型的键，不返回数组的其他自有属性；Set的键与值是相同的，因此它的keys()与values()返回了相同的迭代器；对于Map，keys()迭代器返回了每个不重复的键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> Mpa()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'understanding es6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'ebook'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> colors.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> tracking.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> data.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：<br>0<br>1<br>2<br>12<br>34<br>56<br>“title”<br>“format”</p>
<p>集合类型的默认迭代器<br>当for-of循环没有显示指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。values()方法是数组与Set的默认迭代器，而entries()方法则是Map的默认迭代器。在for-of循环中使用集合对象时，这些默认迭代器会让处理更容易一些。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line"><span class="keyword">let</span> tracking = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>])</span><br><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">data.set(<span class="string">'title'</span>, <span class="string">'understanding es6'</span>)</span><br><span class="line">data.set(<span class="string">'format'</span>, <span class="string">'print'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> colors) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> tracking) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：<br>“red”<br>“green”<br>“blue”<br>1234<br>5678<br>9012<br>[“title”, “Understanding ES6”]<br>[“format”, “print”]</p>
<h4 id="字符串的迭代器"><a href="#字符串的迭代器" class="headerlink" title="字符串的迭代器"></a>字符串的迭代器</h4><p>从ES5发布开始，JS的字符串就慢慢变得越来越像数组。例如ES5标准化了字符串的方括号表示法，用于访问其中的字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">'A B'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;message.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：<br>A</p>
<p>B</p>
<h4 id="NodeList的迭代器"><a href="#NodeList的迭代器" class="headerlink" title="NodeList的迭代器"></a>NodeList的迭代器</h4><p>文档对象模型（DOM）具有一种NodeList类型，用于表示页面文档中元素的集合。对于需要书写在浏览器中运行的JS代码的开发者，要理解NodeList对象与数组之间的差异总是稍有困难。NodeList对象与数组都使用了length属性来表明项的数量，并且都使用方括号表示法来访问各个项。然而本质上来说，NodeList与数组的行为是完全不同的，这回引发许多混乱。<br>随着默认迭代器被附加到ES6，DOM关于NodeList的规定也包含了一个默认迭代器（此规定在HTML规范而非ES6规范中），其表现方式与数组的默认迭代器一致。这意味着你可以讲NodeList用于for-of循环，或用于其他使用对象默认迭代器的场合。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> divs) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(div.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符与非数组的可迭代对象"><a href="#扩展运算符与非数组的可迭代对象" class="headerlink" title="扩展运算符与非数组的可迭代对象"></a>扩展运算符与非数组的可迭代对象</h4><p>扩展运算符（…)能作用于所有可迭代对象，并且会使用默认迭代器来判断需要哪些值。<strong>所有的值都从迭代器中被读取出来并插入数组</strong>，遵循迭代器返回值的顺序。(利用扩展运算符还可以进行深度复制)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4])</span><br><span class="line">let array = [...<span class="keyword">set</span>]</span><br><span class="line">console.log(array)</span><br><span class="line">let map = new Map([['name', 'daming'], ['age', 25]])</span><br><span class="line">let array2 = [...map]</span><br><span class="line">console.log(array2)</span><br></pre></td></tr></table></figure>
<p>可以不限次数的在数组字面量中使用扩展运算符，而且可以在任意位置使用扩展运算符将可迭代对象的多个项插入数组，这些项在新数组中将会出现在扩展运算符对应的位置，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> smallNumbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">bigNumbers = [<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>],</span><br><span class="line">allNumbers = [<span class="number">0</span>, ...smallNumbers, ...bigNumbers]</span><br><span class="line"><span class="built_in">console</span>.log(allNumbers.length)</span><br><span class="line"><span class="built_in">console</span>.log(allNumbers)</span><br></pre></td></tr></table></figure>
<h4 id="迭代器的高级功能"><a href="#迭代器的高级功能" class="headerlink" title="迭代器的高级功能"></a>迭代器的高级功能</h4><p>使用迭代器的基本功能，并使用生成器来方便地创建迭代器，就可以完成很多工作了。然而，在单纯迭代集合的值之外的任务中，迭代器会显得更加强大。在ES6的开发过程中，许多独特的思想与模式出现了，激励着规定者去添加更多的功能。</p>
<h4 id="传递参数给迭代器"><a href="#传递参数给迭代器" class="headerlink" title="传递参数给迭代器"></a>传递参数给迭代器</h4><p>本章中的范例已经展示了迭代器能够将值传递出来，通过next()方法或者在生成器中使用yield都可以。但还可以通过next()方法向迭代器传递参数。当一个参数被传递给next()方法时，该参数就会成为生成器内部yield语句的值。这种能力对于更多高级功能（例如异步编程）来说是非常重要的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> zero = <span class="number">6</span></span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> zero + <span class="number">1</span>     <span class="comment">//6 + 1</span></span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>   <span class="comment">//4 + 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(second)            <span class="comment">//5</span></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span>               <span class="comment">//5 + 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(second)            <span class="comment">//5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">8</span>))   <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>))  <span class="comment">//&#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">5</span>))  <span class="comment">//&#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于next()的首次调用是一个特殊情况，传给它的任意参数都会被忽略。由于传递给next()的参数会成为yield语句的值，该yield语句指的是上次生成器中断执行处的语句；而next()方法第一次被调用时生成器函数才刚刚开始执行，没有所谓的上一次中断处的yield语句”可供赋值。因此在第一次调用next()时，不存在任何向其传递参数的理由。</p>
<h4 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h4><p>能传递给迭代器的不仅是数据，还可以是错误条件。迭代器可以选择实现一个throw()方法，用于指示迭代器应在恢复执行时抛出一个错误。这是对异步变成来说很重要的一个能力。同事也会增加生成器内部的灵活度，能够既模仿返回一个值，又模仿抛出错误（也就是退出函数的两种方式）。可以传递一个错误对象给throw()方法，当迭代器继续进行处理时应当抛出此错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())</span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Boom'</span>)))</span><br></pre></td></tr></table></figure>
<p>输出如下：<br>{ value: 1, done: false }<br>{ value: 6, done: false }<br>C:\Users\Administrator\Desktop\atHome.js:116<br>    let second = yield first + 2<br>                 ^<br>Error: Boom<br>    at Object.<anonymous> (C:\Users\Administrator\Desktop\atHome.js:124:28)<br>    at Module._compile (module.js:569:30)<br>    at Object.Module._extensions..js (module.js:580:10)<br>    at Module.load (module.js:503:32)<br>    at tryModuleLoad (module.js:466:12)<br>    at Function.Module._load (module.js:458:3)<br>    at Function.Module.runMain (module.js:605:10)<br>    at startup (bootstrap_node.js:158:16)<br>    at bootstrap_node.js:575:3<br>[Finished in 0.4s]<br>利用这些，可以在生成器内部使用一个try-catch块来捕捉这种错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> second</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        second = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        second = <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)); <span class="comment">// "&#123; value: 6, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom"</span>))); <span class="comment">// "&#123; value: 9, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器的return语句"><a href="#生成器的return语句" class="headerlink" title="生成器的return语句"></a>生成器的return语句</h4><p>由于生成器是函数，可以在内部使用return语句，既可以让生成器早一点退出执行，也可以指定在next()的最后一次调用时的返回值。之前大多数例子中，对迭代器上的next的最后一次调用都返回了undefined，但还可以像其他函数中那样，使用return来指定另一个返回值。生成器内，return表明所有的处理已经完成，因此done属性会被设定为true，而如果提供了返回值，就会被用于value字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())    <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>
<p>也可以指定一个返回值，会被用于最终返回的结果对象中的value字段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())      <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())      <span class="comment">// "&#123; value: 42, done: true &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())      <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器委托"><a href="#生成器委托" class="headerlink" title="生成器委托"></a>生成器委托</h4><p>在某些情况下，将两个迭代器的值合并器一起会更有用。<strong>生成器可以用星号（*）配合yield这一特殊形式来委托其他的迭代器。</strong>正如生成器的定义，星号出现在何处是不重要的，只要落在yield关键字与生成器函数名之间即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNuberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'red'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'green'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">    <span class="keyword">yield</span> *createColorIterator()</span><br><span class="line">    <span class="keyword">yield</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: "red", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: "green", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: true, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next())   <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<p>生成器委托也能让你进一步使用生成器的返回值。这是访问这些返回值的最简单方式，并且<br>在执行复杂任务时会非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"repeat"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">    <span class="keyword">yield</span> *createRepeatingIterator(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>
<p>注意值 3 从未在对于 next() 方法的任何调用中被输出。当前它仅仅存在于<br>createCombinedIterator() 生成器内部。但你也可以通过添加另一个 yield 语句来输出这个<br>值，正如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createRepeatingIterator</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"repeat"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">    <span class="keyword">yield</span> result</span><br><span class="line">    <span class="keyword">yield</span> *createRepeatingIterator(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 1, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 2, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: 3, done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: "repeat", done: false &#125;"</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// "&#123; value: undefined, done: true &#125;"</span></span><br></pre></td></tr></table></figure>

<h4 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h4><p>JS的异步编程是一把双刃剑：简单任务很容易用异步实现，但复杂任务就会变成代码组织方面的苦差事。由于生成器能让你在执行过程中有效的暂停代码操作，它就开启了与异步编程相关的许多可能性。<br>执行一步操作的传统铜方式是调用一个包含回调的函数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'config.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, contents</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能使用文件名与一个回调函数去调用fs.readFile()方法，在读取操作结束之后，回调函数就会被调用。此回调函数查看是否存在错误，若否则处理返回的contents数据。当拥有数量少而有限的任务需要完成时，这么做很有效；然而当需要嵌套回调函数，或者要按顺序处理一系列异步任务时，此方式就会非常麻烦了。这种场合下生成器与yield会很有用。</p>
<h4 id="一个简单的任务运行器"><a href="#一个简单的任务运行器" class="headerlink" title="一个简单的任务运行器"></a>一个简单的任务运行器</h4><p>由于yield能停止运行，并且在重新开始运行前等待next()方法被调用，就可以在没有回调函数的情况下实现异步调用。首先，需要一个能够调用生成器并且启用迭代器的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器，让它在别处可用</span></span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用函数来保持对next()的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            result = task.next()</span><br><span class="line">            setp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run()函数接受一个任务定义（即一个生成器函数）作为参数，它会调用生成器来创建一个迭代器，并将迭代器放在task变量上。task变量放在函数的外层，因此它可以被函数内的其他函数访问到。第一次对next()的调用启动了迭代器，结果存储下以便稍后使用。step()函数查看result.done是否为false，如果是就在递归调用自身之前调用next()方法。每次调用next()都会把返回的结果保存在result变量上，它总是会被最新的信息所重写。对于step()的出事调用启动了处理过程就，该过程会查看result.done来判断是否还有更多要做的工作。</p>
<p>配合这个已实现的 run() 函数，你就可以运行一个包含多条 yield 语句的生成器，就像这<br>样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此例只是将三个数值输出到控制台，单纯用于表明对 next() 的所有调用都已被执行。然<br>而，仅仅使用几次 yield 并不太有意义，下一步是要把值传进迭代器并获取返回数据。</p>
<h4 id="带数据的任务运行"><a href="#带数据的任务运行" class="headerlink" title="带数据的任务运行"></a>带数据的任务运行</h4><p>传递数据给任务运行器最简单的方式，就是把yield返回的值传入下一次的next()调用。为此，仅需传递result.value,正如一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            result = task.next(result.value)</span><br><span class="line">            step()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 result.value 作为参数被传递给了 next() ，这样就能在 yield 调用之间传递数据<br>了，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 1</span></span><br><span class="line">    value = <span class="keyword">yield</span> value + <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 4</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="异步任务运行器"><a href="#异步任务运行器" class="headerlink" title="异步任务运行器"></a>异步任务运行器</h4><p>上个例子只是在yield之间来回传递静态数据，但等待一个异步处理与此稍微有点差异。任务运行器需要了解回调函数，并了解如何使用它们。并且由于yield表达式将它们的值传递给了任务运行器，这就意味着函数调用都必须返回一个值，并以某种方式标明改返回值是个异步操作调用，二人舞运行器应当等待此操作。<br>此处是将返回值标明为异步操作的一种方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        callback(<span class="literal">null</span>, <span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码的目的是：任何打算让人物运行器调用的函数，都应当返回一个能够执行回调函数的函数。fetchData()函数所返回的函数能接受一个回调函数作为其参数，当返回的函数被调用时，它会执行回调函数并附加一点额外数据（即“hi”字符串）。该回调函数需要由任务运行器提供，以确保回调函数能与当前的迭代其正确交互。虽然fetchData()函数是同步的，但能延迟对回调函数的调用，从而轻易地将它改造为异步函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(<span class="literal">null</span>, <span class="string">'hi'</span>)</span><br><span class="line">        &#125;, <span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此版本的fetchData()再调用回调函数之前引入了50毫秒的延迟，说明此模式在同步或一部代码上都能良好运作。<strong>只要保证每个需要被yield调用的函数都遵循此模式。</strong><br>此版本的 fetchData() 在调用回调函数之前引入了 50 毫秒的延迟，说明此模式在同步或异<br>步代码上都能同样良好运作。你只要保证每个需要被 yield 调用的函数都遵循此模式。<br>在深入理解函数如何标注自己是一个异步处理后，你就可以结合这种模式来改造任务运行<br>器。只要 result.value 是一个函数，任务运行器就应当执行它，而不是仅仅将它传递给<br>next() 方法。此处有更新后的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">                result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        result = task.throw(err)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    result = task.next(data)</span><br><span class="line">                    step()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = task.next(result.value)</span><br><span class="line">                step()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 result.value 是个函数时（使用 === 运算符来判断），它会被使用一个回调函数进行调<br>用。该回调函数遵循了 Node.js 的惯例，将任何潜在错误作为第一个参数（ err ）传入，而<br>处理结果则作为第二个参数。若 err 非空，也就表示有错误发生，需要使用该错误对象去调<br>用 task.throw() ，而不是调用 task.next() ，这样错误就会在恰当的位置被抛出；若不存<br>在错误， data 参数将会被传入 task.next() ，而其调用结果也会被保存下来。接下来，调<br>用 step() 来继续处理过程。若 result.value 并非函数，它就会被直接传递给 next() 方<br>法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(filename, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 readFile() 方法接受单个参数，即文件名，并返回一个能执行回调函数的函数。此回<br>调函数会被直接传递给 fs.readFile() 方法，后者会在操作完成后执行回调。接下来你就可<br>以使用 yield 来运行这个任务，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">run(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">"config.json"</span>)</span><br><span class="line">    doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/iversoncurry/Blog.git/2020/02/15/Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog/images/avatar.gif">
      <meta itemprop="name" content="蚂蚁">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蚂蚁的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Blog/2020/02/15/Promise%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Promise与异步编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-15 20:27:08" itemprop="dateCreated datePublished" datetime="2020-02-15T20:27:08+08:00">2020-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 10:21:24" itemprop="dateModified" datetime="2020-05-31T10:21:24+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JS最强大的一方面就是它能极其轻易地处理异步编程。作为因为互联网而生的语言，JS从一开始就必须能够响应点击或按键之类的用户交互行为。Node.js通过使用回调函数来代替事件，进一步推动了JS中的异步编程。随着越来越多的程序开始使用异步编程，事件与回调函数已不足以支持开发者的所有需求。Promise正是为了解决这方面的问题。<br>Promise是异步编程的另一种选择，它的工作方式类似于在其他语言中延迟并在将来执行作业。一个Promise指定一些要稍后执行的代码（就像事件与回调函数一样），并且也明确标示了作业的代码是否执行成功。能以成功处理或失败处理为基准，将Promise串联在一起，让代码更容易理解，更易调试。</p>
<h2 id="异步编程的背景"><a href="#异步编程的背景" class="headerlink" title="异步编程的背景"></a>异步编程的背景</h2><p>JS引擎建立在单线程事件循环的概念上。单线程（Single-threaded）意味着同一时刻只能执行一段代码，与Java或C++这种允许同时执行多段不同代码的多线程语言形成了反差。多段代码可以同时访问或修改状态，委会并保护这些状态就变成了难题，这也是基于多线程的软件中出现bug的常见根源之一。<br>JS引擎在同一时刻只能执行一段代码，所以引擎无需留意那些“可能”运行的代码。代码会被放置在作业队列（job queue）中，每当一段代码准备执行，它就会被添加到作业队列。当JS引擎结束当前代码的执行后，事件循环就会执行队列中的写一个作业。事件循环（event loop）是JS引擎的一个内部处理线程，能监视代码的执行并管理作业队列。要记住，既然是一个队列，作业就会从队列中的第一个开始，一次运行到最后一个。</p>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>当用户点击一个按钮或按下键盘上的一个键时，一个事件（event）–例如 onclick –就被触发了。该事件可能会对此交互进行响应，从而将一个新的作业添加到作业队列的尾部。这就是JS关于异步编程的最基本形式。时间处理程序代码直到事件发生后才会被执行，此时它会拥有合适的上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = documet.getElementById(<span class="string">'my-btn'</span>)</span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码中，console.log(‘Clicked’)直到button被点击后才会被执行。当button被点击，赋值给onclick的函数就被添加到作业队列的尾部，并在队列前部所有任务结束之后再执行。<br>事件可以很好地工作于简单的交互，但将多个分离的异步调用串联在一起却会很麻烦，因为必须追踪每个事件的事件对象（例如上例中的button）。此外，还须确保所有的事件处理程序都能在事件第一次触发之前被绑定完毕。例如，若button在onclick被绑定之前就被点击，那就不会有任何事发生。因此虽然在响应用户交互或类似的低频功能时。事件很有用，但它在面对更复杂的需求时仍然不够灵活。</p>
<h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>当Node.js被创建时，它通过普及回调函数编程模式提升了异步编程模型。回调函数模式类似于事件模型，因为衣不带吗也会在会面的一个时间点才执行。不同之处在于需要调用的函数（即回调函数）时作为参数传入的，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'example.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br></pre></td></tr></table></figure>
<p>此例中使用了Node.js惯例，即错误优先（error-first）的回调函数风格。readFile()函数用于读取磁盘中的文件（由第一个参数指定），并在读取完成后执行回调函数（即第二个参数）。如果存在错误，回调函数的err参数回事一个错误对象；否则contents擦书就会以字符串形式包含文件内容。<br>使用回调函数模式，readFile()会立即开始执行，并在开始读取磁盘时暂停。这意味着console.log(‘hi’)会在readFile()被调用后立即进行输出，要早于console.log(contents)的打印操作。当readFile()结束操作后，它会将回调函数以及相关参数作为一个新的作业添加到作业队列的尾部。在之前的作业全部结束后，改作业才会执行。<br>回调函数模式要比事件模型灵活得多，因为使用回调函数串联多个调用会相对容易。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'example.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeFile(<span class="string">'example.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'File was written'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此代码中，对于readFile()的第一次成功调用引出了另一个异步调用，即调用writeFile()函数。注意这两个函数都使用了检查err的统一基本模式。当readFile()执行结束后，它添加一个作业到作业队列，从而导致writeFIle()在之后被调用（假设没有出现错误）。接下来，writeFile()也会在执行结束后项队列添加一个作业。<br>这种模式运作得相当好，但你可能会迅速察觉陷入了回调地狱（ callback hell ），这会在嵌<br>套过多回调函数时发生，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">throw</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> err</span><br><span class="line">                &#125;</span><br><span class="line">                method5(result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Promise基础"><a href="#Promise基础" class="headerlink" title="Promise基础"></a>Promise基础</h2><p><strong>Promise是为异步操作的结果所准备的占位符。</strong>函数可以返回一个Promise，而不必订阅一个事件或向函数传递一个回调参数，形式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'example.txt'</span>)</span><br></pre></td></tr></table></figure>
<p>在此代码中，readFile()实际上并未立即开始读取文件，这将会在稍后发生。此函数反而会返回一个Promise对象仪表室异步读取操作，因此可以在奖励啊再操作它。能对结果进行操作的确切时刻，完全取决于Promise的声明周期是如何进行的。</p>
<h3 id="Promise的声明周期"><a href="#Promise的声明周期" class="headerlink" title="Promise的声明周期"></a>Promise的声明周期</h3><p>每个Promise都会经历一个短暂的声明周期，出事为挂起态（pending state)，这表示异步操作尚未结束。一个挂起的Promise也被认为是未决的（unsettled）。上个例子中的Promise在readFile()函数返回它的时候就是出于挂起态。一旦异步操作结束，Promise就会被认为是已决的（settled），并进入两种可能状态之一。<br>1.已完成（fulfilled）：Promise的异步操作已成功结束；<br>2.已拒绝（rejected）：Promise的异步操作未成功结束，可能是一个错误，或有其他原因导致。<br>内部的[[PromiseState]]属性会被设置为”pending”,”fulfilled”或”rejected”，以反映Promise的状态。该属性并未在Promise对象上被暴露出来，因此无法已变成方式判断Promise到底处于哪种状态。不过可以使用then方法在Promise的状态改变时执行一些特定操作。<br>以下为Promise相关词汇的翻译：</p>
<ol>
<li>pending ：挂起，表示未结束的 Promise 状态。相关词汇“挂起态”。</li>
<li>fulfilled ：已完成，表示已成功结束的 Promise 状态，可以理解为“成功完成”。相关<br>词汇“完成”、“被完成”、“完成态”。</li>
<li>rejected ：已拒绝，表示已结束但失败的 Promise 状态。相关词汇“拒绝”、“被拒<br>绝”、“拒绝态”。</li>
<li>resolve ：决议，表示将 Promise 推向成功态，可以理解为“决议通过”，在 Promise<br>概念中与“完成”是近义词。相关词汇“决议态”、“已决议”、“被决议”。</li>
<li>unsettled ：未决，或者称为“未解决”，表示 Promise 尚未被完成或拒绝，与“挂<br>起”是近义词。</li>
<li>settled ：已决，或者称为“已解决”，表示 Promise 已被完成或拒绝。注意这与“已完<br>成”或“已决议”不同，“已决”的状态也可能是“拒绝态”（已失败）。</li>
<li>fulfillment handler ：完成处理函数，表示 Promise 为完成态时会被调用的函数。</li>
<li>rejection handler ：拒绝处理函数，表示 Promise 为拒绝态时会被调用的函数。</li>
</ol>
<p>then()方法在所有的Promise上都存在，并且接受两个参数。第一个参数是Promise被完成时要调用的函数，与异步操作关联的任何附加数据都会被传入这个完成函数。第二个参数则是Promise被拒绝时要调用的函数，与完成函数相似，拒绝函数会被传入与拒绝相关联的任何附加数据。<br>这种方式实现then()防范的任何对象都被称为一个thenable。所有的Promise都是thenable，繁殖则未必成立。<br>传递个then()的两个参数都是可选的，因此你可以监听完成与拒绝的任意组合形式。例如研究这组then()调用： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'exapmle.txt'</span>)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 完成</span></span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 拒绝</span></span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这三个then()调用都操作在同一个Promise上。第一个调用同时监听了完成与失败；第二个调用只监听了完成，错误不会被报告；第三个则只监听了拒绝，并不报告成功信息。<br>Promise也具有一个catch()方法，其行为等同于值传递拒绝函数给then()。例如，以下的catch()与then()调用时功能等效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>then()与catch()背后的意图是能组合使用来正确处理异步操作的结果。此系统要优于事件与回调函数，因为它让操作是成功还是失败变得完全清晰（事件模式倾向于在出错时不被触发，而在回调函数模式中你必须始终记得检查错误参数）。只需知道若未给出Promise附加拒绝处理函数，所有的错误就会静默发生。建议始终附加一个拒绝处理函数，及时该程序只是用于打印错误日志。<br>及时完成或拒绝处理函数在Promise已经被解决之后才添加到作业队列，它们仍然会被执行。这允许你随时添加新的完成或拒绝处理函数，并保证它们会被调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'example,txt'</span>)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">    promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(contents)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码中，完成处理函数又为同一个Promise添加了另一个完成处理函数。这个Promise此刻已经完成了，因此新的处理程序就被添加到任务队列，并在就绪时（前面的作业执行完毕后）被调用。拒绝处理函数使用同样方式工作。</p>
<p>每次调用then()或catch()都会创建一个新的作业，它会在Promise已决议时被执行。但这些作业最终会进入一个完全为Promise保留的作业队列。</p>
<h3 id="创建未决的Promise"><a href="#创建未决的Promise" class="headerlink" title="创建未决的Promise"></a>创建未决的Promise</h3><p>新的Promise使用Promise构造器来创建。此构造器接受单个参数：一个被称为执行器（executor）的函数，包含初始化Promise的代码。该执行器挥别传递两个名为resolve与reject()的函数作为参数。resolve()函数在执行器成功结束时被调用，由于示意该Promise已经准备好被决议（resolved），而reject()函数则表明执行器的操作已失败。下为范例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(fileName, &#123;<span class="attr">encoding</span>: <span class="string">'utf8'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            resolve(contents)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</span><br><span class="line"><span class="comment">// 同时监听完成与拒绝</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 完成</span></span><br><span class="line"><span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 拒绝</span></span><br><span class="line"><span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中，Node.js原生的fs.readFile()异步调用被包装在一个Promise中。执行器要么传递错误对象给reject()函数，要么传递文件内容给resoleve()函数。<br>要记住执行器会在readFile()被调用时立即运行。当resolve()或reject()在执行器内部被调用时，一个作业被添加到作业队列中，以便决议（resolve）这个Promeise。这被称为作业调度（job scheduling）。作业调度中，添加新作业到队列中时表示：“不要立刻执行这个作业，但要在稍后执行它”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过以下代码理解promise的执行顺序</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hhh'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'lll'</span>)</span><br><span class="line">        <span class="comment">// fs.readFile(fileName, &#123;encoding: 'utf8'&#125;, function(err, contents) &#123;</span></span><br><span class="line">        <span class="comment">//     console.log('%%%%%%%%%%%%%%%%%')</span></span><br><span class="line">        <span class="comment">//     if(err) &#123;</span></span><br><span class="line">        <span class="comment">//         reject(err)</span></span><br><span class="line">        <span class="comment">//         return</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     resolve(contents)</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        resolve(<span class="number">123</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">456</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'mimashiduoshao'</span>)</span><br><span class="line"><span class="comment">// 同时监听完成与拒绝</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 完成</span></span><br><span class="line"><span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 拒绝</span></span><br><span class="line"><span class="built_in">console</span>.error(err.message)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'woshimima'</span>)</span><br></pre></td></tr></table></figure>
<p>输出为：<br>hhh<br>lll<br>456<br>mimashiduoshao<br>woshimima<br>123</p>
<h3 id="创建已决的Promise"><a href="#创建已决的Promise" class="headerlink" title="创建已决的Promise"></a>创建已决的Promise</h3><p>基于Promise执行器行为的动态本质，Promise构造器就是创建未决的Promise的最好方法。但若想让一个Promise代表一个一直的值，那额安排一个淡出传值给resolve()函数的作业并没有意义。相反，有两种方法可以使用指定值来创建已决的Promise</p>
<h4 id="使用Promise-resolve"><a href="#使用Promise-resolve" class="headerlink" title="使用Promise.resolve()"></a>使用Promise.resolve()</h4><p>Promise.resolve()方法接受单个参数并会返回一个处于完成态的Promise。这意味着没有任何作业调度会发生，并且需要向PRomise添加一个或更多的完成处理函数来提取这个参数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码创建了一个已完成的Promise，因此完成处理函数就接收到42作为value参数。若一个拒绝处理函数被添加到此Promise，该拒绝处理函数将永不会被调用，因为此Promise绝不可能时拒绝态</p>
<h4 id="使用Promise-reject"><a href="#使用Promise-reject" class="headerlink" title="使用Promise.reject()"></a>使用Promise.reject()</h4><p>可以使用Promise.reject()方法来创建一个已拒绝的Promise。此方法向Promise.resolve()一样工作，区别是被创建的Promise处于拒绝态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="number">420</span>)</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>任何附加到这个Promise的拒绝处理函数都将会被调用，而完成处理函数则不会执行。</p>
<p>若你传递一个 Promise 给 Promise.resolve() 或 Promise.reject() 方法，该 Promise<br>会不作修改原样返回。<br>译注： 经过测试，在几大浏览器中都存在与上一句话不符的情况。</p>
<ol>
<li>若传入的 Promise 为挂起态，则 Promise.resolve() 调用会将该 Promise 原样返<br>回。此后，若决议原 Promise ，在 then() 中可以接收到原例中的参数 42 ；而若<br>拒绝原 Promise ，则在 catch() 中可以接收到参数 42 。 但 Promise.reject()<br>调用则会对原先的 Promise 重新进行包装，对其使用 catch() 可以捕捉到错误，<br>处理函数中的 value 参数不会是数值 42 ，而是原先处于挂起态的 Promise 。</li>
<li>若传入的 Promise 为完成态，则 Promise.resolve() 调用会将该 Promise 原样返<br>回，在 then() 中可以接收到原例中的参数 42 。 但 Promise.reject() 调用则会<br>对原先的 Promise 重新进行包装，对其使用 catch() 可以捕捉到错误，处理函数<br>中的 value 参数不会是数值 42 ，而是原先处于完成态的 Promise 。</li>
<li>若传入的 Promise 为拒绝态，则 Promise.reject() 调用会将该 Promise 原样返<br>回，在 catch() 中可以接收到参数 42 。 但 Promise.resolve() 调用则会对原先<br>的 Promise 重新进行包装，对其使用 then() 可以进行完成处理，处理函数中的<br>value 参数不是 42 ，而是原先处于拒绝态的 Promise 。也就是说此时的情况与<br>上一种情况相反。<br>总结：对挂起态或完成态的 Promise 使用 Promise.resolve() 没问题，会返回原<br>Promise ；对拒绝态的 Promise 使用 Promise.reject() 也没问题。而除此之外的情况全<br>都会在原 Promise 上包装出一个新的 Promise 。</li>
</ol>
<p><strong>实际测试</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> === <span class="string">'1'</span>) &#123;            <span class="comment">//写的有点别扭</span></span><br><span class="line">			reject(<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		resolve(<span class="number">1</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promiseResol = <span class="built_in">Promise</span>.resolve(<span class="number">11</span>)</span><br><span class="line"><span class="keyword">let</span> promiseRej = <span class="built_in">Promise</span>.resolve(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = testFunction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> returnP = <span class="built_in">Promise</span>.resolve(promise)</span><br><span class="line"><span class="keyword">let</span> returnPRej = <span class="built_in">Promise</span>.reject(promise)</span><br><span class="line"><span class="keyword">let</span> returnP1 = <span class="built_in">Promise</span>.resolve(promiseResol)</span><br><span class="line"><span class="keyword">let</span> returnPRej1 = <span class="built_in">Promise</span>.reject(promiseResol)</span><br><span class="line"><span class="keyword">let</span> returnP2 = <span class="built_in">Promise</span>.resolve(promiseRej)</span><br><span class="line"><span class="keyword">let</span> returnPRej2 = <span class="built_in">Promise</span>.reject(promiseRej)</span><br><span class="line"></span><br><span class="line">returnP.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnPthen'</span> + val)    <span class="comment">//returnPthen1</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnPcatch'</span> + val)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">returnPRej.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnPRejthen'</span> + val)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnPRejcatch'</span> + val)         <span class="comment">////returnPRejcatch[object Promise]</span></span><br><span class="line">	val.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'then'</span> + val)                <span class="comment">//then1</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'catch'</span> + val)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">returnP1.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnP1then'</span> + val)        <span class="comment">//returnP1then11</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnP1catch'</span> + val)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">returnPRej1.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnPRej1then'</span> + val)       </span><br><span class="line">	val.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'then'</span> + val)</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'catch'</span> + val)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnPRej1catch'</span> + val)    <span class="comment">//returnPRej1catch[object Promise]</span></span><br><span class="line">	val.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'then'</span> + val)            <span class="comment">//then11</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'catch'</span> + val)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">returnP2.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnP2then'</span> + val)            <span class="comment">//returnP2then12</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnP2catch'</span> + val)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">returnPRej2.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnPRej2then'</span> + val)</span><br><span class="line">	val.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'then'</span> + val)</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'catch'</span> + val)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'returnPRej2catch'</span> + val)         <span class="comment">//returnPRej2catch[object Promise]</span></span><br><span class="line">	val.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'then'</span> + val)                 <span class="comment">//then12</span></span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'catch'</span> + val)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>输出结果<br>returnPthen1<br>returnP1then11<br>returnP2then12<br>returnPRejcatch[object Promise]<br>returnPRej1catch[object Promise]<br>returnPRej2catch[object Promise]<br>then1<br>then11<br>then12<br><strong>当时用Promise.resolve()时，无论输入的promise是什么状态，都会返回promise，并且该promise的状态是已完成，结果是传入的promise的返回（完成或者拒绝），即都通过then返回。当时用Promise.reject()时，不论什么状态，都会在catch中返回一个promise，传入的promise为已决，则结果从该promise的then输出，若传入的promise为未决，则根据promise决议的结果从then或者catch返回。</strong></p>
<p>非Promise的Thenable<br>Promise.resolve()与Promise.reject()都能接受非Promise的thenable作为参数。当传入了非Promise的thenable时，这些方法会创建一个新的Promise，此Promise会在then函数之后被调用。<br>当一个对象拥有一个能接受resolve与reject参数的then()方法，该对象就会被认为是一个非Promise的thenable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h4><p>如果在执行器内部抛出了错误，那么Promise的拒绝处理函数就会被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'explosion!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message)       <span class="comment">//'explosion'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        reject(ex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message); <span class="comment">// "Explosion!"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行器处理程序捕捉了抛出的任何错误，以简化这种常见处理。但在执行器内抛出的错误仅<br>当存在拒绝处理函数时才会被报告，否则这个错误就会被隐瞒。这在开发者早期使用<br>Promise 的时候是一个问题，但 JS 环境通过提供钩子（ hook ）来捕捉被拒绝的 Promise ，<br>从而解决了此问题。</p>
<h3 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h3><p>Promise最有争议的方面之一就是：当一个Promise被拒绝时若缺少拒绝处理函数，就会静默失败。有人认为这是规范中最大的缺陷，因为这是JS语言左右组成部分中唯一不让错误清晰可见的。<br>由于Promise的本质，判断一个Promise的拒绝是否已被处理并不直观。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reject = <span class="built_in">Promise</span>.reject(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此刻rejected不会被处理</span></span><br><span class="line"><span class="comment">// 一段时间后</span></span><br><span class="line">reject.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>无论Promise是否已被解决，都可以在任何时候调用then()或catch()并使它们正确工作，这导致很难准确知道一个Promise合适会被处理。此例中的Promise被立刻拒绝，但它后来才被处理。<br>虽然下个版本的 ES 可能会处理此问题，不过浏览器与 Node.js 已经实施了变更来解决开发者<br>的这个痛点。这些变更不是 ES6 规范的一部分，但却是使用 Promise 时的宝贵工具。</p>
<h3 id="Node-js的拒绝处理"><a href="#Node-js的拒绝处理" class="headerlink" title="Node.js的拒绝处理"></a>Node.js的拒绝处理</h3><p>在Node.js中，process对象上存在两个关联到Promise的拒绝处理事件：<br>unhandledRejection：当一个Promise被拒绝，而在事件循环的一个轮次中没有任何拒绝处理函数被调用，改时间就会被触发；<br>rejectionHandled：若一个Promise被拒绝、并在时间循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。<br>这两个事件旨在共同帮助识别已被拒绝但未曾处理promise。<br>unhandledRejection 事件处理函数接受的参数是拒绝原因（常常是一个错误对象）以及已被<br>拒绝的 Promise 。以下代码展示了 unhandledRejection 的应用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason.message); <span class="comment">// "Explosion!"</span></span><br><span class="line">    <span class="built_in">console</span>.log(rejected === promise); <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>))</span><br></pre></td></tr></table></figure>

<p>此例创建了一个带有错误对象的已被拒绝的 Promise ，并监听了 unhandledRejection 事件。事件处理函数接收了该错误对象作为第一个参数，原 Promise 则是第二个参数。rejectionHandled 事件处理函数则只有一个参数，即已被拒绝的 Promise 。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rejected === promise) <span class="comment">// true</span></span><br><span class="line">&#125;)</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>))</span><br><span class="line"><span class="comment">// 延迟添加拒绝处理函数</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value.message); <span class="comment">// "Explosion!"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>此处的 rejectionHandled 事件在拒绝处理函数最终被调用时触发。若在 rejected 被创建后直接将拒绝处理函数附加到它上面，那么此事件就不会被触发。因为立即附加的拒绝处理函数在 rejected 被创建的事件循环的同一个轮次内就会被调用，这样 rejectionHandled 就不会起作用。为了正确追踪潜在的未被处理的拒绝，使用 rejectionHandled 与 unhandledRejection 事件就能保持包含这些 Promise 的一个列表，之后等待一段时间再检查此列表。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="comment">// 当一个拒绝未被处理，将其添加到 map</span></span><br><span class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.set(promise, reason)</span><br><span class="line">&#125;)</span><br><span class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.delete(promise)</span><br><span class="line">&#125;)</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line">        <span class="comment">// 做点事来处理这些拒绝</span></span><br><span class="line">        handleRejection(promise, reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    possiblyUnhandledRejections.clear()</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>
<p>对于未处理的拒绝，这只是个简单追踪器。它使用了一个 Map 来储存 Promise 及其拒绝原因，每个 Promise 都是键，而它的拒绝原因就是相关的值。每当 unhandledRejection 被触发， Promise 及其拒绝原因就会被添加到此 Map 中。而每当 rejectionHandled 被触发，已被处理的 Promise 就会从这个 Map 中被移除。这样一来， possiblyUnhandledRejections 就会随着事件的调用而扩展或收缩。 setInterval() 的调用会定期检查这个列表，查看可能未被处理的拒绝，并将其信息输出到控制台（在现实情况下，你可能会想做点别的事情，以便记录或处理该拒绝）。此例使用了一个 Map 而不是 Weak Map ，这是因为你需要定期检查此Map 来查看哪些 Promise 存在，而这是使用 Weak Map 所无法做到的。尽管此例仅针对 Node.js ，但浏览器也实现了类似的机制来将未处理的拒绝通知给开发者。</p>
<h3 id="浏览器的拒绝处理"><a href="#浏览器的拒绝处理" class="headerlink" title="浏览器的拒绝处理"></a>浏览器的拒绝处理</h3><p>浏览器同样能触发两个事件，来帮助识别未处理的拒绝。这两个事件会被 window 对象触发，并完全等效于 Node.js 的相关事件：<br>unhandledrejection ：当一个 Promise 被拒绝、而在事件循环的一个轮次中没有任何拒绝处理函数被调用，该事件就会被触发；<br>rejectionHandled ：若一个 Promise 被拒绝、并在事件循环的一个轮次之后再有拒绝处理函数被调用，该事件就会被触发。<br>Node.js 的实现会传递分离的参数给事件处理函数，而浏览器事件的处理函数则只会接收到包含下列属性的一个对象：<br>type ： 事件的名称（ “unhandledrejection” 或 “rejectionhandled” ）；<br>promise ：被拒绝的 Promise 对象；<br>reason ： Promise 中的拒绝值（拒绝原因）。<br>浏览器的实现中存在的另一个差异就是：拒绝值（ reason ）在两种事件中都可用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type) <span class="comment">// "unhandledrejection"</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.reason.message) <span class="comment">// "Explosion!"</span></span><br><span class="line">    <span class="built_in">console</span>.log(rejected === event.promise) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.type) <span class="comment">// "rejectionhandled"</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.reason.message) <span class="comment">// "Explosion!"</span></span><br><span class="line">    <span class="built_in">console</span>.log(rejected === event.promise) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rejected = Promise.reject(new Error(“Explosion!”));<br>此代码使用了 DOM 0 级写法的 onunhandledrejection 与 onrejectionhandled ，对两个事件处理函数都进行了赋值（若你喜欢，也可以使用 addEventListener(“unhandledrejection”) 与addEventListener(“rejectionhandled”) ）。每个事件处理函数都接收一个事件对象，其中包含与被拒绝的 Promise 有关的信息， type 、 promise 与 reason 属性都可用。以下代码在浏览器中追踪未被处理的拒绝，与 Node.js 的代码非常相似：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">// 当一个拒绝未被处理，将其添加到 map</span></span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.set(event.promise, event.reason);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.delete(event.promise)</span><br><span class="line">&#125;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line">        <span class="comment">// 做点事来处理这些拒绝</span></span><br><span class="line">        handleRejection(promise, reason)</span><br><span class="line">    &#125;)</span><br><span class="line">    possiblyUnhandledRejections.clear()</span><br><span class="line">&#125;, <span class="number">60000</span>)</span><br></pre></td></tr></table></figure>
<p>这个实现与 Node.js 的实现几乎一模一样。使用了相同方法在 Map 中存储 Promise 及其拒绝值，并在此后进行检查。唯一真正的区别就是在事件处理函数中信息是从何处被提取出来<br>的。<br>处理 Promise 的拒绝可能很麻烦，但你才刚开始见识 Promise 实际上到底有多强大。现在是时候更进一步了——把几个 promises 串联在一起使用。</p>
<h3 id="串联Promise"><a href="#串联Promise" class="headerlink" title="串联Promise"></a>串联Promise</h3><p>到此为止， Promise 貌似不过是个对组合使用回调函数与 setTimeout() 函数的增量改进，<br>然而 Promise 的内容远比表面上所看到的更多。更确切地说，存在多种方式来将 Promise 串<br>联在一起，以完成更复杂的异步行为。<br><strong>每次对 then() 或 catch() 的调用实际上创建并返回了另一个 Promise ，仅当前一个Promise 被完成或拒绝时，后一个 Promise 才会被决议。研究以下例子：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finished'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码输出：<br>42<br>finished<br>对 p1.then() 的调用返回了第二个 Promise ，又在这之上调用了 then() 。仅当第一个Promise 已被决议后，第二个 then() 的完成处理函数才会被调用。假若你在此例中不使用<br>串联，它看起来就会是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在这个无串联版本的代码中， p1.then() 的结果被存储在 p2 中，并且随后 p2.then() 被调用，以添加最终的完成处理函数。正如你可能已经猜到的，对于 p2.then() 的调用也返回了一个 Promise ，本例只是未使用此 Promise 。</p>
<h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p>Promise链允许捕获前一个Promise的完成或拒绝处理函数中发生的错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span> + value)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message)  <span class="comment">//boom42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码中，p1的完成处理函数抛出了一个错误，链式调用指向了第二个Promise上的catch()方法，能通过此拒绝处理函数接受前面的错误。若是一个拒绝处理函数抛出了错误，情况也一样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> newError(<span class="string">'Explosion'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error.message)  <span class="comment">//Explosion</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'boom'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    console.log(error.message</span>)   //<span class="title">boom</span></span></span><br><span class="line"><span class="function">))</span></span><br></pre></td></tr></table></figure>
<p>此处的执行器抛出了一个错误，就触发了 p1 这个 Promise 的拒绝处理函数，该处理函数随后抛出了另一个错误，并被第二个 Promise 的拒绝处理函数所捕获。链式 Promise 调用能察觉到链中其他 Promise 中的错误。<br>为了确保能正确处理任意可能发生的错误，应当始终在 Promise 链尾部添加拒绝处理函数。</p>
<h4 id="在Promise链中返回值"><a href="#在Promise链中返回值" class="headerlink" title="在Promise链中返回值"></a>在Promise链中返回值</h4><p>Promise链的另一种药方面是能从一个Promise传递数据给下一个Promise的能力。传递给执行器中的resolve()处理函数的参数，会被传递给对应Promise的完成处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)      <span class="comment">//42</span></span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)      <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>p1 的完成处理函数在被执行时返回了 value + 1 。由于 value 的值为 42 （来自执行器），此完成处理函数就返回了 43 。这个值随后被传递给第二个 Promise 的完成处理函数，并被其输出到控制台。<br>可以对拒绝处理函数做相同的事。当一个拒绝处理函数被调用时，它也能返回一个值。如果这么做，该值会被用于完成下一个 Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// "42"</span></span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// "43"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处的执行器使用 42 调用了 reject() ，该值被传递到这个 Promise 的拒绝处理函数中，从中又返回了 value + 1 。尽管后一个返回值是来自拒绝处理函数，它仍然被用于链中下一个Promise 的完成处理函数。若有必要，一个 Promise 的失败可以通过传递返回值来恢复整个Promise 链。</p>
<h3 id="在Promise链中返回Promise"><a href="#在Promise链中返回Promise" class="headerlink" title="在Promise链中返回Promise"></a>在Promise链中返回Promise</h3><p>从完成或拒绝处理函数中返回一个基本类型值，能够在Promise之间传递数据，但若返回的是一个对象呢？若该对象是一个Promise，那么需要采取一个额外步骤来决定如何处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Promsise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)   <span class="comment">//42</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)   <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此代码中， p1 安排了一个决议 42 的作业， p1 的完成处理函数返回了一个已处于决议态的 Promise ： p2 。由于 p2 已被完成，第二个完成处理函数就被调用了。而若 p2 被拒绝，会调用拒绝处理函数（如果存在的话），而不调用第二个完成处理函数。<br>关于此模式需认识的首要重点是第二个完成处理函数并未被添加到 p2 上，而是被添加到第三个 Promise 。正因为此，上个例子就等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)   <span class="comment">//42</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;)</span><br><span class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)   <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处清楚说明了第二个完成处理函数被附加给 p3 而不是 p2 。这是一个细微但重要的区<br>别，因为若 p2 被拒绝，则第二个完成处理函数就不会被调用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 第一个完成处理函数</span></span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 第二个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 永不被调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中，由于 p2 被拒绝了，第二个完成处理函数就永不被调用。不过你可以改为对其附加一个拒绝处理函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">43</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个完成处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 42</span></span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 拒绝处理函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处 p2 被拒绝，导致拒绝处理函数被调用，来自 p2 的拒绝值 43 会被传递给拒绝处理函数。从完成或拒绝处理函数中返回 thenable ，不会对 Promise 执行器何时被执行有所改变。第一个被定义的 Promise 将会首先运行它的执行器，接下来才轮到第二个 Promise 的执行器执行，以此类推。返回 thenable 只是让你能在 Promise 结果之外定义附加响应。你能通过在完成处理函数中创建一个新的 Promise ，来推迟完成处理函数的执行。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value) <span class="comment">// 42</span></span><br><span class="line">    <span class="comment">// 创建一个新的 promise</span></span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">43</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// 43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中，一个新的 Promise 在 p1 的完成处理函数中被创建。这意味着直到 p2 被完成之后，第二个完成处理函数才会执行。若你想等待前面的 Promise 被解决，之后才去触发另一个 Promise ，那么这种模式就非常有用。</p>
<h3 id="响应多个Promise"><a href="#响应多个Promise" class="headerlink" title="响应多个Promise"></a>响应多个Promise</h3><p>至今的每个例子在同一时刻都只响应一个 Promise 。然而有时会想监视多个 Promise的进程，以便决定下一步行动。 ES6 提供了能监视多个 Promise 的两个方法：Promise.all() 与 Promise.race()。</p>
<h4 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all()方法"></a>Promise.all()方法</h4><p>Promise.all()方法接收单个可迭代对象（如数组）作为参数，并返回一个Promise。这个可迭代对象的元素都是Promise，只有在它们都完成后，所返回的Promise才会被完成。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))  <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处前面的每个Promise都用一个数值进行了决议，对Promise.all()的调用创建了新的Promise p4，在p1，p2和p3都被完成后，p4最终也会被完成。传递给p4的完成处理函数的结果是一个包含每个决议值（42，42，43）的数组，这些值得存储顺序保持了待决议的Promise的顺序（**与完成的先后顺序无关），因此可以将结果匹配到每个Promise。<br>若传递给Promise.all()的任意Promise被拒绝了，那么方法所返回的Promise就会立即被拒绝，而不必等待其他的Promise结束：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))   <span class="comment">//false</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)                  <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中，p2被使用数值43进行了拒绝，则p4的拒绝处理函数就立刻被调用，而不会等待p1或p3结束执行（它们任然会各自结束执行，只是p4不等它们）。<br>拒绝处理函数总会接收到单个值，而不是一个数组，该值就是被拒绝的Promise所返回的拒绝值。本例中的决绝处理函数被传入了43，反映了来自p2的拒绝。</p>
<h4 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race()方法"></a>Promise.race()方法</h4><p>Promise.race()提供了监视多个Promise的一个稍微不同的方法。此方法也接受一个包含需要监视的Promise的可迭代对象，并返回一个新的Promise，但一旦来源Promise中有一个被解决，所返回的Promise就会立刻被解决。等待所有Promise完成的Promise.all()方法不同，来自源Promise中任意一个被完成时，Promise.race()方法所返回的Promise就能作出响应。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3])</span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log()     <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此代码中， p1 被创建为一个已完成的 Promise ，而其他的 Promise 则需要调度作业。p4 的完成处理函数被使用数值 42 进行了调用，并忽略了其他的 Promise 。传递给Promise.race() 的 Promise 确实在进行赛跑，看哪一个首先被解决。若胜出的 Promise 是被完成，则返回的新 Promise 也会被完成；而胜出的 Promise 若是被拒绝，则新 Promise 也会被拒绝。此处有个使用拒绝的范例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.reject(<span class="number">43</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">44</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3])</span><br><span class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此处的 p4 被拒绝了，因为 p2 在 Promise.race() 被调用时已经处于拒绝态。尽管 p1 与p3 都被完成，其结果仍然被忽略，因为这发生在 p2 被拒绝之后。</p>
<h3 id="继承Promise"><a href="#继承Promise" class="headerlink" title="继承Promise"></a>继承Promise</h3><p>正像其他内置类型，可将一个Promise用作派生类的基类。这允许你自定义变异的Promise，在内置Promise的基础上扩展功能，例如假设想创建一个可以使用succss()和failure()方法的Promise，对常规的then()和catch()方法进行扩展，可以像下面这样创建该Promise类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    success(resolve, reject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    failure(reject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catch(reject)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;).failure(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此例中， MyPromise 从 Promise 上派生出来，并拥有两个附加方法。 success() 方法模拟了 resolve() ， failure() 方法则模拟了 reject() 。<br>每个附加方法都使用了 this 来调用它所模拟的方法。派生的 Promise 函数与内置的Promise 几乎一样，除了可以随你需要调用 success() 与 failure() 。<br>由于静态方法被继承了， MyPromise.resolve() 方法、 MyPromise.reject() 方法、MyPromise.race() 方法与 MyPromise.all() 方法在派生的 Promise 上都可用。后两个方法的行为等同于内置的方法，但前两个方法则有轻微的不同。<br>MyPromise.resolve() 与 MyPromise.reject() 都会返回 MyPromise 的一个实例，无视传递进来的值的类型，这是由于这两个方法使用了 Symbol.species 属性（详见第九章）来决定需要返回的 Promise 的类型。若传递内置 Promise 给这两个方法，将会被决议或被拒绝，并且会返回一个新的 MyPromise ，以便绑定完成或拒绝处理函数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = MyPromise.resolve(p1)</span><br><span class="line">p2.MyPromise.resolve(p1)</span><br><span class="line">p2.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)  <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> MyPromise)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>此处的p1是一个内置的Promise，被传递给了MyPromise.resolve()方法。作为结果的p2是MyPromise的一个实例，来自p1的决议值被传递给了p2的完成处理函数。<br>若MyPromise的一个实例被传递给了MyPromise.resolve()或MyPromise.reject()方法，它会在未被决议的情况下就被直接返回。其他情况下，这两个方法的行为都会等同于Promise.resolve()与Promise.reject()</p>
<h3 id="异步任务运行"><a href="#异步任务运行" class="headerlink" title="异步任务运行"></a>异步任务运行</h3><p>可以像如下方案进行异步任务运行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器，让它在别处可用</span></span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line">    <span class="comment">// 开始任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line">    <span class="comment">// 递归使用函数来保持对next()的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> result.value === <span class="string">'function'</span>) &#123;</span><br><span class="line">                result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                        result = task.throw(err)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    result = task.next(data)</span><br><span class="line">                    step()</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = task.next(result.value)</span><br><span class="line">                step()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始处理过程</span></span><br><span class="line">    step()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个函数来配合任务运行器使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(filename, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">'config.json'</span>)</span><br><span class="line">    doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此实现存在一些痛点。首先，将每个函数包裹在另一个函数内，再返回一个新函数，这是有点令人困惑的。其次，返回值为函数的情况下，没有任何方法可以区分它是否应当被作为任务运行器的回调函数。<br>借助Promise，可以确保每个异步操作都返回一个Promise，从而大幅度简化并一般化异步处理，通过接口也意味着可以大大减少异步代码。此处有一个简化异步任务运行器的方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    <span class="keyword">let</span> task = taskDef()</span><br><span class="line">    <span class="comment">// 启动任务</span></span><br><span class="line">    <span class="keyword">let</span> result = task.next()</span><br><span class="line">    <span class="comment">// 递归使用函数来进行迭代</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.done) &#123;</span><br><span class="line">            <span class="comment">// 决议一个Promise，让任务处理变简单</span></span><br><span class="line">            <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(result.value)</span><br><span class="line">            promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                result = task.next(value)</span><br><span class="line">                step()</span><br><span class="line">            &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">                result = task.throw(error)</span><br><span class="line">                step()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数来配合任务运行器使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(contents)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行一个任务</span></span><br><span class="line">run(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> contents = <span class="keyword">yield</span> readFile(<span class="string">'config.json'</span>)</span><br><span class="line">    doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在此版本的代码中，一个通用的 run() 函数执行了生成器来创建一个迭代器。它调用了task.next() 来启动任务，并递归调用 step() 直到迭代完成。<br>在 step() 函数内部，如果还有更多工作要做，那么 result.done 的值会是 false ，此时result.value 应当是一个 Promise ，不过调用 Promise.resolve() 只为预防未正确返回Promise 的函数（记住： Promise.resolve() 在被传入任意 Promise 时只会直接将其传递回来，而不是 Promise 的参数则会被包装为 Promise ）。接下来，一个完成处理函数被添加以便提取该 Promise 值，并将该值传回迭代器。此后，在 step() 函数调用自身之前，result 被赋值为下一个 yield 的结果。<br>一个拒绝处理函数将任意拒绝结果存储在一个错误对象中。 task.throw() 方法将这个错误对象传回给迭代器，而若一个错误在任务中被捕获， result 也会被赋值为下一个 yield 的结果，这样 step() 最终在 catch() 内部就会被调用，以便继续任务执行。run() 函数能运行任意使用 yield 来实现异步代码的生成器，而不会将 Promise （或回调函数）暴露给开发者。事实上，由于函数调用后的返回值总是会被转换为一个 Promise ，该函数甚至允许返回 Promise 之外的类型。这意味着同步与异步方法在使用 yield 时都会正常工作，并且你永不需要检查返回值是否为一个 Promise 。唯一需要担心的是，要确保诸如 readFile() 的异步方法能返回一个正确标记其状态的Promise 。对于 Node.js 内置的方法来说，这意味着你必须转换这些方法，让它们返回Promise 而不是使用回调函数。<br>未来的异步任务运行<br>在我写这本书的时候，针对 JS 中的异步任务运行，为之引入简单语法的一项工作正在进行。此工作开展在 await 语法上，极度借鉴了上述以 Promise 为基础的例子。其基本理念是使用一个被 async 标记的函数（而非生成器），并在调用另一个函数时使用await 而非 yield ，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> contents = <span class="keyword">await</span> readFile(<span class="string">"config.json"</span>);</span><br><span class="line">doSomethingWith(contents)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Done"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在 function 之前的 async 关键字标明了此函数使用异步方式运行。 await 关键字则表示对于 readFile(“config.json”) 的函数调用应返回一个 Promise ，若返回类型不对，则会将其包装为 Promise 。与上述 run() 的实现一致， await 会在 Promise 被拒绝的情况下抛出错误，否则它将返回该 Promise 被决议的值。最终结果是你可以将异步代码当作同步代码来书写，而无须为管理基于迭代器的状态机而付出额外开销。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/Blog/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/Blog/">1</a><a class="page-number" href="/Blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/Blog/page/4/">4</a><a class="extend next" rel="next" href="/Blog/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">蚂蚁</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蚂蚁</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog/lib/anime.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.min.js"></script>
  <script src="/Blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog/js/utils.js"></script>

<script src="/Blog/js/motion.js"></script>


<script src="/Blog/js/schemes/pisces.js"></script>


<script src="/Blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
