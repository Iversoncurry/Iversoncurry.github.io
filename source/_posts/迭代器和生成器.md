---
title: 迭代器和生成器
date: 2020-02-20 20:27:08
tags:
---

#### 循环的问题
考虑如下代码区：
```Js
var colors = ['red', 'green', 'blue']
for (var i = 0, len = colors.length; i <len; i++) {
    console.log(color[i])
}
```
虽然这个循环非常直观，然而当它被嵌套使用并要追踪多个变量时，情况就会变得非常复杂。额外的复杂度会引发错误，而for循环的样板性也增加了自身出错的可能性，因为相似的代码会被卸载多个地方。迭代器正式用来解决此问题的。
#### 何为迭代器
迭代器是被设计专用于迭代的对象，带有特定接口。所有迭代器对象都拥有next()方法，会返回一个结果对象。该结果对象有两个属性，对应下一个值的value，一集一个布尔类型的done，其值为true时表示没有更多值可供使用。迭代器持有一个指向集合位置的内部指针，每当调用了next()方法，迭代器就会返回相应的下一个值。
若在最后一个值返回后再调用next()，所返回的done属性值回事true，并且value属性值会是迭代器自身的返回值(return value，及时使用return语句明确返回值)。该“返回值”不是原数据集的一部分，去会成为相关数据的最后一个片段，或在迭代器未提供返回值时使用undefined。迭代器自身的返回值类似于函数的返回值，事项调用者返回信息的最后手段。
在ES5中床加一个迭代器代码如下：
```Js
function createIterator(items) {
    var i = 0
    return {
        next: function() {
            var done = (i >= items.length)
            var value = !done?items[i++] : undefined
            return {
                done: done,
                valued: value
            }
        }
    }
}
var iterator = createIterator([1,2,3])
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())

console.log(iterator.next())
```
#### 何为生成器
**生成器（generator）是能返回一个迭代器的函数。**生成器函数由放在function关键字之后的一个星号（*)来表示，并能使用心得yield关键字。将星号紧跟在function关键字之后，或是在中间留出空格，如下：
```Js
// 生成器
function *createIterator() {
    yield 1
    yield 2
    yield 3
}
// 生成器能想正规函数那样被调用，但会返回一个迭代器
let iterator = createIterator()
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
```
createIterator()前面的星号让此函数变成一个生成器。yield关键字也是ES6新增的。
生成器函数最有意思的方面是在每个yield语句后停止执行。例如，此代码中yield 1执行后，该函数将不会再执行任何操作，直到迭代器的next()方法被调用，此时才继续执行yield 2。
yield关键字可以和值或是表达式一起使用，因此可以通过生成器给迭代器添加项目，而不是机械化地讲项目一个个列出：
```Js
function *createIterator(items) {
    for (let i = 0; i < items.length; i++) {
        yield items[i]
    }
}

let iterator = createIterator([1, 2, 3])
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
```
生成器函数是ES6的一个重要特性，并且因为它就是函数，就能被用于所有可以使用函数的位置。
yield关键字只能用在生成器内部，用于其他任意位置都是语法错误，即使在生成器内部函数中也不行：
```Js
function *createIterator(items) {
    items.forEach(function(item) {
        // 语法错误
        yield item + i
    })
}
```
尽管yield严格位于createIterator()内部，此代码仍然有语法错误，因为yield无法穿越函数边界。**从这一点来说，yield和return非常相似，在一个被浅套的函数中无法将值返回给包含它的函数。**
#### 生成器表达式
可以使用函数表达式来创建一个生成器，只要在function官架子与圆括号之间使用一个星号（*）即可：
```Js
let createIterator = function *(items) {
    for (let i = 0; i <items.length; i++) {
        yield items[i]
    }
}
let itertor = createIterator([1, 2, 3])
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
```
此例子中，createIterator()是一个生成器函数表达式，而不是一个函数声明。
**不能讲箭头函数创建为生成器。
#### 生成器对象方法
由于生成器就是函数，因此也可以被添加到对象中。例如，可以在ES5风格的对象字面量中使用函数表达式来创建一个生成器：
```Js
var o = {
    createIterator: function *(items) {
        for (let i = 0; i < items.length; i++) {
            yield items[i]
        }
    }
}
var iterator = o.createIterator([1, 2, 3])

// 以下为ES6中语法
var o = {
    *createIterator(items) {
        for (let i = 0; i < items.length; i++) {
            yield items[i]
        }
    }
}
let iterator = o.createIterator([1, 2, 3])
```

#### 可迭代对象与for循环
与迭代器紧密相关的是可迭代对象（iterable）是包含Symbol.iterator属性的对象。这个Symbol.iterator知名符号定义了未指定对象返回迭代器的函数。在ES6中，所有的集合对象（数组，Set和Map）一字符串都是可迭代对象。因此他们都被指定了默认的迭代器
之前提到过在for循环中追踪索引的问题。迭代器是解决此问题的第一部分；for-of循环则是第二部分：它完全删除了追踪集合索引的需要。代码如下:
```Js
var values = [1, 2, 3]
for (let num of values) {
    console.log(num)
}
```
在不可迭代对象、null、或者undefined上使用for-of语句会抛出错误TypeError: Cannot read property 'Symbol(Symbol.iterator)' of null。
#### 访问默认迭代器
可以使用Symbol.iterator来访问对象上的默认迭代器：
```Js
let values = [1, 2, 3]
let iterator = values[Symbol.iterator]()
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.next())
```

既然Symbol.iterator指定了默认的迭代器，就可以使用它来检测一个对象是否能进行迭代：
```Js
function isIterable(object) {
    return typeof object[Symbol.iterator] === 'function'
}

console.log(isIterable([1, 2, 3]))
console.log(isIterable('hello'))
console.log(isIterable(new Map()))
console.log(isIterable(new Set()))
console.log(isIterable(new WeakMap()))
console.log(isIterable(new WeakSet()))
```

创建可迭代对象
利用Symbol.iterator属性， 让自定义的对象成为可迭代对象：
```Js
let collection = {
    items: [],
    *[Symbol.iterator]() {
        for (let item of this.items) {
            yield item
        }
    }
}

collection.items.push(1)
collection.items.push(2)
collection.items.push(3)

for (let x of collection) {
    console.log(x)
}
```

#### 内置迭代器
迭代器是ES6的一个重要部分，因此，无需为许多内置类型创建自己的迭代器。
##### 集合的迭代器
ES6具有三种集合对象类型：数组，Map与Set。这三种类型都拥有如下迭代器，有助于探索它们的内容：
entries(): 返回一个包含键值对的迭代器；
values(): 返回一个包含集合中的值得迭代器；
keys(): 返回一个包含集合中的键的迭代器

entries()迭代器
entries()迭代器会在每次next()被调用时返回一个双项数组，次数组代表了集合中每个元素的键与值：对于数组来说，第一项是数值索引；对于Set，第一项也是值（因为它的值也会被视为键）；对于Map，第一项就是键。

```Js
let colors = ['red', 'green', 'blue']
let tracking = new Set([12, 34, 56, 78])
let data = new Map()

data.set('title', 'understanding es6')
data.set('format', 'ebook')

for (let entry of colors.entries()) {
    console.log(entry)
}

for (let entry of tracking.entries()) {
    console.log(entry)
}

for (let entry of data.entries()) {
    console.log(entry)
}
```
调用console.log()输出一下内容：
[0, "red"]
[1, "green"]
[2, "blue"]
[1234, 1234]
[5678, 5678]
[9012, 9012]
["title", "Understanding ES6"]
["format", "ebook"]
values()迭代器
values()迭代器仅仅能返回存储在集合内的值，例如：
```Js
let colors = ['red', 'green', 'blue']
let tracking = new Set([12, 34, 56])
let data = new Map()

data.set('title', 'understanding es6')
data.set('format', 'ebook')
for (let value of colors.values()) {
    console.log(value)
}
for (let value of tracking.values()) {
    console.log(value)
}
for (let value of data.values()) {
    console.log(value)
}
```
输出为：
"red"
"green"
"blue"
12
34
56
"Understanding ES6"
"ebook"

keys()迭代器
keys()迭代器能返回集合中的每个键。对于数组来说，只返回数值类型的键，不返回数组的其他自有属性；Set的键与值是相同的，因此它的keys()与values()返回了相同的迭代器；对于Map，keys()迭代器返回了每个不重复的键。
```Js
let colors = ['red', 'green', 'blue']
let tracking = new Set([12, 34, 56])
let data = new Mpa()

data.set('title', 'understanding es6')
data.set('format', 'ebook')

for (let key of colors.keys()) {
    console.log(key)
}
for (let key of tracking.keys()) {
    console.log(key)
}
for (let key of data.keys()) {
    console.log(key)
}
```
输出为：
0
1
2
12
34
56
"title"
"format"

集合类型的默认迭代器
当for-of循环没有显示指定迭代器时，每种集合类型都有一个默认的迭代器供循环使用。values()方法是数组与Set的默认迭代器，而entries()方法则是Map的默认迭代器。在for-of循环中使用集合对象时，这些默认迭代器会让处理更容易一些。
```Js
let colors = ['red', 'green', 'blue']
let tracking = new Set([12, 34, 56])
let data = new Map()

data.set('title', 'understanding es6')
data.set('format', 'print')

for (let value of colors) {
    console.log(value)
}
for (let num of tracking) {
    console.log(num)
}
for (let entry of data) {
    console.log(entry)
}
```
输出为：
"red"
"green"
"blue"
1234
5678
9012
["title", "Understanding ES6"]
["format", "print"]

#### 字符串的迭代器
从ES5发布开始，JS的字符串就慢慢变得越来越像数组。例如ES5标准化了字符串的方括号表示法，用于访问其中的字符。
```Js
var message = 'A B'
for (let i=0;i<message.length; i++) {
    console.log(message[i])
}
```
输出为：
A

B



#### NodeList的迭代器
文档对象模型（DOM）具有一种NodeList类型，用于表示页面文档中元素的集合。对于需要书写在浏览器中运行的JS代码的开发者，要理解NodeList对象与数组之间的差异总是稍有困难。NodeList对象与数组都使用了length属性来表明项的数量，并且都使用方括号表示法来访问各个项。然而本质上来说，NodeList与数组的行为是完全不同的，这回引发许多混乱。
随着默认迭代器被附加到ES6，DOM关于NodeList的规定也包含了一个默认迭代器（此规定在HTML规范而非ES6规范中），其表现方式与数组的默认迭代器一致。这意味着你可以讲NodeList用于for-of循环，或用于其他使用对象默认迭代器的场合。例如：
```Js
var divs = document.getElementsByTagName('div')
for (let div of divs) {
    console.log(div.id)
}
```

#### 扩展运算符与非数组的可迭代对象
扩展运算符（...)能作用于所有可迭代对象，并且会使用默认迭代器来判断需要哪些值。**所有的值都从迭代器中被读取出来并插入数组**，遵循迭代器返回值的顺序。(利用扩展运算符还可以进行深度复制)
```Js
let set = new Set([1, 2, 3, 4])
let array = [...set]
console.log(array)
let map = new Map([['name', 'daming'], ['age', 25]])
let array2 = [...map]
console.log(array2)
```
可以不限次数的在数组字面量中使用扩展运算符，而且可以在任意位置使用扩展运算符将可迭代对象的多个项插入数组，这些项在新数组中将会出现在扩展运算符对应的位置，例如：
```Js
let smallNumbers = [1, 2, 3],
bigNumbers = [100, 101, 102],
allNumbers = [0, ...smallNumbers, ...bigNumbers]
console.log(allNumbers.length)
console.log(allNumbers)
```
#### 迭代器的高级功能
使用迭代器的基本功能，并使用生成器来方便地创建迭代器，就可以完成很多工作了。然而，在单纯迭代集合的值之外的任务中，迭代器会显得更加强大。在ES6的开发过程中，许多独特的思想与模式出现了，激励着规定者去添加更多的功能。

#### 传递参数给迭代器
本章中的范例已经展示了迭代器能够将值传递出来，通过next()方法或者在生成器中使用yield都可以。但还可以通过next()方法向迭代器传递参数。当一个参数被传递给next()方法时，该参数就会成为生成器内部yield语句的值。这种能力对于更多高级功能（例如异步编程）来说是非常重要的。
```Js
function *createIterator() {
    let zero = 6
    let first = yield zero + 1     //6 + 1
    let second = yield first + 2   //4 + 2
    console.log(second)            //5
    yield second + 3               //5 + 3
    console.log(second)            //5
}

let iterator = createIterator()

console.log(iterator.next(8))   // {value: 1, done: false}
console.log(iterator.next(4))  //{value: 6, done: false}
console.log(iterator.next(5))  //{value: 8, done: false}
console.log(iterator.next())   //{value: undefined, done: true}
```
对于next()的首次调用是一个特殊情况，传给它的任意参数都会被忽略。由于传递给next()的参数会成为yield语句的值，该yield语句指的是上次生成器中断执行处的语句；而next()方法第一次被调用时生成器函数才刚刚开始执行，没有所谓的上一次中断处的yield语句”可供赋值。因此在第一次调用next()时，不存在任何向其传递参数的理由。

#### 在迭代器中抛出错误
能传递给迭代器的不仅是数据，还可以是错误条件。迭代器可以选择实现一个throw()方法，用于指示迭代器应在恢复执行时抛出一个错误。这是对异步变成来说很重要的一个能力。同事也会增加生成器内部的灵活度，能够既模仿返回一个值，又模仿抛出错误（也就是退出函数的两种方式）。可以传递一个错误对象给throw()方法，当迭代器继续进行处理时应当抛出此错误：
```Js
function *createIterator() {
    let first = yield 1
    let second = yield first + 2
    yield second + 3
}

let iterator = createIterator()

console.log(iterator.next())
console.log(iterator.next())
console.log(iterator.throw(new Error('Boom')))
```
输出如下：
{ value: 1, done: false }
{ value: 6, done: false }
C:\Users\Administrator\Desktop\atHome.js:116
    let second = yield first + 2
                 ^
Error: Boom
    at Object.<anonymous> (C:\Users\Administrator\Desktop\atHome.js:124:28)
    at Module._compile (module.js:569:30)
    at Object.Module._extensions..js (module.js:580:10)
    at Module.load (module.js:503:32)
    at tryModuleLoad (module.js:466:12)
    at Function.Module._load (module.js:458:3)
    at Function.Module.runMain (module.js:605:10)
    at startup (bootstrap_node.js:158:16)
    at bootstrap_node.js:575:3
[Finished in 0.4s]
利用这些，可以在生成器内部使用一个try-catch块来捕捉这种错误：
```Js
function *createIterator() {
    let first = yield 1
    let second

    try {
        second = yield first + 2
    } catch (ex) {
        second = 6
    }

    yield second + 3
}

let iterator = createIterator();
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next(4)); // "{ value: 6, done: false }"
console.log(iterator.throw(new Error("Boom"))); // "{ value: 9, done: false }"
console.log(iterator.next()); // "{ value: undefined, done: true }"
```

#### 生成器的return语句
由于生成器是函数，可以在内部使用return语句，既可以让生成器早一点退出执行，也可以指定在next()的最后一次调用时的返回值。之前大多数例子中，对迭代器上的next的最后一次调用都返回了undefined，但还可以像其他函数中那样，使用return来指定另一个返回值。生成器内，return表明所有的处理已经完成，因此done属性会被设定为true，而如果提供了返回值，就会被用于value字段。
```Js
function *createIterator() {
    yield 1
    return
    yield 2
    yield 3
}
let iterator = createIterator()
console.log(iterator.next())    // "{ value: 1, done: false }"
console.log(iterator.next())    // "{ value: undefined, done: true }"
```
也可以指定一个返回值，会被用于最终返回的结果对象中的value字段。
```Js
function *createIterator() {
    yield 1
    return 42
}
let iterator = createIterator()
console.log(iterator.next())      // "{ value: 1, done: false }"
console.log(iterator.next())      // "{ value: 42, done: true }"
console.log(iterator.next())      // "{ value: undefined, done: true }"
```

#### 生成器委托
在某些情况下，将两个迭代器的值合并器一起会更有用。**生成器可以用星号（*）配合yield这一特殊形式来委托其他的迭代器。**正如生成器的定义，星号出现在何处是不重要的，只要落在yield关键字与生成器函数名之间即可。
```Js
function *createNuberIterator() {
    yield 1
    yield 2
}

function *createColorIterator() {
    yield 'red'
    yield 'green'
}

function *createCombinedIterator() {
    yield *createNumberIterator()
    yield *createColorIterator()
    yield true
}

var iterator = createCombinedIterator()
console.log(iterator.next())   // "{ value: 1, done: false }"
console.log(iterator.next())   // "{ value: 2, done: false }"
console.log(iterator.next())   // "{ value: "red", done: false }"
console.log(iterator.next())   // "{ value: "green", done: false }"
console.log(iterator.next())   // "{ value: true, done: false }"
console.log(iterator.next())   // "{ value: undefined, done: true }"
```

生成器委托也能让你进一步使用生成器的返回值。这是访问这些返回值的最简单方式，并且
在执行复杂任务时会非常有用。
```Js
function *createNumberIterator() {
    yield 1
    yield 2
    return 3
}
function *createRepeatingIterator(count) {
    for (let i=0; i < count; i++) {
        yield "repeat"
    }
}
function *createCombinedIterator() {
    let result = yield *createNumberIterator()
    yield *createRepeatingIterator(result)
}
var iterator = createCombinedIterator();
console.log(iterator.next()) // "{ value: 1, done: false }"
console.log(iterator.next()) // "{ value: 2, done: false }"
console.log(iterator.next()) // "{ value: "repeat", done: false }"
console.log(iterator.next()) // "{ value: "repeat", done: false }"
console.log(iterator.next()) // "{ value: "repeat", done: false }"
console.log(iterator.next()) // "{ value: undefined, done: true }"
```
注意值 3 从未在对于 next() 方法的任何调用中被输出。当前它仅仅存在于
createCombinedIterator() 生成器内部。但你也可以通过添加另一个 yield 语句来输出这个
值，正如：
```Js
function *createNumberIterator() {
    yield 1
    yield 2
    return 3
}
function *createRepeatingIterator(count) {
    for (let i=0; i < count; i++) {
        yield "repeat"
    }
}
function *createCombinedIterator() {
    let result = yield *createNumberIterator()
    yield result
    yield *createRepeatingIterator(result)
}
var iterator = createCombinedIterator()
console.log(iterator.next()) // "{ value: 1, done: false }"
console.log(iterator.next()) // "{ value: 2, done: false }"
console.log(iterator.next()) // "{ value: 3, done: false }"
console.log(iterator.next()) // "{ value: "repeat", done: false }"
console.log(iterator.next()) // "{ value: "repeat", done: false }"
console.log(iterator.next()) // "{ value: "repeat", done: false }"
console.log(iterator.next()) // "{ value: undefined, done: true }"
```

#### 异步任务运行
JS的异步编程是一把双刃剑：简单任务很容易用异步实现，但复杂任务就会变成代码组织方面的苦差事。由于生成器能让你在执行过程中有效的暂停代码操作，它就开启了与异步编程相关的许多可能性。
执行一步操作的传统铜方式是调用一个包含回调的函数。例如：
```Js
let fs = require('fs')
fs.readFile('config.json', function(error, contents)) {
    if (err) {
        throw err
    }
    doSomethingWith(contents)
    console.log('Done')
}
```
能使用文件名与一个回调函数去调用fs.readFile()方法，在读取操作结束之后，回调函数就会被调用。此回调函数查看是否存在错误，若否则处理返回的contents数据。当拥有数量少而有限的任务需要完成时，这么做很有效；然而当需要嵌套回调函数，或者要按顺序处理一系列异步任务时，此方式就会非常麻烦了。这种场合下生成器与yield会很有用。

#### 一个简单的任务运行器
由于yield能停止运行，并且在重新开始运行前等待next()方法被调用，就可以在没有回调函数的情况下实现异步调用。首先，需要一个能够调用生成器并且启用迭代器的函数：
```Js
function run(taskDef) {
    // 创建迭代器，让它在别处可用
    let task = taskDef()

    // 启动任务
    let result = task.next()

    // 递归使用函数来保持对next()的调用
    function step() {
        if (!result.done) {
            result = task.next()
            setp()
        }
    }

    // step()
}

```
run()函数接受一个任务定义（即一个生成器函数）作为参数，它会调用生成器来创建一个迭代器，并将迭代器放在task变量上。task变量放在函数的外层，因此它可以被函数内的其他函数访问到。第一次对next()的调用启动了迭代器，结果存储下以便稍后使用。step()函数查看result.done是否为false，如果是就在递归调用自身之前调用next()方法。每次调用next()都会把返回的结果保存在result变量上，它总是会被最新的信息所重写。对于step()的出事调用启动了处理过程就，该过程会查看result.done来判断是否还有更多要做的工作。

配合这个已实现的 run() 函数，你就可以运行一个包含多条 yield 语句的生成器，就像这
样：
```Js
run(function*() {
    console.log(1)
    yield
    console.log(2)
    yield
    console.log(3)
})
```
此例只是将三个数值输出到控制台，单纯用于表明对 next() 的所有调用都已被执行。然
而，仅仅使用几次 yield 并不太有意义，下一步是要把值传进迭代器并获取返回数据。

#### 带数据的任务运行
传递数据给任务运行器最简单的方式，就是把yield返回的值传入下一次的next()调用。为此，仅需传递result.value,正如一下代码：
```Js
function run(taskDef) {
    let task = taskDef()
    let result = task.next()
    function step() {
        if (!result.done) {
            result = task.next(result.value)
            step()
        }
    }
    step()
}
```

现在 result.value 作为参数被传递给了 next() ，这样就能在 yield 调用之间传递数据
了，就像这样：
```Js
run(function*() {
    let value = yield 1;
    console.log(value); // 1
    value = yield value + 3;
    console.log(value); // 4
})
```

#### 异步任务运行器
上个例子只是在yield之间来回传递静态数据，但等待一个异步处理与此稍微有点差异。任务运行器需要了解回调函数，并了解如何使用它们。并且由于yield表达式将它们的值传递给了任务运行器，这就意味着函数调用都必须返回一个值，并以某种方式标明改返回值是个异步操作调用，二人舞运行器应当等待此操作。
此处是将返回值标明为异步操作的一种方法：

```Js
function fetchData() {
    return function(callback) {
        callback(null, 'hi')
    }
}
```
这部分代码的目的是：任何打算让人物运行器调用的函数，都应当返回一个能够执行回调函数的函数。fetchData()函数所返回的函数能接受一个回调函数作为其参数，当返回的函数被调用时，它会执行回调函数并附加一点额外数据（即“hi”字符串）。该回调函数需要由任务运行器提供，以确保回调函数能与当前的迭代其正确交互。虽然fetchData()函数是同步的，但能延迟对回调函数的调用，从而轻易地将它改造为异步函数：
```Js
function fetchData() {
    return function(callback) {
        setTimeout(function() {
            callback(null, 'hi')
        }, 50)
    }
}
```
此版本的fetchData()再调用回调函数之前引入了50毫秒的延迟，说明此模式在同步或一部代码上都能良好运作。**只要保证每个需要被yield调用的函数都遵循此模式。**
此版本的 fetchData() 在调用回调函数之前引入了 50 毫秒的延迟，说明此模式在同步或异
步代码上都能同样良好运作。你只要保证每个需要被 yield 调用的函数都遵循此模式。
在深入理解函数如何标注自己是一个异步处理后，你就可以结合这种模式来改造任务运行
器。只要 result.value 是一个函数，任务运行器就应当执行它，而不是仅仅将它传递给
next() 方法。此处有更新后的代码：
```Js
function run(taskDef) {
    let task = taskDef()
    let result = task.next()
    function step() {
        if (!result.done) {
            if (typeof result.value === 'function') {
                result.value(function(err, data) {
                    if (err) {
                        result = task.throw(err)
                        return
                    }
                    result = task.next(data)
                    step()
                })
            } else {
                result = task.next(result.value)
                step()
            }
        }
    }
    step()
}
```
当 result.value 是个函数时（使用 === 运算符来判断），它会被使用一个回调函数进行调
用。该回调函数遵循了 Node.js 的惯例，将任何潜在错误作为第一个参数（ err ）传入，而
处理结果则作为第二个参数。若 err 非空，也就表示有错误发生，需要使用该错误对象去调
用 task.throw() ，而不是调用 task.next() ，这样错误就会在恰当的位置被抛出；若不存
在错误， data 参数将会被传入 task.next() ，而其调用结果也会被保存下来。接下来，调
用 step() 来继续处理过程。若 result.value 并非函数，它就会被直接传递给 next() 方
法。

```Js
let fs = require("fs");
function readFile(filename) {
    return function(callback) {
        fs.readFile(filename, callback)
    }
}
```
这个 readFile() 方法接受单个参数，即文件名，并返回一个能执行回调函数的函数。此回
调函数会被直接传递给 fs.readFile() 方法，后者会在操作完成后执行回调。接下来你就可
以使用 yield 来运行这个任务，如下：
```Js
run(function*() {
    let contents = yield readFile("config.json")
    doSomethingWith(contents)
    console.log("Done")
})
```
