---
title: 深度优先搜索和广度优先搜索
date: 2020-05-26 11:13:46
tags:
---

## 深度优先搜索
深度优先搜索属于图算法的一种，是一个针对图和树的遍历算法，英文缩写为DFS即Depth First Search。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。

```js
function treeNode(val) {
	this.val = val
	this.p = null
	this.f = -1
	this.d = -1
	this.n = []
	this.color = 'white'
}
let obj = {}
for (let i = 0; i < 8; i++) {
	obj[i] = new treeNode(i)
}
obj[0].n.push(obj[3])
obj[0].n.push(obj[4])
obj[3].n.push(obj[1])
obj[3].n.push(obj[2])
obj[4].n.push(obj[5])
obj[4].n.push(obj[6])
obj[1].n.push(obj[7])
obj[4].n.push(obj[1])
let G = {
	tree1: obj[0]
}


function DFS(G) {
    var time = 0
    DFS_Visit(G, time)
}
function DFS_Visit(u, time) {
	console.log(u.val)
    time = time + 1
    u.d = time
    // u.color = 'grey'        //作用不大
    for (let v of u.n) {
        if (v.color === 'white') {
            v.p = u
            DFS_Visit(v, time)
        }
    }
    u.color = 'black'
    time = time + 1
    u.f = time
}

DFS(obj[0])
console.log(obj[0])
```

## 广度优先搜索

广度优先搜索（也称宽度优先搜索，缩写BFS，以下采用广度来描述）是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。基本过程，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现BFS算法。

```js
function treeNode(val) {
	this.val = val
	this.p = null
	this.f = -1
	this.d = -1
	this.n = []
	this.color = 'white'
}
let obj = {}
for (let i = 0; i < 8; i++) {
	obj[i] = new treeNode(i)
}

obj[0].n.push(obj[3])
obj[0].n.push(obj[4])
obj[3].n.push(obj[1])
obj[3].n.push(obj[2])
obj[4].n.push(obj[5])
obj[4].n.push(obj[6])
obj[1].n.push(obj[7])
obj[4].n.push(obj[1])
let G = {
	tree1: obj[0]
}

function BFS(G) {
    // G.color = 
    G.d = 0
    G.p = null
    let queue = []
    queue.unshift(G)
    while(queue.length > 0) {

        let u = queue.pop()
        // console.log(u)
        // console.log(u.val)
        // console.log('hdkal')
        // console.log(queue)
        for (let item of u.n) {
        	// if (item.val === 1) {
        	// 	console.log(item.color)
        	// }
            if (item.color === 'white') {
            	console.log(item.val)
                item.color = 'gray'
                item.d = u.d + 1
                item.p = u
                queue.unshift(item)
            }
            // console.log(queue)
        }
        u.color = 'black'
    }
} 
BFS(obj[0])
```
