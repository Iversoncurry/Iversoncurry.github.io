---
title: 二叉搜索树
date: 2020-05-09 22:48:44
tags: 算法与数据结构
---

**注：**NIL表示空的节点

## 二叉树遍历
1.前序遍历
按照线根节点再左节点再右节点的顺序遍历
```python
inorder-tree-walk(x)
    if x != NIL:
        print(x.key)
        inorder-tree-walk(x.left) 
        inorder-tree-walk(x.right)
```

2.中序遍历
按照先左节点，再根节点最后右节点的顺序
```python
inorder-tree-walk(x)
    if x != NIL:
        inorder-tree-walk(x.left) 
        print(x.key)
        inorder-tree-walk(x.right)
```
3.后序遍历
按照左节点，右节点最后根节点的顺序
```python
inorder-tree-walk(x)
    if x != NIL:
        inorder-tree-walk(x.left) 
        inorder-tree-walk(x.right)
        print(x.key)
```

## 二叉搜索树
二叉搜索树节点包含父节点指针，左孩子指针，右孩子指针和存储的值。

二叉搜索树的特点
左节点小于根节点小于右节点，由于这样的特点中序遍历的二叉搜索树的结果就是从小到大的排列。

### 查找
在树中查找某个值
```python
tree-search(x, k)
    if x == NIL or k == x.key
        return x
    if k < x.key
        return tree-search(x.left, k)
    else 
        tree-search(x.right, k)
```

查找树中最小值
```python
tree-minimum(x)
    while x.left != NIL
        x = x.left
    return x
```

查找树中最大值
```python
tree-maximum(x)
    while x.right != NIL
        x = x.right
    return x
```

查找后继（比key大的最小值）
```python
tree-successor(x)
# 右子树不为空，在右子树中找到最小
    if x.right != NIL
        return tree-minimum(x.right)  
# 右子树为空，向上查找，向上查找直到x为y的左子树或者y为空
    y = x.p
    while y != NIL and x == y.right
        x = y
        y = y.p
    return y
```

查找前驱（比key小的最大值）
```python
tree-successor(x)
# 左子树不为空，在左子树中找到最大
    if x.left != NIL
        return tree-maximum(x.left) 
# 左子树为空，向上查找，若x为y的左子树，则返回NIL，否则向上查找直到x为y的左子树

    y = x.p
    if (x == y.left)
        return NIL
    else
        while y != NIL and x == y.right
            x = y
            y = y.p
    return x
```

### 插入

查找后继（比key大的最小值）
```python
tree-insert(T, z)
    x = T.root
# 向下查找直到找到一个叶子节点y，然后判断叶子节点和要插入节点的大小关系
    while x != NIL
        y = x
        if z.key < x.key
            x = x.left
        else
            x = x.right
    z.p = y
    if y == NIL
        T.root = z
    else if
        z.key < y.key
            y.left = z
    else 
        y.right = z
```

### 删除

```python
# 子程序，实现用树v替换树u并成为树u双亲的孩子节点。其中考虑到u为根节点故添加参数T。
transplant(T, u, v)
    if u.p == NIL
        T.root = v
    else if u == u.p.left
        u.p.left = v
    else 
        u.p.right = v
    if v != NIL
        v.p = u.p

tree-delete(T, z)
# 情况1，左孩子为空，直接把用z的右孩子替换z
    if z.left == NIL
        transplant(T, z, z.right)
# 情况2，右孩子为空，直接把用z的左孩子替换z
    else if z.right == NIL
        transplant(T, z, z.left)
# 情况三，左右孩子都不为空，为保证修改树的结构仍满足二叉树的形式（防止z的右子树向上移动与z的左子树出现冲突）
    else 
        y = tree-minimum(z.right)
        # 当z的后继不为z的孩子，先将z的后继y的右孩子（y不会有左孩子）把y替换，然后将y插入到z的位置（注意，if外的代码也会执行，即要调整z的左右孩子的父节点为y，同时将y的左右孩子赋值为z的左右孩子）
        if y.p != z
            transplant(T, y, y.right)
            y.right = z.right
            y.right.p = y
        # 当z的后继为z的孩子，直接将y插入到z的位置
        transplant(T, z, y)
        y.left = z.left
        y.left.p = y
```