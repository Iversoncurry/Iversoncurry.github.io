---
title: 面向对象的程序设计
abbrlink: 9
tags: 
    JavaScript
categories:
    JavaScript高级程序设计
---
**引用类型的值（对象）是引用类型的一个实例。**在ECMAScript中，引用类型是一种书结构，用于将数据和功能组织在一起。尽管ECMAScript从技术上讲是一门面向对象的语言，但他不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的，构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。
## Object类型
虽然Object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。
创建Object实例的方法有两种，第一种是使用new操作符后跟Object构造函数：
```JS
var person = new Object()
person.name = "Nicholas"
person.age = 19
```
另一种方式是使用**对象字面量**表示法，对象i字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。其中，属性名也可以使用字符串。
```JS
var person = {
    name: "Nicholas",
    age: 19
}
var person = {}
person.name = "Nicholas",
person.age = 19
```
对象的属性可以通过点表示法和方括号法进行访问，从功能上看两者没有任何区别，但方括号语法的主要优点是可以通过变量来访问属性
```JS
person = {
    name: 'daming',
    age: 13
}
let personName = 'name'
console.log(person.name)
console.log(person[personName])
```
## 理解对象
ECMA-262在定义只有内部才能用的特性(attribute)时，描述了属性(property)的各种特征。这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把他们放在了两对方括号中，例如[[Enumerable]]。
对象有两种属性，数据属性和访问器属性
### 数据属性
数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性：
1.[[Configurable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。
2.[[Enumerable]]:表示能否通过for-in循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true；
3.[[Writable]]:表示能否修改属性的值，像前面离震中那样直接在对象上定义的属性，它们的这个特性默认为true；
4.[[Value]]:包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性时，把新值保存在这个位置。这个特性的默认值为undefined。
对于前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值
要修改属性默认的特性，必须使用Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象，属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable，enumerable，writable，value。设置其中的一个或多个值，可以修改对应的特性值。
```JS
var person = {}
Object.defineProperty(person, "name", {
    writable: false,
    value: "Nicholas"
})
console.log(person.name) //Nicholas
person.name = "daming"
console.log(person.name) //Nicholas
```
当writable为false时，在严格模式下赋值操作将抛出错误，在非严格模式下将被忽略，这个规则适用于"configurable: false"情况下。同时当把属性定义为不可配置的，就**不能**把它在变回可配置的。此时再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误
```JS
var person = {}
Object.defineProperty(person, "name", {
    configureble: false,
    value: "Nicholas"
})
//一下代码将导致抛出错误
Object.defineProperty(person, "name", {
    configurable: ture,
    value: "Nicholas"
})
```
### 访问器属性
**访问器属性不包含数据值**，它们包含一对getter和setter函数（这两个函数都不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数，并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性：
[[Configurable]]: 表示能否通过delete删除从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，对于直接在对象上定义的属性，合格特性的默认值为true
[[Enumerable]]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。
[[Get]]：在读取属性时调用的函数。默认值为undefined
[[Set]]：再写入属性时。默认值为undefined
访问器属性不能直接定义，必须使用Object.defineProperty()来定义。
```JS
var book = {
    _yera: 2004,
    edition: 1
}
Object.defineProperty(book, "year", {
    get: function() {
        return this._year
    },
    set: function(newValue) {
        if (newValue > 2004) {
            this._year = newValue
            this.edition += newValue - 2004
        }
    }
})
book.year = 2005;
console.log(book.edition)   //2
```
_year前的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性；而**访问器属性year**则包含一个getter函数和一个setter函数。getter函数返回_year的值，setter函数通过计算来确定正确的版本。因此，把year属性修改为2005会导致——year变为2005，而edition变为2.这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。
不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，非严格模式下尝试写入属性会被忽略；在严格模式下，尝试写入值制定了getter函数的属性会抛出错误。类似的，没有指定getter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误。

### 定义多个属性
由于为对象定义多个属性的可能性很大，ECMAScript 5 又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应
```JS
var book = {}
Object.defineProperties(book, {
    _year:{
        value: 2004
    },
    edition: {
        value: 1
    },
    year: {
        get: function() {
        return this._year
        },
        set: function(newValue) {
            if (newValue > 2004) {
                this._year = newValue
                this.edition += newValue - 2004
            }
        }
    }
})
```
### 读取属性的特性
使用Object.definePropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和尧都区其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个歌对象的属性又configurable, enumerable, get, set；如果是数据属性，这个对象的属性有configurable, enumerable, writable, value.
```JS
var book = {}
Object.defineProperities(book, {
    _year: {
        value: 2004
    },
    edition: {
        value: 1
    },
    year: {
        get: function() {
        return this._year
        },
        set: function(newValue) {
            if (newValue > 2004) {
                this._year = newValue
                this.edition += newValue - 2004
            }
        }
    }
})
var descriptor = Object.getOwnPropertyDescriptor(book, "_year")
var descriptor2 = Object.getOwnPropertyDescriptor(book, "year")
console.log(descriptor.value)
console.log(descriptor.configurable)
console.log(typeof descriptor.get)
console.log(descriptor2.value)
console.log(descriptor2.enumerable)
console.log(typeof descriptor2.get)
```
在JavaScript中，可以针对任何对象，包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。

## 创建对象
虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。
### 工厂模式
工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。
```JS
function createPerson(name, age, job) {
    var o = new Object()
    o.name = name
    o.age = age
    o.job = job
    o.sayName = function() {
        alert(this.name)
    }
    return o
}
var person1 = createPerson("Nicholas", 29, "Software Engineer")
var person2 = createPerson("Greg", 27, "Doctor")
```
工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别问题（即怎样知道一个对象的类型）。

### 构造函数模式
ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。
```JS
function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
    this.sayName = function() {
        console.log(this.name)
    }
}
var person1 = new Person("daming", 13, "SoftWare Engineer")
var person2 = new Person("xiaoming", 11, "student")
```
**注意**：要创建Person的新实例，必须使用new操作符，这种方式调用构造函数实际上会经历以下4个步骤:
1.创建一个新对象
2.将构造函数的租用与赋给新对象（因此this就只想了这个新对象）
3.执行构造函数中的代码（为这个个新对象添加属性）
4.返回新对象

在前面的例子最后，person1和person2分别保存着Person的一个不同的实例，这两个对象都有一个constructor（构造函数）属性，改属性指向Person。
```JS
console.log(person1.constructor === Person)    //true
console.log(person2.constructor === Person)    //true
```
对象的constructor属性最初时用来表示对象类型的。但是，提到检测对象类型，还是instanceof更可靠一些。
```JS
console.log(person1 instanceof Object)         //true
console.log(person1 instanceof Person)         //true
```
创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而着正事构造函数模式胜过工厂模式的地方。
**以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。**

**将构造函数当作函数
构造函数与其他函数的唯一区别，就在于调用它们的方式不同，不过构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它跟普通函数也不会有什么两样。
```JS
//当作构造函数使用
var person = new Person("Nicholas", 29, "software engineer")
person.sayName()       //"Nicholas"

//作为普通函数调用
Person("Greg", 27, "Doctor")
window.sayName()                //"Greg"

//在另一个对象的作用域中调用
var o = new Object()
Person.call(o, "daming", 25, "Nurse")
o.sayName()              //"daming"
```

**构造函数的问题
构造函数模式虽然好用，但也并非没有缺点，使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。ECMAScript中的函数是对象，因此没定义一个函数，也就是实例化了一个对象，从逻辑角度讲，此时的构造函数也可以这样定义。
```JS
function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
    this.sayName = new Function("console.log(this.name)")
}
```
从这个角度上来看构造函数，更容易明白每个Person实例都包含一个不同的Function实例（以显示name属性）的本质。以这种方式创建函数，会导致不同的作用域链和表示符解析，但创建Function新实例的机制仍然是相同的。因此不同实力上的同名函数是不相等的。
```JS
console.log(person1.sayName === person2.sayName)       //false
```
然而，创建两个完成同样任务的Function实例的确没有必要，况且有this对象在，根本不用在执行代码前就把哈数绑定到特定对象上面。因此，大可像下面这样，通过函数定义转移到构造函数外部来解决这个问题。
```JS
function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
    this.sayName = sayName
}
function sayName() {
    console.log(this.name)
}
var person1 = new Person("daming", 19, "software engineer")
var person2 = new Person("xiaoming", 17, "docter")
```
这个例子中，我们把sayName()函数的定义转移到了构造函数外部。而在构造函数内部，我们讲sayName属性设置等于全局的sayName函数，这样一来由于sayName包含的是一个指向函数的指针，因此person1和person2对象就共享了在全局作用臃肿定义的同一个sayName()函数。这解决了两个函数做同一件事的问题，但出现了新问题。全局作用域下的函数只能被某个对象调用，有违全局作用域的本意，同时如果对象需要定义很多方法，那么就要定义多个全局函数，这样就毫无封装性可言了。

### 原型模式
我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。换句话说，不必再构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中：
```JS
function Person() {
    Person.prototype.name = "daming"
    Person.prototype.age = 19
    Person.prototype.job = "software engineer"
    Person.prototype.sayName = function() {
        console.log(this.name)
    }
}
var person1 = new Person()
person1.sayName()    //daming
var person2 = new Person()
person2.sayName()    //daming
console.log(person1.sayName === person2.sayName)    //true
```
在此，**与构造函数不同之处在于，新对象的这些属性和方法是由所有实例共享的。**

理解原型对象
无论什么时候，只要创建了一个新函数，就回根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针，就拿前面的例子来说，Person.prototype.constructor指向Person。通过这个构造函数，我们可以继续为原型对象添加其他属性和方法。
创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，至于其他方法，都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象，ECMA-262第5版中管这个指针叫[[Prototype]]。**要明确的是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例和构造函数之间**。具体关系如下图
<!-- ![attr](/public/images/实例原型构造函数关系图.png) -->
![attr](面向对象的程序设计总结/a.png)
如上例中，两个对象都不包含属性和方法，但我们却可以调用person1.sayName()。这是通过查找对象属性的过程来实现的。
虽然在所有实现中都无法访问到[[Prototype]],但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向 调用isPrototypeOf()方法的对象（Person.prototype),那么这个方法就返回true。
```JS
console.log(Person.prototype.isPrototypeOf(person1))
console.log(Person.prototype.isPrototypeOf(person2))
```
ECMAScript5中增加了一个新方法，叫Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值
```JS
console.log(Object.getPrototypeOf(person1) == Person.prototype)     //true
console.log(Object.getPrototypeOf(person1).name)                    //"daming"
```
使用Object.getPrototypeOf()可以方便地取得一个对象的原型，而在利用原型实现集成的情况下是非常重要的。
虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那就在实例中创建该属性，改属性将会屏蔽原型中的那个属性。添加这个属性只会阻止访问原型对象中的那个属性，但不会修改那个属性。即使将该属性设为null，也只会在实例中设置这个属性，不会恢复其指向原型的连接。不过delete操作符可以完全删除实例属性，从而能够重新访问原型中的属性。
```JS
function Person() {
}
Person.prototype.name = "Nicholas"
Person.prototype.age = 19
Person.prototype.job = "software engineer"
Person.prototype.sayName = function() {
    console.log(this.name)
}
var person1 = new Person()
var person2 = new Person()
person1.name = "daming"
console.log(person1.name)   //daming
console.log(person2.name)   //Nicholas
person1.sayName()           //daming
person2.sayName()           //Nicholas

person1.name = null         
console.log(person1.name)   //null
person1.sayName()           //null
delete person1.name
console.log(person1.name)   //Nicholas
person1.sayName()           //Nicholas
```
使用hasOwnProperty()方法可以检测一个属性是存在在于实例中还是存在在于原型中
```JS
function Person() {
}
Person.prototype.name = "Nicholas"
Person.prototype.age = 19
Person.prototype.job = "software engineer"
Person.prototype.sayName = function() {
    console.log(this.name)
}
var person1 = new Person()
var person2 = new Person()
console.log(person1.hasOwnProperty("name"))  //false
person1.name = "daming"
console.log(person1.name)                    //daming
console.log(person1.hasOwnProperty("name"))  //true
console.log(person2.name)                    //Nicholas
console.log(person2.hasOwnProperty("name"))  //false
delete person1.name                           
console.log(person1.name)                    //Nicholas
console.log(person1.hasOwnProperty("name"))  //false
```
**原型与in操作符**
有两种方式使用in操作符：单独使用和在for-in循环中使用。
**单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。**

```JS
function Person() {
}
Person.prototype.name = "Nicholas"
Person.prototype.age = 29
Person.prototype.job = "Software Engineer"
Person.prototype.sayName = function() {
    console.log(this.name)
}
var person1 = new Person()
var person2 = new Person()
console.log(person1.hasOwnProperty("name"))  //false
console.log("name" in person1)               //true
person1.name = "Greg"
console.log(person1.name)                    //"Greg" -----来自实例
console.log(person1.hasOwnProperty("name"))  //true
console.log("name" in person1)               //true
console.log(person2.name)                    //daming -----来自原型
console.log(person2.hasOwnProperty("name"))  //false
console.log("name" in person2)               //true
delete person1.name
console.log(person1.name)                    //daming -----来自原型
console.log(person1.hasOwnProperty("name"))  //false
console.log("name" in person1)               //true
```

**在使用for-in循环时，返回的时所有能够通过对象访问的，可枚举的（enumerated）属性，其中，既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerale]]标记的属性）的实例也会在for-in循环中返回。**

```JS
function Person() {
}
Person.prototype.name = "Nicholas"
Person.prototype.age = 29
Person.prototype.job = "Software Engineer"
Person.prototype.sayName = function() {
    console.log(this.name)
}

var person1 = new Person()
var person2 = new Person()

for (let item in person1) {
    console.log(item)
}                                    //name, age, job, sayName
Object.defineProperty(Person.prototype, "name", {
	enumerable: false
})

for (let item in person1) {
    console.log(item)
}                                   //age, job, sayName
person1.name = "Greg"

for (let item in person1) {
    console.log(item)
}                                   //name, age, job, sayName
```
要取得对象上所有可枚举的实例属性，可以使用ECMAScript5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。
**注意Object.keys和for-in之间的差别**
```JS
function Person() {
}
Person.prototype.name = "daming"
Person.prototype.age = 29
Person.prototype.job = "softWare Engineer"
Person.prototype.sayName = function() {
    console.log(this.name)
}
var keys = Object.keys(Person.prototype)
console.log(keys)                               //name, age, job, sayName
var p1 = new Person()
p1.name = "Rob"
p1.age = 31
var p1keys = Object.keys(p1)
console.log(p1keys)                            //name, age
```
**如果需要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。**
```JS
var keys = Object.getOwnPropertyNames(Person.prototype)
console.log(keys)                                   //constructor, name, age, job, sayName
```

**更简单的原型语法**
用一个包含所有属性和方法的对象字面量来重写整个原型对象：
```JS
function Person() {
}
Person.prototype = {
    name: "nicholas",
    age: 29,
    job: "software Engineer",
    sayName: function() {
        console.log(this.name)
    }
}
```
在上面的代码中，将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外，constructor属性不再指向Person了。每创建一个函数，都会同时创建它的prototype对象，这个对象会自动获得constructor属性，而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。此时，尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了。
```JS
function Person() {
}

var friend = new Person()

console.log(friend instanceof Object)  //true
console.log(friend instanceof Person)  //true
console.log(friend.constructor == Person) //true
console.log(friend.constructor ==Object)  //false

Person.prototype = {
    name: "nicholas",
    age: 29,
    job: "software Engineer",
    sayName: function() {
        console.log(this.name)
    }
}

var friend2 = new Person()
console.log(friend2 instanceof Object)  //true
console.log(friend2 instanceof Person)  //true
console.log(friend2.constructor == Person) //false
console.log(friend2.constructor ==Object)  //true
```
另一种写法，会导致不同的输出结果，原因在于重写了Person.prototype对象后Person.prototype已发生改变，**注意与上一种的区别联系**
```JS
function Person() {
}

var friend = new Person()

console.log(friend instanceof Object)  //true
console.log(friend instanceof Person)  //true
console.log(friend.constructor == Person) //true
console.log(friend.constructor ==Object)  //false

Person.prototype = {
    name: "nicholas",
    age: 29,
    job: "software Engineer",
    sayName: function() {
        console.log(this.name)
	}	
}

console.log(friend instanceof Object)  //true
console.log(friend instanceof Person)  //false
console.log(friend.constructor == Person) //true
console.log(friend.constructor ==Object)  //false
```

如果constructor的值真的很重要，可以像像下面这样特意将他设置会适当值。
```JS
Person.prototype = {
    constructor: Person,
    name: "nicholas",
    age: 29,
    job: "software Engineer",
    sayName: function() {
        console.log(this.name)
}
```
注意，以这种方式重设constructor属性会导致它的[[Enumerable]]特性被设置为true。默认情况下，原生的constructor属性是不可枚举的，弥补方法如下：
```JS
fucntion Person() {
}

Person.prototype = {
    name: "Nicholas",
    age: 29,
    job: "Software Engineer"
    sayName: function () {
        console.log(this.name)
    }
}
Object.defineProperty(Person.prototype, "constructor", {
    enumerable: false,
    value: Person
})
```
**原型的动态性**
由于在原型中查找值的过程是一次搜索，因此我们对原型对象所作的任何修改都能够立即从实例上反映出来，即使先创建了实例后修改原型也照样如此。
```JS
function Person() {
}
var friend = new Person()
Person.prototype.sayHi = function() {
    console.log('hi')
}
friend.sayHi()     //hi
```
尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果重写整个原型对象就不一样了。其原因在于，调用构造函数时会为实力添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。**实例中的指针仅指向原型，不指向构造函数。
```JS
function Person() {

}
Person.prototype.sayAge = function() {
    console.log('sayAge')
}
var friend = new Person()
Person.prototype = {
    constructor: Person,
    name: 'Nicholas',
    age: 19,
    job: 'software enginner',
    sayName: function() {
        console.log(this.name)
    }
}
friend.sayAge()                 //'sayAge'
friend.sayName()                //error
```
**原生对象的原型**
原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object, Array, String, 等等）都在其构造函数的原型上定义了方法。例如，在Array.prototype中可以找到sort()方法，而在String.prototype中可以找到substring()方法：
```JS
console.log(typeof Array.prototype.sort)                 //funciton
console.log(typeof String.prototype.substring)           //function
```
通过原生对象的原型，不仅可以取得所有默认方法的引用，而且可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String添加了一个名为startsWith()方法：
```JS
String.prototype.startsWith = function (text) {
    return this.indexOf(text) == 0
}
var msg = 'Hello World'
console.log(msg.startsWith('Hello'))   //true
```
尽管可以这样做，但不推荐在产品化的程序中修改原生对象的原型。如果因某个事项中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的视线中运行代码时，就可能会导致命名冲突，而且这样做也可能会意外地重写原生方法。
**原生对象地问题**
原型模式也不是没有缺点，首先，它省略了为构造函数传递初始化阐述这一回姐，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题，原型模式的最大问题是由其共享的本性所导致的。
原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性说得过去，因为通过在实力上添加一个同名属性，可以隐藏原型中的对应属性。但对于包含引用类型的属性来说，问题就比较突出：
```JS
function Person() {
}
Person.prototype = {
    constructor: Person,
    name: 'Nicholas',
    age: 19,
    job: 'software enginee',
    friends: ['daing', 'lingling'],
    sayName: function() {
        console.log(this.name)
    }
}
var person1 = new Person()
var person2 = new Person()
person1.friends.push('Van')
console.log(person1.friends)                       //daing, lingling, Van
console.log(person2.friends)                       //daing, lingling, Van
console.log(person1.friends === person2.freidns)   //true
```
在person1的friends中添加一项，person2的friends也相应添加了一项，在大多数情况下这是不想要的，这个问题正是很少有人单独使用原型模式的原因。
### 组合使用构造函数模式和原型模式
创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。**构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性**。这样，每个实力都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，这最大限度地接上了内存。另外，这种混成模式还支持向构造函数传递参数。
```JS
function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
    this.friends = ['daming', 'lingling']
}
Person.prototype = {
    constructor: Person,
    sayName: function() {
        console.log(this.name)
    }
}
var person1 = new Person('Nicholas', 19, 'software engineer')
var person2 = new Person('Greg', 17, 'doctor')
person1.friends.push('van')
console.log(person1.friends)                                 //daming, lingling, van
console.log(person2.friends)                                 //daming, lingling
console.log(person1.friends === person2.friends)             //false
console.log(person1.sayName === person2.sayName)             //true
```
### 动态原型模式
动态原型模式把所有信息都封装再了构造函数中，二通过在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否有需要初始化原型。
```JS
function Person(name, age, job) {
    this.name = name
    this.age = age
    this.job = job
    if (typeof this.sayName != "function") {
        Person.prototype.sayName = function() {
            console.log(this.name)
        }
    }
}
```
### 寄生构造函数模式
通常，在前述的集中模式都不适用的情况下，可以使用寄生(parasitic)构造函数模式。这种模式的基本思想时创建一个函数，该函数的作用仅仅时封装创建对象的代码，然后再返回新建的对象；但从表面上看，这个函数又像是典型的构造函数。
```JS
function Person(name, age, job) {
    var o = new Object()
    o.name = name
    o.age = age
    o.job = job
    o.sayName = function() {
        console.log(this.name)
    }
    return o
}
var friend = new Person('Nicholas', 29, 'software engineer')
friend.sayName()                                                  //Nicholas
```
这里除了使用new操作符并把使用的包装函数叫做构造函数骄傲做构造函数之外，这个模式跟工厂模式其实是一模一样的。**构造函数在不返回值的情况下，默认会返回新对象实例。而通过构造函数的末尾添加一个return语句，可以重写调用构造函数时返回的值。**
这个模式可以在特殊的情况西用来为对象创建构造函数，假设我们向创建一个具有额外方法的特殊数组。由于不能直接修改Array构造函数，因此可以使用这个模式。
```JS
function SpecialArray() {
    var values = new Array()
    values.push.apply(values, arguments)
    values.toPipedString = function() {
        return this.join("|")
    }
    return values
}
var colors = new SpecialArray("red", "blue", "green")
console.log((colors.toPipeString()));
```
关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造汉顺外部创建的对象没有什么不同。为此不能依赖instanceof操作符来确定对象类型。
### 稳妥构造函数模式
所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this对象，稳妥对象最适合在一些安全的环境中使用（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。
```JS
function Person(name, age, job) {
    var o = new Object()
    o.sayName = function() {
        console.log(name)
    }
    return o
}
var friend = Person("Nicholas", 19, "Software Engineer")
friend.sayName()                                             //Nicholas
```
注意，在以这种模式创建的对象中，除了使用sayName()方法之外，没有其他办法访问name的值。
这样，变量person中保存的是一个稳妥对象，而除了调用sayName()方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。稳妥构造函数模式提供这种安全性。
与寄生构造函数模式类似，使用稳妥构造含糊模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。
## 扩展的对象功能
### 对象类别
对象类别包括：
普通对象： 拥有JS对象所有默认的内部行为
奇异对象：其内部行为在某些方面有别于默认行为
标准对象：在ES6中被定义的对象，例如Array、Date等等
内置对象：在脚本开始运行时由JS运行环境提供的对象。**所有标准对象都是内置对象。**

### 对象字面量语法的扩展
对象字面量是JS中最流行的模式之一（JSON就是基于这种语法），而它还存在于互联网上的几乎所有JS文件中。
**属性初始化器的速记法**
在ES5及更早的版本中，对象字面量是“键值对”的简单集合。这意味着在属性值被初始化时可能会有重复，ES6中，可以使用属性初始化器的速记法来消除对象名称与本地变量的重复情况。
```JS
function createPerson(name, age) {
    return {
        name: name,
        age: age
    }
}

//ES6语法
function cretePerson(name,age) {
    return {
        name,
        age
    }
}
```
**方法简写**
ES6同样改进了为对象字面量方法赋值的语法：
```JS
var person = {
    name: "nicholas",
    sayName() {
        console.log(this.name)
    }
}
```
**需计算属性名**
对象实例能使用”需计算属性名“，只要用方括号表示法来替代小数点表示法即可。方括号允许你将变量或字符串字面量指定为属性名：
```JS
var person = {}
var lastName = 'last name'
person['first name'] = 'nicholas'
person[lastName] = 'zakas'
console.log(person['first name'])          //nicholas
console.log(person[lastName])              //zakas
console.log(person.first name)             //error
```
可以在对象字面量中将字符串字面量直接用作属性，就像这样：
```JS
var person = {
    'first name': 'nicholas'
}
console.log(person['first name'])
```
在ES6中，需计算属性名时对象字面语法的一部分，它用的也是方括号表示法，于此前在对象实例上的用法一直
```JS
var lastName = 'last name'
var person = {
    'first name': 'nicholas',
    [lastName]: 'zakas'
}
console.log(person['first name'])
console.log(person[lastName])
```
对象字面量内的方括号表明该属性名需要计算，其结果是一个字符串，这意味着其中可以包含表达式：
```JS
var suffix = ' name'
var person = {
    ['first' + suffix]: 'nicholas',
    ['last' + suffix]: 'zakas'
}
console.log(person['first name'])
console.log(person['last name'])
```
### 新的方法
当JS中要比较两个值时，可能会使用相等运算符（==）或严格相等运算符（===）。为了避免在比较时发生前值类型转化，许多开发者更倾向使用后者。但严格相等运算符也不完全标准，例如它认为+0和-0相等，即使这两者在JS引擎中有不同的表示；另外NaN===NaN会返回false，因此有必要使用isNaN()函数来正确检查NaN，
ES6引入了Object.is()方法来弥补严格相等运算符残留的怪异点。此方法接收两个参数，并会在二者的值相等时返回true，此时要求二者类型相同并且值也相等。
```JS
console.log(+0 == -0); // true
console.log(+0 === -0); // true
console.log(Object.is(+0, -0)); // false
console.log(NaN == NaN); // false
console.log(NaN === NaN); // false
console.log(Object.is(NaN, NaN)); // true
console.log(5 == 5); // true
console.log(5 == "5"); // true
console.log(5 === 5); // true
console.log(5 === "5"); // false
console.log(Object.is(5, 5)); // true
console.log(Object.is(5, "5")); // false
```
**Object.assign方法**
混入（Mixin）是在JS中组合对象时最流行的模式。再一次混入中，一个对象会从另一个对象中接收属性与方法。很多JS的库中都有类似下面的混入方法：
```JS
function minin(receiver, supplier) {
    Object.keys(supplier).forEach(function(key) {
        receiver[key] = supplier[key]
    })
    return receiver
}
```
由于mixin()函数使用了赋值运算符（=），**因此无法将访问器属性复制到接收者上，Object.assign()体现了这种区别(即无法复制访问器属性）。**
Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的，这在下面的代码片段中就发生了：
```JS
var receiver = {};
Object.assign(receiver,
    {
        type: "js",
        name: "file.js"
    },
    {
        type: "css"
    }
)
console.log(receiver.type) // "css"
console.log(receiver.name) // "file.js"
```
**需要记住 Object.assign() 并未在接收者上创建访问器属性，即使供应者拥有访问器属性。由于 Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者数据属性**，例如：
```JS
var receiver = {}
var supplier = {
    get name() {
        return "file.js"
    }
}
Object.assign(receiver, supplier)
var descriptor = Object.getOwnPropertyDescriptor(receiver, "name")
console.log(descriptor.value) // "file.js"
console.log(descriptor.get); // undefined
```
**重复的对象字面量属性**
ES5 严格模式为重复的对象字面量属性引入了一个检查，若找到重复的属性名，就会抛出错误。例如，以下代码就有问题：
```JS
"use strict";
var person = {
    name: "Nicholas",
    name: "Greg" // 在 ES5 严格模式中是语法错误
}
```
但 ES6 移除了重复属性的检查，严格模式与非严格模式都不再检查重复的属性。当存在重复属性时，排在后面的属性的值会成为该属性的实际值，如下所示：
```JS
"use strict";
var person = {
    name: "Nicholas",
    name: "Greg" // 在 ES6 严格模式中不会出错
}
console.log(person.name) // "Greg"
```
**自有属性的枚举顺序**
ES5并没有定义对象属性的枚举顺序。ES6中则严格定义了对象自由属性在被美剧时返回的顺序。这对Object.getOwnPropertyNames()和Reflect.ownKeys如何返回属性造成了影响，同样影响了Object.assign()处理属性的顺序。
自有属性枚举时基本顺序如下：
1.所有的数字类型键，按升序排列；
2.所有的字符串类型键，按被添加到对象的顺序排类；
3.所有的符号类型键，也按添加顺序排列。
```JS
var obj = {
    a: 1,
    0: 1,
    c: 1,
    2: 1,
    b: 1,
    1: 1
    }
obj.d = 1;
console.log(Object.getOwnPropertyNames(obj).join("")); // "012acbd"
```
**for-in 循环的枚举顺序仍未被明确规定，因为并非所有的 JS 引擎都采用相同的方式。而 Object.keys() 和 JSON.stringify() 也使用了与 for-in 一样的枚举顺序。**
**更强大的原型**
修改对象的原型
一般来说，对象的原型会在通过构造器或 Object.create() 方法创建该对象时被指定。直到ES5 为止， JS 编程最重要的假定之一就是对象的原型在初始化完成后会保持不变。尽管ES5 添加了 Object.getPrototypeOf() 方法来从任意指定对象中获取其原型，但仍然缺少在初始化之后更改对象原型的标准方法。
ES6 通过添加 Object.setPrototypeOf() 方法而改变了这种假定，此方法允许你修改任意指定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象。例如：
```JS
let person = {
    getGreeting() {
        return "Hello";
    }
}
let dog = {
    getGreeting() {
        return "Woof";
    }
}
// 原型为 person
let friend = Object.create(person);
console.log(friend.getGreeting()); // "Hello"
console.log(Object.getPrototypeOf(friend) === person); // true
// 将原型设置为 dog
Object.setPrototypeOf(friend, dog);
console.log(friend.getGreeting()); // "Woof"
console.log(Object.getPrototypeOf(friend) === dog); // true
```
对象原型的实际值被存储在一个内部属性[[Prototype]]上，Object.getPrototypeOf()方法会返回此属性存储的值，而Object.setPrototypeOf()方法能够修改该值。
**使用super引用的简单原型访问**
关于原型的另一项进步就是引入了super引用，这让在对象原型上的功能调用变得更加容易。例如若要覆盖对象实例的一个方法、但依然要调用原型上的同名方法，如下（以下代码为ES5的实现方案）：
```JS
let person = {
    getGreeting() {
        return 'hello'
    }
}
let dog = {
	name: 'daming',
    getGreeting() {
        // return 'woof' + this.name
        return 'woof'
    }
}
let friend = {
	name: 'friend',
    getGreeting() {
        return Object.getPrototypeOf(this).getGreeting.call(this) + ', hi'         //这里的this指向friend，可以通过this.name验证
    }
}
Object.setPrototypeOf(friend, person)
console.log(friend.getGreeting())                             //hello, hi
console.log(Object.getPrototypeOf(friend) === person)         //true

Object.setPrototypeOf(friend, dog)
console.log(friend.getGreeting())                             //woof, hi
console.log(Object.getPrototypeOf(friend) === dog)            //true
```
从代码中可以看出this的指向过于复杂。ES6中引入super。简单说，super是指向当前对象的原型的一个指针，实际上就是Object.getPrototypeOf(this)的值。由此简化friend中的getGreet()方法：
```JS
let friend = {
    getGreeting() {
    // 这相当于上个例子中的：
    // Object.getPrototypeOf(this).getGreeting.call(this)
        return super.getGreeting() + ", hi!"
    }
}
```
此处调用super.getGreeting()等用于在上例的环境中使用Object.getPrototypeOf(this).getGreeting.call(this).类似的，能使用super引用来调用对象原型上的任何方法，**只要这个引用时位于简写的方法之内**。试图在方法接卸之外的情况使用super会导致语法错误，**在这种上下文中 super 是不可用的：错误信息（SyntaxError: 'super' keyword unexpected here）**
```JS
let friend = {
    getGreeting: function() {
        return super.getGreeting() + ', hi'
    }
}
```
在多继承时，super引用功能非常强大，因为这种情况下，Object.getPrototypeOf()不再适用于所有场景：
```JS
let person = {
    getGreeting() {
        return 'hello'
    }
}

let friend = {
    getGreeting() {
        // console.log('%%%%%%%%%%%%%%%%')
    	// console.log(this === relative)
        return Object.getPrototypeOf(this).getGreeting.call(this) + ',hi'
    }
}
Object.setPrototypeOf(friend, person)
let relative = Object.create(friend)
console.log(person.getGreeting())                   //hello
console.log(friend.getGreeting())                   //hello, hi
console.log(relative.getGreeting())                 //error
```
调用 Object.getPrototypeOf() 时，在调用 relative.getGreeting() 处发生了错误。这是因为此时 this 的值是 relative ，而 relative 的原型是 friend 对象，这样
friend.getGreeting().call() 调用就会导致进程开始反复进行递归调用，直到发生堆栈错误。(原因在于this引用的一直都是relative)
在ES6中，利用super可以解决这个问题：
```JS
let person = {
    getGreeting() {
        return "Hello"
    }
}
// 原型为 person
let friend = {
    getGreeting() {
        return super.getGreeting() + ", hi!"
    }
}
Object.setPrototypeOf(friend, person)
// 原型为 friend
let relative = Object.create(friend)
console.log(person.getGreeting()) // "Hello"
console.log(friend.getGreeting()) // "Hello, hi!"
console.log(relative.getGreeting()) // "Hello, hi!"
```
**正式的“方法”定义**
在ES6之前，“方法”的概念从未被正式定义，此前禁止对象的函数属性（而非数据属性）。ES6中正事做出了定义：方法时一个拥有[[HomeObject]]内部属性的函数，此内部属性指向该方法所属的对象。
```JS
let person = {
    getGreeting() {
        return "hello"
    }
}

function shareGreeting() {
    return 'hi'
}
```
任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在[[HomeObject]] 上调用 Object.getPrototypeOf() 来获取对原型的引用；接下来，在该原型
上查找同名函数；最后，创建 this 绑定并调用该方法。这里有个例子：
```JS
let person = {
    getGreeting() {
        return "Hello"
    }
}
// 原型为 person
let friend = {
    getGreeting() {
        return super.getGreeting() + ", hi!"
    }
}
Object.setPrototypeOf(friend, person)
console.log(friend.getGreeting()) // "Hello, hi!"
```
调用 friend.getGreeting() 返回了一个字符串，也就是 person.getGreeting() 的返回值与", hi!" 的合并结果。此时 friend.getGreeting() 的 [[HomeObject]] 值是 friend ，并且friend 的原型是 person ，因此 super.getGreeting() 就等价于person.getGreeting.call(this) 。

## 继承
ECMAScript中描述了**原型链**的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。
实现原型链有一种基本模式，其代码如下：
```JS
function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property
}
function SubType() {
    this.subproperty = false
}
SubType.prototype = new SuperType()
SubType.prototype.getSubValue = function() {
    return this.subproperty
}
var instance = new SubType()
console.log(instance.getSuperValue())         //true
console.log(instance.constructor)             //SuperType
```
通过实现原型链，本质上扩展了本章前面介绍的原型搜索机制。即，当一度去模式访问一个实例属性是，首先会在实力上搜索改属性，果果没有找到改属性，则会继续搜索实例的原型，再通过原型链实现集成的请款西，搜索过程就得以沿着原型链继续向上。就拿上面的例子来说，条用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.prototype，最后一步才会找到该方法。再找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。
**默认的原型**
之前的例子中展示的原型链还少一环。所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例。因此默认内源性都会包含一个内部指针，指向Object.prototype。这也是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。
**SubType继承了SuperType，而SuperType继承了Object。**
**确定原型和实例关系**
可以通过两种方式来确定原型和实例之间的关系。第一种方式是使用instanceof操作符。只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就回返回true。
```JS
console.log(instance instanceof Object)                //true
console.log(instance instanceof SuperType)             //true
console.log(instance instanceof SubType)               //true
```
由于原型链的关系，可以说instance是Object、SuperType或SubType中任何一个类型的实例。
第二种方法是使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。因此isPrototypeOf()方法也会返回true：
```JS
console.log(Object.prototype.isPrototypeOf(instance))     //true
console.log(SuperType.prototype.isPrototypeOf(instance))  //true
console.log(SubType.prototoye.insPrototypeOf(instance))   //true
```
**谨慎的定义方法**
子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。
```JS
function SuperType() {
    this.property = true
}
SuperType.prototype.getSuperValue = function() {
    return this.property
}
function SubType() {
    this.subproperty = false
}
SubType.prototype = new SuperType()
SubType.prototype.getSubValue = function() {
    return this.subproperty
}
SubType.prototype.getSuperValue = function () {
    return false
}
var instance = new SubType()
console.log(instance.getSuperValue())              //false

//另一个继承SuperType的对象对getSuperValue()的引用未发生改变
function anSubType() {
    this.anSubProperty = 'hhh'
}
anSubType.prototype = new SuperType()
anSubType.prototype.getanSubProperty = function () {
    return this.anSubProperty
}
var anInstance = new anSubType()
console.log(anInstance.getSuperValue())             //true  
```
当通过SubType的实例调用getSuperValue()时，调用的就是这个重新定义的方法；但通过SuperType的实例调用getSuperValue()时，还会继续调用原来的那个方法。
这里要格外注意的时，**必须在用SuperType的实例替换原型之后，再定义这两个方法。**
除默认原型外，其他实例中不包含指向构造函数的指针，这也就是图6-5中展现出的形式，即SubType.prototype不包含constructor属性，因为它是由SuperType生成的实例：
```JS
console.log(SubType.prototype.constructor)               //SuperType
```
还有一点要注意，即在通过原型链实现继承，不能使用对象字面量创建原型方法，因为这样做就会重写原型链:
```JS
function SuperType() {
    this.property = true
}
SuperType.prototype.getSuperValue = function() {
    return this.property
}
function SubType() {
    this.subproperty = false
}
SubType.prototype = new SuperType()
SubType.prototype = {
    getSubValue: function () {
        return this.subproperty
    },
    getSuperValue: function () {
        return false
    }
}
SubType.prototype.
var instance = new SubType()
console.log(instance.getSuperValue())               //error
```
以上代码展示了刚刚把SuperType的实例赋值给原型链，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，一次原型链已经被切断。
**此处继承和通过原型构造实例的对象字面量方式的区别与联系在于：**

**原型链的问题**
原型链虽然很强大，可以用它来实现继承，但也存在一些问题。其中最主要的问题来自包含引用类型值的原型。包含引用类型值的原型属性会被所有实例共享，这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。
```JS
function SuperType() {
    this.colors = ['red', 'blue', 'green']
}
function SubType() {
}
SubType.prototype = new SuperType()

var instance1 = new SubType()
instance1.colors.push('black')
console.log(instance1.colors)            //red, blue, green, black

var instance2 = new SubType()
console.log(instance2.colors)            //red, blue, green, black
```
原型链的第二个问题是：在创建i之类性的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。
## 借用构造函数
在解决原型中包含引用类型值所带来问题的过程中，开始使用一种叫做借用构造函数的技术。其基本思想为在子类型构造函数的内部调用超类型构造函数。**函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）创建的对象上执行构造函数：
```JS
function SuperType() {
    this.colors = ['red', 'blue', 'green']
}
function SubType() {
    //继承了SuperType
    SuperType.call(this)
}
var instance1 = new SubType()
instance1.colors.push('black')
console.log(instance1.colors)

var instance2 = new SubType()
console.log(instance2.colors)
```
代码中注释"继承了SuperType"那一行代码借调了超类型的构造函数。通过使用call()方法和apply()方法，实际上是在新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就回在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码（实际上利用this绑定到新对象），由此，SubType的每个实例就都会具有自己的colors属性的副本。
**传递函数**
相对于原型链而言，借用构造函数有一个很大的优势： 即可以在子类型构造函数中向超类型构造函数传递参数，
```JS
function SuperType(name) {
    this.name = name
}
function SubType() {
    SuperType.call(this, "Nicholas")
    this.age = 19
}
var instance = new SubType()
console.log(instance.name)                   //Nicholas
console.log(instance.age)                    //19
```
以上代码中的SuperType只接收一个参数name，该参数会直接赋给一个属性，在SubType构造函数内部调用SuperType构造函数时，实际上是为SubType的实例设置了name属性。为保证SuperType构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。
**借用构造函数的问题**
如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此无法进行函数复用。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。
### 组合继承
组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术结合到一起。其思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。
```JS
function SuperType(name) {
    this.name = name
    this.colors = ['red', 'blue', 'green']
}
SuperType.prototype.sayName = function() {
    console.log(this.name)
}
function SubType(name, age) {
    SuperType.call(this, name)
    this.age = age
}
SubType.prototype.sayAge = function() {
    console.log(this.age)
}
var instance1 = new SubType("Nicholas", 19)
instance1.colors.push("black")
console.log(instance1.colors)
instance1.sayName()
instance1.sayAge()
var instance2 = new SubType("Greg", 17)
console.log(instance2.colors)
instance2.sayName()
instance2.sayAge()
```
instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。
### 原型式继承
该方式的基本想法为借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型：
```JS
function object(o) {
    function F() {
        F.prototype = o
        return new F()
    }
}
```
在object()函数内部，先创建了一个临时性的构造函数，然后将传入的对象左右这个构造函数的原型，最后返回了这个临时类型的新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制：
```JS
var person = {
    name: 'Nicholas',
    friends: ['shelby', 'court', 'van']
}
var anotherPerson = object(person)
anotherPerson.name = 'Greg'
anotherPerson.friends.push('rob')

var yetAnotherPerson = object(person)
yetAnotherPerson.name = 'linda'
yetAnotherPerson.friends.push('barbie')
console.log(person.friends)                    //'shelby', 'court', 'van', 'rob'
```
实际上，上述代码相当于又创建了person的两个副本
ECMAScript5通过Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()和Object()方法的行为相同。(**注意基本数据类型和引用类型的区别**)
```JS
var person = {
    name: 'Nicholas',
    friends: ['shelby', 'count', 'van']
}
var anotherPerson = Object.create(person)
aontherPerson.name = 'Greg'
anotherPerson.friends.push('Rob')

var yetAnotherPerson = Object.create(person)
yetAnotherPerson.name = 'Linda'
yetAnotherPerson.friends.push('Barbie')
console.log(person.friends)                //'shelby', 'count', 'van', 'Rob', 'Barbie'

var person2 = {
    name: 'nicholas',
    friends: ['shelby', 'count', 'van']
}
var anotherPerson = Object.create(person, {
    name: {
        value: 'greg'
    }
})
console.log(anotherPerson.name)                //greg
console.log(anotherPerson)                     //{}
console.log(person)                            //{ name: 'nicholas', friends: [ 'shelby', 'count', 'van' ] }
```
在没必要使用构造函数，只想让一个对象与另一个对象保持类似的情况西，原型式继承完全可以胜任。不过，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。

### 寄生式继承
寄生式继承是与原型式继承相关的一种思路。寄生式继承的思路与寄生构造函数和工厂模式类似，即船舰一个仅用于封装击沉过程的函数，该函数在内部以某种愤怒时来增强对象，最后再像真的是他做了所有工作一样返回对象。
```JS
function createAnother(original) {
    var clone = object(original)
    clone.sayHi = function() {
        console.log('hi')
    }
    return clone
}

var person = {
    name: 'nicholas',
    friends: ['shelby', 'courts', 'van']
}
var anotherPerson = createAnother(person)
anotherPerson.sayHi()
```
使用寄生式继承来为对象添加函数会由于不饿能做到函数复用而降低效率；这一点与构造函数类似
### 寄生组合式继承
前面说过，组合继承是javaScript最常用的集成模式；不过，也有不足。组合继承最大的问题就是无论什么请款下，都会调用两次超类型构造函数：一次实在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例，但不得不再调用子类型构造函数时重写这些属性：
```JS
function Supertype(name) {
    this.name = name
    this.colors = ['red', 'blue', 'green']
}
SuperType.prototype.sayName =  function () {
    console.log(this.name)
}
function SubType(name, age) {
    SuperType.call(this, name)                   //调用第二次构造函数，重写SubType原型SuperType中的name和colors属性
    this.age = age
}
SubType.prototype = new SuperType()              //调用第一次构造函数
SubType.prototype.constructor = SubType
SubType.prototype.sayAge = function () {
    console.log(this.age)
}
```
所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形成来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，所需的无非是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。
```JS
function inheritPrototype(subType, superType) {
    var prototype = object(superType.ptototype)
    prototype.constructor = subType
    subType.prototype = prototype
}

function SuperType(name) {
    this.name = name
    this.colors = ['red', 'blue', 'green']
}
SuperType.prototype.sayName = function() {
    console.log(this.name)
}
function SubType(name, age) {
    SuperType.call(this, name)
    this.age = age
}
inheritPrototype(SubType, SuperType)
SubType.prototype.sayAge = function() {
    console.log(this.age)
}
```




