---
title:  引用类型之数组
abbrlink: 9
date: 2019-11-02 20:27:08
tags: 
    JavaScript
categories:
    # JavaScript高级程序设计
---
除Object之外，Array类型是ECMAScript中最常用的类型，与其他语言不同，数组中可以保存任何类型的数据；同时数组大小可以随意调整，不同于java，当数组长度确定时不能再进行改变；Array 存储的对象能动态增多和减少，并且可以存储任何JavaScript值。

## 创建数组

1.利用Array构造函数

``` JS
var colors = new Array(args)
```
其中args可以为空，也可以为一个数值或是字符串，当为数值时，生成一个长度为该数值的数组，当为字符串时，生成一个含有该字符串的数组；其中，new可以省略
2.利用数组字面量表示法进行创建
``` JS
var colors = ['1','2','3']
```
其中数组中最后一项不要为逗号，如为逗号将产生一个长度不定的数组

## 数组索引

在读取和设置数组的值时，利用方括号并提供相应的数字索引，数字索引是从0开始：
```JS
var colors = [1,2,3]
console.log(colors[0])
colors[1] = 4
console.log(colors[1])
```
通过length属性可以获取数组长度
```JS
var colors = [1,2,23]
console.log(colors.length)
```
对数组的length进行设置时，会改变数组项数，当设置的length大于数组实际长度时，超过的数组位置为undefined，当设置的length小于数组实际长度时，多余的数组会被移除
```JS
var colors = [1,2,23]
colors.length = 4
console.log(colors[3])
colors.length = 2
console.log(colors[2])
```
由此可以利用length属性实现数组的栈方法（构想，还没写😁）

## 检测数组

对于同一个网页或者一个全局作用域而言，利用instanceof操作符可以实现数组的检测

``` JS
console.log(value instanceof Array)
```
但如果网页中包含多个框架，导致存在两个及以上不同全局执行环境，从而导致多个不同版本的Array构造函数，instanceof方法将失效，此时可以利用Array.isArray()方法，该方法是最终确定一个值是否是数组：
```JS
console.log(Array.isArray(value))
```

## 转换方法

所有对象都有toLocaleString(), toString(), valueOf()方法。其中调用数组的toString()会返回有数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串（调用数组每一项的toString()方法；而调用valueOf()，返回的是数组；toLocaleString()方法调用每一项的toLocaleString()方法，对于alert方法，当其参数为数组时，会先调用数组的toString()方法。

``` JS
var color = ['red', 'green', 'blue']
console.log('hello')
console.log(color)
console.log(color.toString())
console.log(color.valueOf())
```
通过调用数组的join()方法，传入分隔符参数，更改分隔符
```JS
var color = ['red', 'green', 'blue']
console.log(color.join("||"))
```

## 栈方法
数组的push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改数组长度；pop()方法从数组末尾移除最后一项，减少数组的length，然后返回移除的项。
```JS
var color = ['red', 'green', 'blue']
var count = color.push('yellow', 'black')
console.log(count)
myColor = color.pop()
console.log(myColor)
```

## 队列方法
与栈方法相比，队列方法将pop()方法变为shift()方法，该方法移除数组第一项并返回该项，push()方法与栈方法相同。
```JS
var color = ['red', 'green', 'blue']
myColor = color.shift()
console.log(myColor)
```

## 重排序方法
数组有两个可以直接用来重排序的方法，reverse()和sort()方法。
reverse()方法将数组进行倒排
```JS
var values = [1,2,3,4,5]
values.reverse()
console.log(values)
```
sort()方法默认按升序排列数组，为实现排序，sort()方法会调用每个数组项的toString()方法，然后比较字符串，即使数组里每一项都是数值，sort()方法比较的也是字符串。但有些情况下，通过字符串比较会出现错误：
```JS
var values = [0,1,5,10,15]
values.sort()
console.log(values) //0,1,10,15,5
```
可通过给sort()函数传递一个比较函数作为参数（升序）：
```JS
function compare(value1, value2) {
    if (value < value) {
        return -1
    } else if (value1 > value2) {
        return 1
    } else {
        return 0
    }
}
var values = [0,1,5,10,15]
values.sort(compare)
console.log(values) //0,1,5,10,15
```
当数组元素为数值类型或其valueOf方法会返回数值类型对象时比较函数可简化为（升序）：
```JS
function compare(value1, value2) {
    return value2 - value1
}
```
注意：reverse()和sort()方法都是对原始数组进行修改
## 操作方法
concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。当concat()方法不传入参数时，只是对原数组进行复制并返回副本；当传入参数为一个或多个数组该方法将每个数组的每一项都添加到结果数组中；如果传入的参数不是数组，则值将会被简单添加到结果数组的末尾。
```JS
var color = ['red', 'green', 'blue']
var color2 = colors.concat('yellow', ['black', 'brown'])
console.log(color)
console.log(color2)
```
注意concat()方法不改变原始数组。
slice()方法能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一个或两个参数，即要返回项的起始和结束位置；若slice()方法只传递一个参数，则返回从该参数指定位置看是到当前数组末尾的所有项。
```js
var color = ['red', 'green', 'blue', 'yellow', 'black', 'brown']
var color2 = colors.slice(1)
var color3 = colors.slice(1, 4)
console.log(color)
console.log(color2)
console.log(color3)
```
注意slice()方法不改变原始数组。
splice()方法主要用途时向数组中部插入项：
1.删除：可以删除任意数量的的项，需指定2个参数：要删除的第一项的位置和要删除的项数；
2.插入：可以向指定位置插入任意数量的项，需提供3个参数：起始位置、0（要删除的项）和要插入的项。最后一个参数可以为任意多项
3.替换：可以项指定位置插入任意数量的项，且同时删除任意数量的项，需指定3个参数：其实位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。
splice()方法始终返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）
```JS
var color = ['red', 'green', 'blue']
var removed = color.splice(0,1)
console.log(color)
console.log(removed)

removed = color.splice(1,0,'yellow','orange')
console.log(color)
console.log(removed)

removed = color.splice(1,1,'red', 'purple')
console.log(color)
console.log(removed)
```
splice()方法改变原数组

## 位置方法
数组实例有两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数，要查找的项和表示查找起点位置的索引（可选）。其中，indexOf()方法从起点位置从前向后查找，lastIndexOf()方法从起始点从后向前查找，两个方法返回要查找项在数组中的位置。如果要查找项不在数组中则返回-1.
```JS
var number = [1,2,3,4,5,4,3,2,1]
console.log(number.indexOf(4,4))
console.log(number.lastIndexOf(4,4))
```

## 迭代方法
ECMAScript5为数组定义了5个迭代方法，每个方法接受两个参数：要在每一项上运行的函数和运行该函数的作用域对象----影响this的值。传入这些方法的函数接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。
1.every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true则返回true；(当找到不满足条件的项时停止迭代)(不改变原数组)
2.filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；(不改变原数组)
3.forEach(): 对数组中的每一项运行给定函数。这个方法没有返回值；本质上与for循环迭代数组一样。 (不改变原数组)
4.map(): 对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组；(不改变原数组)
5.some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。(当找到满足条件的项时停止迭代) (不改变原数组)
```JS
var number = [1,2,3,4,5,4,3,2,1]
var everyResult = number.every(function(item, index, array) {
	return (item > 2)
})
var someResult = number.some(function(item, index, array) {
	return (item > 2)
})
var filterResult = number.filter(function(item, index, array) {
	return (item > 2)
})
var mapResult = number.map(function(item, index, array) {
	return item*2
})
number.forEach(function(item, index, array) {
	number[index] = item*3
})
```

## 缩小方法
reduce()和reduceRight()方法为两个缩小数组方法，这两个方法都会迭代数组的所有项，其中reduce()方法从数组的第一项开始，逐个遍历到最后；而reduceRight()则从数组的最后一项开始，向前遍历到第一项。这连个方法都接收两个参数：一个在每一项上调用的函数和作为缩小基础的初始值（可选）。串给reduce()和reduceRight()函数接收4个参数：前一个值，当前值，想的索引和数组对象，函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数时数组的第一项，第二个参数就是数组的第二项。
```JS
var values = [1,2,3,4,5]
var sum = values.reduce(function(prev, cur, index, array) {
    return prev + cur
})
console.log(sum)
```
reduceRight()方法相较reduce()方法区别在于执行的方向不同。

## ES6增强的数组功能
### Array.of()方法 
JS语言中存在一个怪异点：
```JS
let item = new Array(2)
console.log(item.length) //2
console.log(item[0])     //undefined
console.log(item[1])     //undefined

item = new Array("2")
console.log(item.length) //2
console.log(item[0])

item = new Array(1,2)
console.log(item.length) //2
console.log(item[0])     //1
console.log(item[1])     //2

item = new Array(1,"2")
console.log(item.length) //2
console.log(item[0])     //1
console.log(item[1])     //"2"
```

ES6中引用Array.of()方法来解决这个问题，该方法类似 Array 构造器，但在使用多个数值参数的时候不会导致特殊结果。Array.of()方法总会创建一个包含所有出入参数的数组，不管参数的数量和类型。
```JS
let item = Array.of(1,2)
console.log(item.length)      //2
console.log(item[0])          //1
console.log(item[1])          //2

let item = Array.of(2)
console.log(item.length)      //1
console.log(item[0])          //2

let item = Array.of("2")
console.log(item.length)      //1
console.log(item[0])          //"2"
```

### Array.from()方法
该方法将类数组对象转化为数组对象,同时，可以向from传入一个映射函数
```JS
function doSomething() {
    var args = Array.from(arguments)
    ...
}
function translate() {
    return Array.from(arguments, (value) => value + 1)
}
let number = translate(1, 2, 3)
console.log(number)                  //2,3,4
```
如果映射函数需要在对象上工作，可以手动传递第三个参数给Array.from()方法，从而**指定映射函数内部**的this值
```JS
let diff = 2
let helper = {
    diff: 1,
    add(value) {
    	console.log(this.diff)
        return value + this.diff
    }
}
function translate() {
	this.diff = 3
    return Array.from(arguments, helper.add, helper) //1
    return Array.from(arguments, helper.add)         //2
}
let numbers = translate(1,2,3)
console.log(numbers)       //1     2,3,4   2    4,5,6
```
Array.from()方法不仅可以用于类数组对象，也可以用于迭代对象，这意味着该方法可以将任意包含Symbol.iterator属性的对象转换为数组
```JS
let numbers = {
    *[Symbol.iterator] () {
        yield 1
        yield 2
        yield 3
    }
}
let numbers2 = Array.from(numbers, (value)=>value+1)
console.log(numbers2)
```
### 数组上的新方法
find()与findIndex()方法。ES5中增加了indexOf()和lastIndexOf()方法，从而允许开发者在数组中查找特定值，但仍存在限制。
find()和findIndex()方法均接受两个参数：一个回调函数、一个可选值用于指定回调函数内部的this。该回调函数可接受三个参数：数组的某个元素、该元素对应的索引位置以及该数组自身，这与map()和forEach()方法的回调函数所用的参数一致。**该回调函数应当在给定的元素满足你定义的条件时返回true**，而find()和findIndex()方法均会在回调函数第一次返回true时停止查找。find()会返回匹配的值，findIndex()会返回匹配位置的索引。
```JS
let numbers = [25, 30, 35, 40, 45]
console.log(numbers.find(n=> n > 30))
console.log(numbers.findIndex(n=> n > 30))
```
**find()与findIndex()方法在查找满足特定条件的数组元素时非常有用。但若想查找特定值，则使用 indexOf() 与 lastIndexOf() 方法会是更好的选择。**
fill()方法能使用特定值填充数组中的一个或多个元素，当只使用一个参数的时候，该方法会用该参数的值填充整个数组，例如：
```JS
let numbers = [1, 2, 3, 4, 5]
numbers.fill(1)
console.log(numbers.toString())   //1,1,1,1
```
当只改变部分值时，可设置起始位置和结束位置的参数（不包括结束位置）
```JS
let numbers = [1, 2, 3, 4, 5]
numbers.fill(1,2)
console.log(numbers.toString())   //1,2,1,1

let numbers = [1, 2, 3, 4, 5]
numbers.fill(1,1,3)
console.log(numbers.toString())   //1,1,1,4
```
copyWithin()方法和fill()方法类似，可以一次性修改数组的多个元素。copyWithin()方法允许在数组内部复制自身元素，为此你需要传毒两个参数给copyWithin()方法：从什么位置开始填充，被用来复制的数据的起始位置索引以及终止位置索引
```JS
let numbers = [1, 2, 3, 4]
numbers.copyWithin()(2,0)
console.log(numbers.toString())  //1,2,1,2

let numbers = [1, 2, 3, 4]
numbers.copyWithin(2,0,1)
console.log(numbers.toString())
```
## 类型化数组
类型化数组是有特殊用途的数组，被设计用来处理数值类型数据（而不像名称暗示的那样，能处理所有类型）。引入类型化数组突破了格式限制并带来了更好的
数学运算性能，其设计概念是：单个数值可以被视为由“位”构成的数组，并且可以对其使用与JS 数组现有方法类似的方法。
### 数值数据类型
JS 数值使用 IEEE 754 标准格式存储，使用64位来存储一个数值的浮点数表示形式，该格式在JS中被同时用来表示整数与浮点数；当值改变时，可能会频繁发生整数与浮点数之间的格式转换。而类型化数组则允许存储并操作八种不同的数值类型：
1. 8 位有符号整数（int8）
2. 8 位无符号整数（uint8）
3. 16 位有符号整数（int16）
4. 16 位无符号整数（uint16）
5. 32 位有符号整数（int32）
6. 32 位无符号整数（uint32）
7. 32 位浮点数（float32）
8. 64 位浮点数（float64）
所有与类型化数组相关的操作和对象都围绕着这八种数据类型。为了使用它们，你首先需要创建一个数组缓冲区用于存储数据。
### 数组缓冲区
数组缓冲区（array buffer）是内存中包含一定数量字节的区域，而所有的类型化数组都基于数组缓冲区。使用ArrayBuffer构造器来创建一个数组缓冲区；调用ArrayBuffer构造器时，只需要传入单个数值用于指定缓冲区包含的字节数。可以通过byteLength属性来获取缓冲区的字节数。
```JS
let buffer = new ArrayBuffer(10)
console.log(buffer.byteLength)
```
可以使用slice()方法来创建一个新的、包含已有缓冲区部分的内容数组缓冲区，和数组的slice()方法类似，可以使用起始位置与结束位置参数，返回由原缓冲区元素组成的一个新的ArrayBuffer实例。
```JS
let buffer = new ArrayBuffer(10)
let buffer2 = buffer.slice(4,6)
console.log((buffer2.byteLength))
```
## 使用视图操作数组缓冲区
数组缓冲区代表了一块内存区域，而视图（views）则是操作这块区域的接口。视图工作在数组缓冲区或其子集上，可以读写某种数值数据类型的数据。DataView类型时数组缓冲区的通用视图，允许对前述所有8中数值数据类型进行操作。同时可以对数据缓冲区的部分上创建视图，需要提供字节偏移量以及要包含的字节数。**使用这种方式，你可以在同一个数组缓冲区上创建多个不同的视图，这样有助于将单块内存区域供给整个应用使用，而不必每次在有需要时才动态分配内存。**
```JS
let buffer = new ArrayBuffer(10)
let view = new DataView(buffer)

let buffer2 = new ArrayBuffer(10)
let view = new DataView(buffer, 5,2) //包含位置5和位置6的字节
```

获取视图信息
可以通过查询一下只读属性来获取视图的信息：
buffer: 概述图所绑定的数组缓冲区；
byteOffset：传给DataView构造器的第二个参数，如果当时提供了的话（默认为0）；
byte Length：传给DataView构造器的第三个参数，如果当时提供的话（默认为该缓冲区的byteLength属性）
```JS
let buffer = new ArrayBuffer(10)
let view1 = new DataView(buffer)
let view2 = new DataView(buffer, 5, 2)
console.log(view1.buffer === buffer)            //true
console.log(view2.buffer === buffer)            //true
console.log(view1.byteOffset)
console.log(view2.byteOffset)
console.log(view1.byteLength)
console.log(view2.byteLength)
```

读取和写入数据
对应JS所有8种数值数据类型，DataView视图的原型别提供了在数组缓冲区上写入数据的一个方法以及读取数据的一个方法，说有方法名都以“set”或“get”开始，气候跟随这对应数据类型的缩写,例如操作int8或unit8类型的读取/写入方法：
“get”方法接受两个参数：开始进行读取的字节偏移量、以及一个可选的布尔值，后者用于指定读取的值是否采用低字节优先方式（注：默认值为 false ）。“set”方法则接受三个参数：开始进行写入的字节偏移量、需要写入的数据值、以及一个可选的布尔值用于指定是否采用低字节优先方式存储数据。
**
getInt8(byteOffset,littleEndian): 从byteOffset处开始读取一个int8值；
setInt8(byteOffset, value, littleEndian): 从byteOffset处开始写入一个int8值；
**
**译注：低字节优先（Little-endian）也被翻译作“小端字节序”，指的是在存储数据的多个内存字节中，第一个内存字节存储着数据的最低字节数据，而最后一个内存字节存储着最高字节数据。**
```JS
let buffer = new ArrayBuffer(2),
view = new DataView(buffer);
view.setInt8(0, 5);
view.setInt8(1, -1);
console.log(view.getInt8(0)); // 5
console.log(view.getInt8(1)); // -1
```

视图允许你使用任意格式对任意位置进行读写，而无须考虑这些数据此前是使用什么格式存储的
```JS
let buffer = new ArrayBuffer(2)
let view = new DataView(buffer)
view.setInt8(0, 5)
view.setInt8(1, -1)
console.log(view.getInt16(0))
console.log(view.getInt8(0))
console.log(view.getInt8(1))
```
在混用不同的数据类型时，使用DataView对象是一种完美方式，不过，若尽享使用特定的一种数据类型，那么特定类型试图会是更好的选择。

类型化数组即为视图

开始时，该数组缓冲区 16 个位均为 0 ；使用 setInt8() 向第一个字节写入 5 之后，该字节的内容就出现了一对 1 （因为 5 可以写为 8 位二进制数 00000101 ）；向第二个字节写入-1 会使得该字节的所有位都变成 1 （即 -1 的二进制补码形式）。接下来使用 getInt16() 就能将前面写入的 16 位数据以单个 16 位整数的方式读取出来，其十进制值就是1535。
ES6 的类型化数组实际上也是针对数组缓冲区的特定类型视图，你可以使用这些数组对象来处理特定的数据类型，而不必使用通用的 DataView 对象。一共存在八种特定类型视图，对应着八种数值数据类型，为处理 uint8 值提供了额外的选择。

构造器名称                          元素大小
Int8Array                               1
Uint8Array                              1
Uint8ClampedArray                       1
Int16Array                              2
Uint16Array                             2
Int32Array                              4
Uint32Array                             4
Float32Array                            4
Float64Array                            8
**类型化数组的构造器可以接受多种类型的参数**，因此存在几种创建类型化数组的方式。
第一种方式是使用与创建 DataView 时相同的参数，即：一个数组缓冲区、一个可选的字节偏移量、以及一个可选的字节数量。
```JS
let buffer = new ArrayBuffer(10)
let view1 = new Int8Array(buffer)
let view2 = new Int8Array(buffer, 5, 2)

console.log(view1.buffer === buffer)                    //true               
console.log(view2.buffer === buffer)                    //true
console.log(view1.byteOffset)                           //0
console.log(view2.byteOffset)                           //5
console.log(view1.byteLength)                           //10
console.log(view2.byteLength)                           //2
```
第二种方法是传递单个数值给类型化数组的构造器，**此数值表示该数组包含的元素数量（而不是分配的字节数）**。构造器会创建一个新的缓冲区，分配正确的字节数以便容纳指定数量的数组元素。可以通过length属性来获取这个元素数量。
```JS
let ints = new Int16Array(2)
let floats = new Float32Array(5)

console.log(ints.byteLength)
console.log(ints.length)
console.log(floats.byteLength)
console.log(floats.length)
```
**如果调用类型化数组构造器时没有传入参数，构造器会认为传入了 0 ，这种方式创建的类型化数组不会被分配任何存储空间，因此也就不能被用于保存数据。**
第三种方式是向构造器传递单个对象参数
**类型化数组**：数组所有元素都会被复制到新的类型化数组中。例如，如果你传递一个 int8类型的数组给 Int16Array 构造器，这些 int8 的值会被复制到 int16 数组中。新的类型化数组与原先的类型化数组会使用不同的数组缓冲区。
**可迭代对象**：该对象的迭代器会被调用以便将数据插入到类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。
**数组**：该数组的元素会被插入到新的类型化数组中。如果其中包含了不匹配视图类型的值，那么构造器就会抛出错误。
**类数组对象**：与传入数组的表现一致。
```JS
let ints1 = new Int16Array([25, 50]),
ints2 = new Int32Array(ints1);
console.log(ints1.buffer === ints2.buffer); // false
console.log(ints1.byteLength); // 4
console.log(ints1.length); // 2
console.log(ints1[0]); // 25
console.log(ints1[1]); // 50
console.log(ints2.byteLength); // 8
console.log(ints2.length); // 2
console.log(ints2[0]); // 25
console.log(ints2[1]); // 50
```
### 类型化数组与常规数组的相似点
类型化数组与常规数组有好几个相似点，类型化数组在很多场景中都可以像常规数组那样被使用。例如，你可以使用length属性来获取类型化数组包含的元素数量，还可以使用数值类型的索引值来直接访问类型化数组的元素。
**与常规数组不同的是，你不能使用 length 属性来改变类型化数组的大小。该属性是不可写的，在非严格模式下写入操作会被忽略，而严格模式下则会抛出错误。**
类型化数组也拥有大量与常规数组等效的方法，你可以对类型化数组使用下列这些方法：
copyWithin()、entries()、fill()、filter()、find()、findIndex()、forEach()、indexOf()、join()、keys()、lastIndexOf()、map()、reduce()、reduceRight()、reverse()、slice()、some()、sort()、values()
**注意**虽然这些方法的表现与数组原型上的对应方法相似，但它们并不完全相同。类型化数组的方法会进行额外的类型检查以确保安全，并且返回值会是某种类型化数组，而不是常规数组（归结于 Symbol.species 属性）。这里有个例子用于演示其中的区别：
```JS
let ints = new Int16Array([25, 50]),
mapped = ints.map(v => v * 2);
console.log(mapped.length); // 2
console.log(mapped[0]); // 50
console.log(mapped[1]); // 100
console.log(mapped instanceof Int16Array); // true
```

**相同的迭代器
与常规数组相同，类型化数组也拥有三个迭代器，它们是 entries() 方法、 keys() 方法与values() 方法。这就意味着你可以对类型化数组使用扩展运算符，或者对其使用for-of 循环，就像对待常规数组
```JS
let ints = new Int16Array([25, 50]),
intsArray = [...ints];
console.log(intsArray instanceof Array); // true
console.log(intsArray[0]); // 25
console.log(intsArray[1]); // 50
```
of()和from()方法
所有的类型化数组都包含静态的 of() 与 from() 方法，作用类似于 Array.of() 与Array.from() 方法。其中的区别是类型化数组的版本会返回类型化数组，而不返回常规数组。
```JS
let ints = Int16Array.of(25, 50),
floats = Float32Array.from([1.5, 2.5]);
console.log(ints instanceof Int16Array); // true
console.log(floats instanceof Float32Array); // true
console.log(ints.length); // 2
console.log(ints[0]); // 25
console.log(ints[1]); // 50
console.log(floats.length); // 2
console.log(floats[0]); // 1.5
console.log(floats[1]); // 2.5
```
类型化数组与常规数组的区别
```JS
let ints = new Int16Array([25, 50]);
console.log(ints instanceof Array); // false
console.log(Array.isArray(ints)); // false
```
**行为差异
**常规数组可以被伸展或是收缩，然而类型化数组却会始终保持自身大小不变。你可以对常规数组一个不存在的索引位置进行赋值，但在类型化数组上这么做则会被忽略。**
```JS
let ints = new Int16Array([25, 50]);
console.log(ints.length); // 2
console.log(ints[0]); // 25
console.log(ints[1]); // 50
ints[2] = 5;
console.log(ints.length); // 2
console.log(ints[2]); // undefined
```
类型化数组也会对数据类型进行检查以保证只使用有效的值，当无效的值被传入时，将会被替换为0
```JS
let ints = new Int16Array(["hi"]);
console.log(ints.length); // 1
console.log(ints[0]); // 0
```
所有在类型化数组上修改项目值的方法都会受到相同的限制，例如当 map() 方法使用的映射函数返回一个无效值的时候，类型化数组会使用 0 来代替返回值：
```JS
let ints = new Int16Array([25, 50]),
mapped = ints.map(v => "hi");
console.log(mapped.length); // 2
console.log(mapped[0]); // 0
console.log(mapped[1]); // 0
console.log(mapped instanceof Int16Array); // true
console.log(mapped instanceof Array); // false
```
尽管类型化数组拥有常规数组的很多同名方法，但仍然缺少了几个数组方法，包括下列这些：
concat()、pop()、push()、shift()、splice()、unshift()
除了 concat() 方法之外，该列表中的其余方法都会改变数组的大小，而由于类型化数组的大小不可变，因此这些方法都不能作用于类型化数组。 concat() 方法不可用的原因则是：连接两个类型化数组的结果是不确定的（特别是当它们处理的数据类型不同时），这种不确定情况原本就不应当使用类型化数组。

**附加的方法
类型化数组还有两个常规数组所不具备的方法： set() 方法与 subarray() 方法。这两个方法作用相反： set() 方法从另一个数组中复制元素到当前的类型化数组，而subarray() 方法则是将当前类型化数组的一部分提取为新的类型化数组。
set() 方法接受一个数组参数（无论是类型化的还是常规的）、以及一个可选的偏移量参数，后者指示了从什么位置开始插入数据（默认值为 0 ）。
```JS
let ints = new Int16Array(4);
ints.set([25, 50]);
ints.set([75, 100], 2);
console.log(ints.toString()); // 25,50,75,100
```
subarray() 方法接受一个可选的开始位置索引参数、以及一个可选的结束位置索引参数（像slice() 方法一样，结束位置的元素不会被包含在结果中），并会返回一个新的类型化数组。你可以同时省略这两个参数，从而创建原类型化数组的一个复制品。
```JS
let ints = new Int16Array([25, 50, 75, 100]),
subints1 = ints.subarray(),
subints2 = ints.subarray(2),
subints3 = ints.subarray(1, 3);
console.log(subints1.toString()); // 25,50,75,100
console.log(subints2.toString()); // 75,100
console.log(subints3.toString()); // 50,75
```



![attr](https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)

上图中展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系，由于所有实现中都无法访问到[[Prototype]]，因此可以通过isPrototypeOf()确定对象对象间是否存在这种关系，如下所示：
