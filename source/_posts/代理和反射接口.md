---
title: 代理和反射接口
tags: JavaScript
---
ES5和ES6都推进了JS功能的公开。例如，JS运行环境包含一些不可枚举、不可写入的对象属性。ES5引入了Object.defineProperty()方法以便开发者在这方面能够像JS引擎那样做。
SE6让开发者能进一步接近JS引擎的能力，这些能力原先只存在于内置对象上。语言通过代理（proxy）暴露在对象上的内部工作，代理是一种封装，能够拦截并改变JS引擎的底层操作。
## 数组问题
在ES6之前，JS的数组对象拥有特定的行为方式，无法被开发者在自定义对象中进行模拟。当你给数组元素赋值时，数组的length属性会受到影响，同时也可以通过修改length属性来变更数组的元素。例如：
```Js
let colors = ['red', 'green', 'blue']
console.log(colors.length)       //3
colors[3] = 'black'
console.log(colors.length)       //4
console.log(colors[3])           //black
colors.length = 2
console.log(colors.length)       //2
console.log(colors[3])           //undefined
console.log(colors[2])           //undefined
console.log(colors[1])           //green
```
## 代理与反射是什么
通过调用new Proxy()，可以创建一个代理用来替代另一个对象（被称为目标），这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。
代理允许拦截在目标对象上的底层操作。拦截行为使用了一个能够响应特定操作的函数（被称为陷阱）。
被Reflect对象所代表的反射接口，是给底层操作提供默认行为的方法的集合，这些操作是能够被代理重写的。每个代理陷阱都有一个对应的反射方法，每个方法都与对应的陷阱函数重名，并且接受的参数也与之一致。下表总结了这些行为：
每个陷阱函数都可以重写 JS 对象的一个特定内置行为，允许你拦截并修改它。如果你仍然需要使用原先的内置行为，则可使用对应的反射接口方法。一旦创建了代理，你就能清晰了解代理与反射接口之间的关系，因此我们最好通过一些例子来进行深入研究。

## 创建一个简单的代理
当你使用 Proxy 构造器来创建一个代理时，需要传递两个参数：目标对象以及一个处理器（handler），后者是定义了一个或多个陷阱函数的对象。如果未提供陷阱函数，代理会对所有操作采取默认行为。为了创建一个仅进行传递的代理，你需要使用不包含任何陷阱函数的处理器：
```Js
let target = {};
let proxy = new Proxy(target, {});
proxy.name = "proxy";
console.log(proxy.name); // "proxy"
console.log(target.name); // "proxy"
target.name = "target";
console.log(proxy.name); // "target"
console.log(target.name); // "target"
```
该例中的 proxy 对象将所有操作直接传递给 target 对象。当 proxy.name 属性被赋值为字符串 "proxy" 的时候， target.name 属性也同时被创建，代理对象 proxy 自身其实并没有存储该属性，它只是简单将值传递给 target 对象。同样， proxy.name 与 target.name 的属性值总是相等，因为它们都指向 target.name ，这就意味着：为 target.name 设置一个新值会在 proxy.name 上反映出相同的改变。当然，缺少陷阱函数的代理没什么用，那么若为其定义一个陷阱函数，又会如何？
## 使用set陷阱函数验证属性值
假设你想要创建一个对象，并要求其属性值只能是数值，这就意味着该对象的每个新增属性都要被验证，并且在属性值不为数值类型时应当抛出错误。为此你需要定义 set 陷阱函数来重写设置属性值时的默认行为，该陷阱函数能接受四个参数：
1. trapTarget ：将接收属性的对象（即代理的目标对象）；
2. key ：需要写入的属性的键（字符串类型或符号类型）；
3. value ：将被写入属性的值；
4. receiver ：操作发生的对象（通常是代理对象）。
Reflect.set() 是 set 陷阱函数对应的反射方法，同时也是 set 操作的默认行为。
Reflect.set() 方法与 set 陷阱函数一样，能接受这四个参数，让该方法能在陷阱函数内部被方便使用。该陷阱函数需要在属性被设置完成的情况下返回 true ，否则就要返回 false，而 Reflect.set() 也会基于操作是否成功而返回相应的结果。你需要使用 set 陷阱函数来拦截传入的 value 值，以便对属性值进行验证。这里有个例子：
```Js
let target = {
    name: "target"
}
let proxy = new Proxy(target, {
    set(trapTarget, key, value, receiver) {
    // 忽略已有属性，避免影响它们
        if (!trapTarget.hasOwnProperty(key)) {
            if (isNaN(value)) {
                throw new TypeError("Property must be a number.")
            }
        }
        // 添加属性
        return Reflect.set(trapTarget, key, value, receiver)
    }
});
// 添加一个新属性
proxy.count = 1
console.log(proxy.count) // 1
console.log(target.count) // 1
// 你可以为 name 赋一个非数值类型的值，因为该属性已经存在
proxy.name = "proxy"
console.log(proxy.name) // "proxy"
console.log(target.name) // "proxy"
// 抛出错误
proxy.anotherName = "proxy"
```
这段代码定义了一个代理陷阱，用于对 target 对象新增属性的值进行验证。当执行proxy.count = 1 时， set 陷阱函数被调用，此时 trapTarget 的值等于 target 对象，key 的值是字符串 "count" ， value 的值是 1 ，而 receiver 的值是 proxy （该参数在本例中并没有被使用）。 target 对象上尚不存在名为 count 的属性，因此代理将value 参数传递给 isNaN() 方法进行验证；如果验证结果是 NaN ，表示传入的属性值不是一个数值，需要抛出错误；但由于这段代码将 count 参数设置为 1 ，验证通过，代理使用一致的四个参数去调用 Reflect.set() 方法，从而创建了一个新的属性。
当 proxy.name 被赋值为字符串时，操作成功完成。这是因为 target 对象已经拥有一个name 属性，因此验证时通过调用 trapTarget.hasOwnProperty() 会忽略该属性，这就确保允许在该对象的已有属性上使用非数值的属性值。
当 proxy.anotherName 被赋值为字符串时，抛出了一个错误。这是因为该对象上并不存在anotherName 属性，因此该属性的值必须被验证，而因为提供的值不是一个数值，验证过程就会抛出错误。
set 代理陷阱允许你在写入属性值的时候进行拦截，而 get 代理陷阱则允许你在读取属性
值的时候进行拦截。
## 使用get陷阱函数进行对象外形验证