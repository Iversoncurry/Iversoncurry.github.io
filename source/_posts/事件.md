---
title: 事件
tags: JavaScript
---

JavaScript与HTML之间的交互是通过事件实现的。**事件，就是文档或浏览器窗口中发生的一些特定交互瞬间。**可以使用侦听器（或处理程序）来订阅事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式。支持页面的行为与页面的外观之间的松散耦合。

## 事件流
事件流描述的是从页面中接收事件的顺序。

### 事件冒泡
IE的事件流叫做事件冒泡（event bubbling），即事件开始时有最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。

### 事件捕获
事件捕获的思想是不太具体的节点更早接收到事件，具体的节点最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。老版本的浏览器对事件捕获不支持。

### DOM事件流
“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。

在DOM事件流中，实际的目标（<div>元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到<html>再到<body>后就停止了。下一个阶段是“处于目标阶段，于是事件在<div>上发生，并在事件处理中被看成冒泡阶段的一部分。然后冒泡阶段发生，事件又传回文档。

## 事件处理程序

事件就是用户或浏览器自身执行的某种动作。诸如click、load和mouseover，都是事件的名字。而响应某个事件的函数就叫做事件处理程序（或事件侦听器）。事件处理程序的名字以“on”开头，因此click事件的处理程序就是onclick，load事件的处理程序就是onload。

### HTML事件处理程序
某个元素支持的每种事件，都可以使用一个与响应事件处理程序的同名HTML特性来指定。
```html
<input type="button" value="click me" onclick="alert('Click')"/>
```
这样指定时间处理程序有一些独到之处。首先，这样会创建一个封装着元素属性值的函数。这个函数中有一个局部变量event，也就是事件对象。

```js
<input type="button" value="click me" onclick="alert(event.type)">
```
通过event变量，可以直接访问事件对象，不用自己定义它，也不用从函数的参数列表中读取。
在这个函数内部，this值等于事件的目标元素。
```html
<input type="button" value="Click Me" onclick="alert(event.type)">
```
关于这个动态函数，在它内部，可以像访问局部变量一样访问document及该元素本身的成员。
```js
function() {
    with(document) {
        with(this) {
            // 元素属性
        }
    }
}
```
以上是由JavaScript底层实现，不需要开发者编写。
由此，可以更便利的访问自己的属性
```html
<input type="button" value="Click Me" onclick="alert(value)">
```
如果当前元素是一个表单输入元素，则作用域中还会包含访问表单元素（父元素）的入口，这个函数就变成了如下所示：
```js
function() {
    with(document) {
        with(this.form) {
            with(this)
            // 元素属性
        }
    }
}
```
实际上，这样扩展作用域的方式，无非就是想让事件处理程序无需引用表单元素就能访问其他表单字段
```html
<form method="post">
    <input type="text" name="username" value="">
    <input type="button" value="Echo Username" onclick="alert(username.value)">
</form>
```
不过在HTML中指定事件处理程序有两个缺点。首先，存在一个时间差问题。因为用户可能会在HTML元素已出现在页面上就触发相应的事件，但当时事件处理程序可能不具备执行条件（还没有被解析）
另一个缺点是，这样扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。
还有就是导致HTML和JavaScript代码紧密耦合。

### DOM0级事件处理程序
通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。要使用JavaScript指定事件处理程序，首先必须取得一个要操作的对象引用。
每个元素（包括window和document）都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。这种属性的值设置为一个函数，就可以指定事件处理程序
```js
var bin = document.getElementById('myBtn')
btn.onclick = function() {
    alert("Clicked")
}
```
需要注意的是，这段代码运行之前不会指定事件处理程序，因此如果这些代码在页面中位于按钮后面，就有可能在一段时间内单击没反应。
**使用DOM0级方法指定的事件处理程序被认为是元素的方法。**因此，这时候的事件处理程序实在元素的作用域中运行；换句话说，程序中的this引用当前元素。
以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理。
也可以删除通过DOM0级方法指定的事件处理程序
```js
btn.onclick = null
```

### DOM2级事件处理程序
“DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。所有DOM节点中都包含这两个方法，并且它们都接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。
要在按钮上click事件添加事件处理程序如下：
```js
var btn = document.getElementById('myBtn')
btn.addEventListener('click', function() {
    alert(this.id)
},false)
```
同时可以添加多个事件处理程序
```js
var btn = document.getElementById('myBtn')
btn.addEventListener('click', function() {
    alert(this.id)
},false)
var btn = document.getElementById('myBtn')
btn.addEventListener('click', function() {
    alert('hello world')
},false)
```
这里为按钮添加了两个事件处理程序，会按照添加它们的顺序触发。**与DOM0级方法一样，这里添加的事件处理程序也是再其依附的元素的作用域中运行。**
通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除；一出事传入的参数与添加处理程序时使用的参数相同。**这也意味着通过addEventListener()添加的匿名函数将无法移除**
```js
var btn = document.getElementById('myBtn')
btn.addEventListener('click', function() {
    alert(this.id)
}, false)
btn.removeEventlisterer('click', function() {  //无效
    alert(this.id)
}, false)  
```
```js
var btn = document.getElementById('myBtn')
var handler = function() {
    alert(this.id)
}
btn.addEventListener('click', handler, false)
btn.removeEventlisterer('click', handler, false)   //有效
```

### IE事件处理程序
IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。attachEvent()添加的事件处理程序都会被添加到事件冒泡阶段。
```js
var btn = document.getElementById('myBtn')
btn.attachEvent('onclick', function() {
    alert('clicked')
})
```
**在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。**
```js
var btn = document.getElementById('myBtn')
btn.attachEvent('onclick', function() {
    alert(this === window)   //true
})
```
attachEvent()方法也可以用来为一个元素添加多个事件处理程序。但执行顺序与DOM2方法相反。
使用attachEvent()添加的事件可以通过detachEvent()来移除，条件是必须提供相同的参数。


**跨浏览器的事件处理需要检查浏览器对事件的支持程度（DOM0、DOM2或IE）**

## 事件对象
在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含这所有与事件有关的信息。包括导致事件的元素，事件的类型以及其他与特定事件相关的信息。所有浏览器都支持event对象，但支持方式不同。
### DOM中的事件对象
兼容DOM的浏览器会将一个event对象传入到事件处理程序中国。无论指定时间处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。
```js
var btn = document.getElementById('myBtn')
btn.onclick = function(event) {
    alert(event.type)   //click
}
btn.addEventListener('click', function(event) {
    alert(event.type)   //click
}, false)
```

在通过HTML特定定义事件处理程序是，变量event中保存着event对象。以这种方式提供event对象，可以让HTML特性事件处理程序与JavaScript函数执行相同的操作。
要阻止特定事件的默认行为，可以使用preventDefault()方法。例如链接的默认行为就是在被单击是会导航到其href特性指定的URL。如果想阻止连接导航这一默认行为，那么通过链接的onclick事件处理程序可以取消它。
```js
var link = document.getElementById('myLink')
link.onclick = function(event) {
    event.preventDefault()
}
```
另外，stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。例如，直接添加到一个按钮的事件处理程序可以调用stopPropagation(),从而避免触发注册在document.body上面的事件处理程序
```js
var btn = document.getElementById('myBtn')
btn.onclick = function(event) {
    alert('clicked')
    event.stopPropagation()
}

document.body.onclick = function(event) {
    alert('body clicked')
}
```
事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的那个阶段。如果是在捕获阶段调用的事件处理程序，那么eventPhase等于1；如果事件处理程序处于目标对象上，则eventPhase等于2；如果是在冒泡阶段调用的事件处理程序，eventPhase等于3。尽管“处于目标”发生在冒泡阶段，但eventPhase仍然一直等于2；
```js
var btn = document.getElementById('myBtn')
btn.onclick = function(event) {
    alert(event.eventPhase)  //2
}
document.body.addEventListener('click',function(event) {
    alert(event.eventPhase) //1
}, true)
document.body.onclick = function(event) {
    alert(event.eventPhase)   //3
}
```

### IE中的事件对象
访问DOM的event对象不同，要访问IE中的event对象有几种不同方式，取决于指定时间处理程序的方法。在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。
```js
var btn = document.getElementById('myBtn')
btn.onclick = function() {
    var event = window.event
    alert(event.type)
}
```
如果事件处理程序时使用attachEvent()添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中
```js
var btn = document.getElementById('myBtn')
btn.attachEvent('onclick', function(event) {
    alert(event.type)
})
```
使用attachEvent()的情况下，也可以通过window对象来访问event对象，就像使用DOM0级方法一样。
如果是通过HTML特性指定的事件处理程序，那么可以通过一个名叫event的变量来访问event对象（与DOM中的事件模型相同）。
```html
<input type="button" value="Click Me" onclick="alert(event.type)">
```

因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement比较保险。
```js
var btn = document.getElementById('myBtn')
btn.onclick = function() {
    alert(window.event.srcElement === this)  //true
}
btn.attachEvent("onclick", function(event) {
    alert(event.srcElement === this)       //false
})
```
在第一个事件处理程序中（使用DOM0级方法指定的），srcElement属性等于this，但在第二个事件处理程序中，这两者的值不相同。
returnValue属性相当于DOM中的preventDefault()方法，它们的作用都是取消给定事件的默认行为。只要将returnValue设置为false，就可以阻止默认行为。

## 内存和性能
### 事件委托
对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有时间。例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。

### 移除事件处理程序
每当事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。可以使用事件委托技术，显示建立连接数量。另外，再不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的“空事件处理程序”，也是造成Web应用程序内存与性能问题的主要原因。
两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有时间处理程序的元素时。可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发生在使用innerHTML替换页面中某一部分。如果带有时间处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当做垃圾回收。
这种情况下，当知道某个元素即将被移除，手动移除事件处理程序。
```js
var btn = document.getElementById('myBtn")
btn.onclick = function() {
    btn.onclick = null
    document.getElementById('myDiv').innerHTML = 'Processing...'
}
```
另一种情况就是卸载页面的时候。如果页面卸载之前没有清理干净事件处理程序，那么就会滞留在内存中。每次加载完页面再卸载页面时（可能是在两个页面间来回切换，也可以是单击了刷新按钮）内存中直流的对象数目就会增加，因为事件处理程序占用的内存并没有被释放。
这种情况最好的做法是在页面卸载之前，通过onunload事件处理程序移处所有事件处理程序。

## 模拟事件
事件，就是网页中某个特别值得关注的瞬间。事件经常由用户操作或通过其他浏览器功能来触发。
事实上，可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。也就是所，这些事件通浏览器创建的事件一样可以冒泡，也可以指定事件处理程序。

### DOM中的事件模拟
可以在document对象上使用creatEvent方法创建event对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在DOM2级中，所有这些字符串都使用英文复数形式，而在DOM3级中都变成了单数。
这个字符串可以是下列几个字符串之一。
1.UIEvents：一般化UI事件。鼠标事件和键盘事件都继承UI事件。
2.MouseEvents：一般化的鼠标事件。
3.MutationEvents：一般化的DOM变动事件
4.HTMLEvents：一般化的HTML事件 如focus...

模拟事件步骤：
```js
var domElement = document.getElementById('someId')
var event = document.creatEvent("MouseEvents")
event.initMouseEvent('props...')  //不同方法事件参数不一样
domElement.dispatchEvent(event)   //等同于触发了initMouseEvent中type设置的事件
```

**自定义DOM事件**
DOM3级还定义了“自定义事件”。自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用createEvent('CustomEvent')。返回的对象有一个名为initCustomEvent()的方法，接收如下4个参数。
1.type(字符串)：触发的事件类型，可入“keydown”
2.bubble(布尔值)：表示事件是否应该冒泡
3.cancelable(布尔值)：表示事件是否可以取消
4.detail(对象)：任意值，保存在event对象的detail属性中
```js
var div = document.getElementById('myDiv')
var event;
EventUtil.addHandler(div, 'myevent',function(event) {
    alert('div:' + event.detail)
})

EventUtil.addHandler(document, 'myevent',function(event) {
    alert('document:' + event.detail)
})

if (document.implementation.hasFeature('CustomEvents', '3.0')) {
    event = document.createEvent('CustomEvent')
    event.initCustomEvent('myevent', true, false, 'hello world')
    div.dispatchEvent(event)
}
```
这个例子创建了一个冒泡事件‘myevent’。

