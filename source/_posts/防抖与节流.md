---
title: 防抖与节流
tags: 前端相关
---

有些情况下前端事件触发的函数执行过于频繁，将浪费浏览器性能由此引出防抖。
**防抖**
定义：
对于短时间内连续触发的事件，防抖的含义是让某个时间期限内，时间处理函数只执行一次。

思路1：
在第一次触发事件时，不利己执行函数，而是给出一个期限例如200ms，
当200ms内没有在此触发该事件，那么就执行函数
当200ms内再次触发该事件，当前计时取消，重新开始计时

**效果** 短时间大量触发同一事件只会执行一次函数。

**实现**
```js
// 非立即实现
function debounce(func, wait) {
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        
        timeout = setTimeout(() => {
            func.apply(context, args)
        }, wait);
    }
}

// 立即实现
function debounce(func,wait) {
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);

        let callNow = !timeout;
        timeout = setTimeout(() => {
            timeout = null;
        }, wait)

        if (callNow) func.apply(context, args)
    }
}

// 合并
function debounce(func,wait,immediate) {
    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(() => {
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}
// 使用
function showTop() {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop
    console.log(scrollTop)
}

window.onscroll = debounce(showTop, 1000)
```
此代码实现停止滚动1秒后，才会打印滚动条位置。
**防抖函数的代码使用这两行代码来获取 this 和 参数，是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。**

**节流**
防抖存在的问题在于，当在规定时间间隔内，某事件一直被触发，则其绑定的函数将无法执行。

效果： 如果短时间内大量触发同一事件，在函数执行一次后，该函数在指定的事件期限内不再工作，直至过了这段时间才重新生效。

实现
```js
// 时间戳版本
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}

// 定时器版本
function throttle(func, wait) {
    let timeout;
    return function() {
        let context = this;
        let args = arguments;
        if (!timeout) {
            timeout = setTimeout(() => {
                timeout = null;
                func.apply(context, args)
            }, wait)
        }

    }
}

// 使用
function showTop  () {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
　　console.log(scrollTop);
}
window.onscroll = throttle(showTop,1000) 
```


**时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。**
以上代码结果，一直拖动滚动条进行滚动，就会以1秒的时间间隔，持续输出当前位置和顶部的距离。

**其他应用场景**
1.搜索框input事件，例如要支持输入试试搜索可以使用节流方案（间隔一段时间就必须查询相关内容），或实现输入间隔大于某个值，就当做用户输入完成。
2.页面resize事件，常见于要做页面适配的时候，需要根据最终呈现的页面进行dom渲染，这种情况一般是使用防抖，因为只需要判断最后一次变化情况）
