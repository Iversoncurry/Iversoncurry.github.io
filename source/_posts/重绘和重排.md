---
title: 重绘和重排
date: 2020-05-16 10:44:27
tags:
---
## 重排 & 重绘

**简单的说，重排负责元素的几何属性更新，重绘负责元素的样式更新。而且，重排必然带来重绘，但是重绘未必带来重排。比如，改变某个元素的背景，这个就不涉及元素的几何属性，所以只发生重绘。**重绘占用的性能要小于重排

## 重绘触发机制 
重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。
触发重绘的条件：改变元素外观属性。如：color，background-color等。

注意：table及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。
## 重排触发机制
上面已经提到了，重排发生的根本原理就是元素的几何属性发生了改变，那么我们就从能够改变元素几何属性的角度入手

添加或删除可见的DOM元素
元素位置改变
元素本身的尺寸发生改变
内容改变
页面渲染器初始化
浏览器窗口大小发生改变

## 优化重绘和重排
既然重排&重绘是会影响页面的性能，尤其是糟糕的JS代码更会将重排带来的性能问题放大。既然如此，我们首先想到的就是减少重排重绘。

### 改变样式
考虑下面这个例子：

```js
var el = document.querySelector('.el');
el.style.borderLeft = '1px';
el.style.borderRight = '2px';
el.style.padding = '5px';
```
这个例子其实和上面那个例子是一回事儿，在最糟糕的情况下，会触发浏览器三次重排。然而更高效的方式就是合并所有的改变一次处理。这样就只会修改DOM节点一次，比如改为使用cssText属性实现：

```js
var el = document.querySelector('.el');
el.style.cssText = 'border-left: 1px; border-right: 2px; padding: 5px';
```
另一种思路是修改类名

```css 
.active {
    padding: 5px;
    border-left: 1px;
    border-right: 2px;
}
```
```js
var el = document.querySelector('.el');
el.className = 'active';
```

### 批量修改DOM

批量修改DOM元素的核心思想是：
让该元素脱离文档流
对其进行多重改变
将元素带回文档中
打个比方，我们主机硬盘出现了故障，常见的办法就是把硬盘卸下来，用专业的工具测试哪里有问题，待修复后再安装上去。要是直接在主板上面用螺丝刀弄来弄去，估计主板一会儿也要坏了...

这个过程引发俩次重排，第一步和第三步，如果没有这两步，可以想象一下，第二步每次对DOM的增删都会引发一次重排。那么知道批量修改DOM的核心思想后，我们再了解三种可以使元素可以脱离文档流的方法，注意，这里不使用css中的浮动&绝对定位，这是风马牛不相及的概念。

看一下下面这个代码示例:

```html
<ul id="mylist">
  <li><a href="https://www.mi.com">xiaomi</a></li>
  <li><a href="https://www.miui.com">miui</a></li>
</ul>
```

// javascript 现在需要添加带有如下信息的li节点
```js
let data = [
  {
    name: 'tom',
    url: 'https://www.baidu.com',
  },
  {
      name: 'ann',
      url: 'https://www.techFE.com'
  }
]
```

首先，我们先写一个通用的用于将新数据更新到指定节点的方法：

```js
function appendNode($node, data) {
  var a, li;
  
  for(let i = 0, max = data.length; i < max; i++) {
    a = document.createElement('a');
    li = document.createElement('li');
    a.href = data[i].url;
    
    a.appendChild(document.createTextNode(data[i].name));
    li.appendChild(a);
    $node.appendChild(li);
  }
}
```

首先我们忽视所有的重排因素，大家肯定会这么写：

```js
let ul = document.querySelector('#mylist');
appendNode(ul, data);
```
使用这种方法，在没有任何优化的情况下，每次插入新的节点都会造成一次重排（这几部分我们都先讨论重排，因为重排是性能优化的第一步）。

考虑这个场景，如果我们添加的节点数量众多，而且布局复杂，样式复杂，那么能想到的是你的页面一定非常卡顿。我们利用批量修改DOM的优化手段来进行重构

1）隐藏元素，进行修改后，然后再显示该元素

```js
let ul = document.querySelector('#mylist');
ul.style.display = 'none';
appendNode(ul, data);
ul.style.display = 'block';
```

<!-- 这种方法造成俩次重排，分别是控制元素的显示与隐藏。对于复杂的，数量巨大的节点段落可以考虑这种方法。为啥使用display属性呢，因为display为none的时候，元素就不在文档流了，还不熟悉的老铁，手动Google一下三者的区别

display:none;
opacity: 0;
visibility: hidden -->
2）使用文档片段创建一个子树，然后再拷贝到文档中

```js
let fragment = document.createDocumentFragment();
appendNode(fragment, data);
ul.appendChild(fragment);
```

文档片段是一个轻量级的document对象，它设计的目的就是用于更新，移动节点之类的任务，而且文档片段还有一个好处就是，当向一个节点添加文档片段时，添加的是文档片段的子节点群，自身不会被添加进去。

不同于第一种方法，这个方法并不会使元素短暂消失造成逻辑问题。上面这个例子，只在添加文档片段的时候涉及到了一次重排。

3）将原始元素拷贝到一个独立的节点中，操作这个节点，然后覆盖原始元素

```js
let old = document.querySelector('#mylist');
let clone = old.cloneNode(true);
appendNode(clone, data);
old.parentNode.replaceChild(clone, old);
```

可以看到这种方法也是只有一次重排。总的来说，使用文档片段，可以操作更少的DOM（对比使用克隆节点），最小化重排重绘次数。

### 缓存布局信息
比如我现在要得到页面ul节点下面的100个li节点，最好的办法就是第一次获取后就保存起来，减少DOM的访问以提升性能，缓存布局信息也是同样的概念。

前面有讲到，当访问诸如offsetLeft，clientTop这种属性时，会冲破浏览器自有的优化————通过队列化修改和批量运行的方法，减少重排/重绘版次。所以我们应该尽量减少对布局信息的查询次数，查询时，将其赋值给局部变量，使用局部变量参与计算。

看以下样例：
将元素div向右下方平移，每次移动1px，起始位置100px, 100px。性能糟糕的代码：

```js
div.style.left = 1 + div.offsetLeft + 'px';
div.style.top = 1 + div.offsetTop + 'px';
```

这样造成的问题就是，每次都会访问div的offsetLeft，造成浏览器强制刷新渲染队列以获取最新的offsetLeft值。更好的办法就是，将这个值保存下来，避免重复取值

```js
current = div.offsetLeft;
div.style.left = 1 + ++current + 'px';
div.style.top = 1 + ++current + 'px';
```