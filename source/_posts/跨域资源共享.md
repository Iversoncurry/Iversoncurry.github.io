---
title: 跨域资源共享
tags: 前端相关
---


通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略（同源策略）。

## 同源的定义
如果两个URL的协议（protocol）、端口（port）（如果有指定的话）和域名（host）都相同的话，则这两个URL是同源。这个方案也被称为‘协议/主机/端口元组’，或者直接是‘元组’。（‘元组’是指一组项目构成的整体，‘三重/四重/五重/等的通用形式）。
一下给出了与URL http://store.company.com/dir/page.html的源进行对比的示例。

1.http://store.company.com/dir2/other.html 
同源，只有路径不同
2.http://store.company.com/dir/inner/another.html
同源，只有路径不同
3.https://store.company.com/secure.html
不同源，协议不同
4.http://store.company.com:81/dir/etc.html
不同源，端口不同（http默认是80端口）
5.http://news.company.com/dir/other.html
不同源，主机（域名）不同

## 源的继承

在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。

例如，about:blank 通常作为父脚本写入内容的新的空白弹出窗口的 URL（例如，通过  Window.open()  ）。 如果此弹出窗口也包含 JavaScript，则该脚本将从创建它的脚本那里继承对应的源。

注意：在Gecko 6.0之前，如果用户在位置栏中输入 data URLs，data URLs 将继承当前浏览器窗口中网页的安全上下文。

data：URLs 获得一个新的，空的安全上下文。

## 源的更改

满足某些限制条件的情况下，页面是可以修改它的源。脚本可以将documet.domain的值设置为其当前域的父域。如果将其设置为当前域的父域，则这个较短的父域将用于后续源检查。
例如，假设http://**store.company.com**/dir/other.html文档中的一个脚本执行以下语句：
```js
document.domain = 'company.com'
```
这条语句执行以后，页面将会成功地通过与http://**company.com**/dir/page.html的同源检测（假设http://company.com.dir/page.html将其document设置为“company.com",已表明它希望允许这样做。然而，company.com 不能设置 document.domain 为 othercompany.com，因为它不是 company.com 的父域。

## 跨域资源共享
通过XHR实现Ajax通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。
CORS（Cross-Origin Resource Sharing，跨源资源共享），定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应应该是成功，还是失败。
比如一个简单的使用GET或POST发送的请求，它没有自定义的头部，而主体内容是text/plain。在发送请求时，需要给它附加一个额外的Origin头部，其中包含情感求页面的源信息（协议、域名和端口），以便服务器进行根据这个头部信息来决定是否给予响应。
  Origin: http://www.nczonline.net
如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发***）
  Access-Control-Allow-Origin: http://www.nczonline.net
如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。****注意，请求和响应都不包含cookie信息。

### IE对CORS的实现
IE8中引入了XDR（XDomainRequest）类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。一下是XDR与XHR的一些不同之处。
1.cookie不会随请求发送，也不会随响应返回
2.只能设置请求头部信息的Content-Type字段
3.不能访问响应头部信息
4.只支持GET和POST请求。
这些变化使CSRF（Cross-Site Request Forgey，跨站点请求伪造）和XSS（Corss-Site Scripting，跨站点脚本）的问题得到了缓解。被请求的资源可以根据它认为合适的任意数据（用户代理、来源页面等）来决定是否设置Access-Control-Allow-Origin头部。作为请求的一部分，Origin头部的值表示请求的来源域，以便远程资源明确地识别XDR请求。
XDR对象的使用方法与XHR对象非常相似。也是创建一个XDomainRequest的实例，调用open()方法，再调用send()方法。但与XHR对象的open()方法不同，XDR对象的open()方法只接收两个参数：请求的类型和URL。
所有XDR请求都是异步执行的，不能用它来创建同步请求。请求返回后，会触发load事件，响应的数据也会保存在reponseText属性中
```js
var xdr = new XDomainRequest()
xdr.onload = function() {
    alert(xdr.responseText)
}
xdr.onerror = function() {
    alert('error')
}
xdr.open('get', 'http://www.somewhere-else.com/page/')
xdr.send(null)
```
在请求返回前调用abort()方法可以终止请求：
xdr.abort()   //终止请求

与XHR一样XDR对象也支持timeout属性以及ontimeout事件处理程序。
```js
var xdr = new XDomainRequest()
xdr.onload = function() {
    alert(xdr.responseText)
}
xdr.onerror = function() {
    alert('error')
}
xdr.timeout = 1000;
xdr.ontimeout = function() {
    alert('timeout')
}
xdr.open('get','url')
xdr.send(null)
```
为支持POST请求，XDR对象提供了contentType属性，用来表示发送数据的格式
```js
var xdr = new XDomainRequest()
xdr.onload = function() {
    alert(xdr.responseText)
}
xdr.onerror = function() {
    alert('error')
}
xdr.timeout = 1000;
xdr.ontimeout = function() {
    alert('timeout')
}
xdr.open('post','url')
xdr.contentType = 'application/x-www-form-urlencoded'
xdr.send(null)
```
这个属性是通过XDR对象影响头部信息的唯一方式

### 其他浏览器对CORS的实现
其他浏览器都通过XMLHttpRequest对象实现了对CORS的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可
```js
var xhr = createXHR()
xhr.onreadystatechange = function() {
    if(xhr.readyState == 4) {
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
            alert(xhr.responseText)
        } else {
            alert('error' + xhr.status)
        }
    }
}
xhr.open('get', 'http://www.somewhere-else.com/page/', true)
xhr.send(null)
```
由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对URL，在访问远程资源时再使用绝对URL。这样做能消除歧义，避免出现限制访问头部或本地cookie信息等问题。

### Preflighted Requests
CORS通过一种叫做Prefilghed Request的透明服务器验证机制支持开发人员使用自定义的头部、GET或POST之外的方法，以及不同类型的主体内容。在使用下列高级选项来发送请求时，就会像服务器发送一个Preflight请求。这种请求使用OPTIONS方法，发送下列头部。
1.Origin：与简单的请求相同
2.Access-Control-Request-Method：请求自身使用的方法。
3.Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。
以下是一个带有自定义头部NCZ的使用POST方法发送的请求。
Origin: http://www.nczonline.net
Access-Control-Request-Method: POST
Access-Control-Request-Headers: NCZ
发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。
1.Access-Control-Allow-Origin：与简单的请求相同。
2.Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔
3.Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔
4.Access-Control-Max-Age：应该讲这个Preflight请求缓存多长时间

例如：
Access-Control-Allow-Origin: http://www.nczonline.net
Access-Control-Allow-Methods: POST, GET
Access-Control-Allow-Headers: NCZ
Access-Control-Max-Age: 172800
Preflight请求结束后，结果将按照响应中指定的时间缓存起来

### 带凭据的请求
默认情况下，跨域请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接收带凭据的请求，就会用下面的HTTP头部来响应。
Access-Control-Allow-Credentials: true
如果发送的是带凭据的请求，单服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给JavaScript（于是，responseText中将是空字符串，status的值为0，而且会调用onerror()事件处理程序）。另外服务器还可以在Preflight响应中发送这个HTTP头部，表示允许源发送带凭据的请求。

## 其他跨域技术
在CORS出现以前，要实现跨域Ajax通信破费一些周折。开发人员想出了一些办法，利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。虽然CORS技术已经无处不在，但开发人员自己发明的技术仍然被广泛使用，因为不需要修改服务器端代码。

### 子域和父域跨域
修改脚本的documet.domain为同一域名实现跨域（必须在同一父域下）。

### 图像Ping
上述第一种跨域请求技术是使用<img>标签。一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。也可以动态地创建图像，使用它们的onload和onerror事件处理程序来确定是否接收到了响应。
动态创建图像经常用于图像Ping。图像Ping是服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过真挺load和error事件，能知道响应是什么时候接收到的。
```js
var img = new Image()
img.onload = img.onerror = function() {
    alert('done')
}
img.src = 'http://www.example.com/test?name=Nicholas"
```
这里创建了一个Image的实例，然后将onload和onerror事件吹程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。**请求从设置src属性那一刻开始，而这个例子在啊请求中发送了一个name参数。
图像Ping最常用于跟踪用户点击页面活动太广告曝光次数。图像Ping有两个主要的缺点，一是只能发送GET请求，二是无法访问服务器的响应文本。因此图像Ping只能用于浏览器与服务器之间额单向通信。

### JSONP
JSONP是JSON with padding（填充式JSON或参数式JSON）的简写，是应用JSON的一种新方法，再后来的Web服务中非常流行。JSONP看起来与JSON差不多，只不过是包含在函数调用中的JSON就像下面这样。
```js
callback({'name': 'Nicholas'})
```
JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。下面是一个典型的JSONP请求
http://freegeoip.net/json/?callback=handleResponse
这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调函数，就像上面的URL所示，这里指定的回调函数的名字叫handlerResponse()
JSONP是通过动态script标签来使用，使用时可以为src属性指定一个跨域URL。这里的script元素与img元素类似，都有能力不受限制的从其他域中加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。
```js
function handleResponse(response) {
    alert('you are at ip address' + response.ip + 'which is in' resoponse.city + ',' + response.region_name)
}

var script = document.createElement('script')
script.src = 'http://freegeoip.net/json/?callback=handleResponse'
document.body.insertBefore(script, documetn.body.firstChild)
```
这个例子通过查询地理定位服务来显示IP地址和位置信息。
JSONP之所以在开发人员中极为流行，只要原因是它非常简单易用。与图像Ping相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP也有两点不足。
首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。
其次要确定JSONP请求是否失败并不容易。虽然HTML5给‘script’元素新增了一个onerror事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和带宽都一样。

### Comet
Comet值得是一种更高级的Ajax技术（经常也有人称为‘服务器推送’）。Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。
有两种实现Comet的方式：长轮询和流。长轮询是传统轮询（也称短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。
长轮询把短轮询颠倒了一下。页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可以发送。发送完数据时候，浏览器关闭连接，随即又发起一个到服务器的新请求。
无论长轮询还是短轮询，浏览器都要在接收数据之前，先发起对服务器的链接。两者最大的区别在于服务器如何发送数据。短轮询是服务器立即发送响应，无论数据是否有效，而长轮询则是等待发送响应。轮询的优势是所有浏览器都支持，因为使用XHR对象和setTimeout()就能实现。
第二种流行的Comet实现是HTTP流。流不同于上述两种轮询方式，因为它在页面的整个生命周期内只是用一个HTTP链接。具体来说就是浏览器向服务器发送一个请求，而服务器保持链接打开，然后周期性的向浏览器发送数据。
在Firefox和Chorme中，通过侦听readystatechange事件及readyState的值是否为3，就可以利用XHR对象实现HTTP流。在上述这些浏览器中，随着不断从服务器接收数据，readyState的值会周期性地变为3.dangreadyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下
```js
function createStreamingClinet(url, progress, finished) {
    var xhr = new XMLHttpRequest()
    var received = 0;
    xhr.open('get', url, true)
    xrh.onreadystatechange = function() {
        var result;
        if (xhr.readyState == 3) {
            result = xhr.responseText.substring(received)
            received +=result.length
            progress(result)
        } else if (xhr.readyState == 4) {
            finished(xhr.responseText)
        }
    }
    xhr.send(null)
    return xhr
}
var client = creatStreamingClient('streaming.php', function(data) {
    alert('Received: ' + data)
}, function(data) {
    alert('done')
})
```
这个createStreamingClient()函数接收三个参数：要连接的URL、在接收到数据时调用的函数。有时候，当连接关闭时，很有可能需要重新建立，所以关注连接，所以关注连接什么时候关闭还是有必要的。
只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后，通过process回调函数来处理传入的新数据。而当readyState值为4时则执行finished回调函数，传入响应返回的全部内容。

### 服务器发送事件
SSE（Serve-Sent Events，服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSEAPI用于创建到服务器的单向连接，服务器通过这个链接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream,而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定合适重新连接。有了这么简单实用的API，再实现Comet就容易多了。

1.SSE API
SSE的JavaScript API与其他传递消息的JavaScript API很相似。要预定新的事件流，首先要创建一个新的EventSource对象，并传进一个入口点：
```js
var source = new EVENTSource('myevents.php')
```
注意，传入的URL必须与创建对象的页面同源（相同的URL模式、域以及端口）。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。
另外，还有以下三个事件。
1.open：在建立连接时触发
2.message：在从服务器接收到新事件时触发。
3.error：在无法建立连接时触发。
```js
source.onmessage = function(event) {
    var data = event.data
}
```
服务器发回的数据以字符串形式保存在event.data中。默认情况下，eventsource对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE社和长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法。
```js
source.close()
```

2.事件流
所谓的服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data：，例如
data: foo

data: bar

data: foo
data: bar
对于以上响应，事件流中的第一个message事件返回的event.data值为foo，第二个message事件返回的event.data值为bar，第三个message事件返回的event.data值为foo\nbar。对于多个连续的以data:开头的数据行，将作为多端数据解析，每个值之间以一个换行符分隔。只有在包含data:的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。
通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面
data: foo
id: 1
设置了ID后，EventSource对象上会跟踪上一次触发的事件。如果连接断开，会向服务器发送一个包含名为Last-Event-ID的特殊HTTP头部的请求，以便服务器知道下次该触发哪个事件。再多次连接的事件流中，这种机制可以确保浏览器以正确的顺序接收到连接的数据段。

### Web Sockets
Web Sockets的目标是在一个单独的持久连接上提供全双工、双向通信。在JavaScript中创建了Web Socket之后，会有一个HTTP请求发送到浏览器以发起连接。在取得服务器响应之后，建立的链接会使用HTTP升级从HTTP协议交换为Web Socket协议，就是说，使用标准的HTTP服务器无法实现Web Sockets，只有支持这种协议的专门服务器才能正常工作。
由于Web Sockets使用了自定义的协议，所以URL模式也略有不同。未加密的链接不再是http://,而是ws://。加密的链接也不是https://,而是wss://。在使用Web Socket URL时，必须带着这个模式，因为将来还有可能支持其他模式。
使用自定义协议而非HTTP协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心HTTP那样的字节级的开销。由于传递的数据包很小，因此Web Sockets非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，指定协议的时间比指定JavaScript API的时间还要长。

1.Web Sockets API
要创建Web Socket，先实例化一个WebSocket对象并传入要连接的URL
```js
var socket = new WebSocket('ws://www.example.com/server.php')
```
注意必须给WebSocket构造函数传入绝对URL。同源策略对Web Sockets不适用，因此可以通过它打开到任何站点的链接。至于是否会与某个域中的页面通信，则完全取决于服务器。（通过握手信息就可以知道请求来自何方）

实例化了WebSocket对象后，浏览器就会马上尝试创建连接。与XHR类似，WebSocket也有一个表示当前状态的readyState属性，取值如下：
WebSocket.OPENING(0):正在建立连接
WebSocket.OPEN(1)：已经建立连接
WebSocket.CLOSING(2)：正在关闭连接
WebSocket.CLOSE(3)：已经关闭连接

WebSocket没有readystatechange事件，步步哦有其他事件，对应着不同的状态。readyState的值永远从0开始。
要关闭Web Socket连接，可以任何时候调用close()方法。
socket.close()
调用了close()之后，readyState的值立即变为2（正在关闭），而在关闭连接后就会变为3.

2.发送和接收数据
Web Socket打开之后，就可以通过链接发送和接收数据。要向服务器发送数据，使用send()方法并传入任意字符串
```js
var socket = new WebSocket('ws://www.example.com/server.php')
socket.send('hello world')
```
因为Web Socket只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前，必须进行序列化。
```js
var message = {
    time: new Data(),
    text: 'hello world',
    clientId: 'asdfp'
}
socket.send(JSON.stringify(message))
```
接下来，服务器要读取其中的数据，就要解析接收到的JSON字符串。
当服务器向客户端发来消息时，WebSocket对象就会触发message事件。这个message事件与掐他产地消息的协议类似，也是吧返回的数据保存在event.data属性中
```js
socket.onmessage = function(event) {
    var data = event.data
}
```
与通过send()发送到服务器的数据一样，event.data中返回的数据也是字符串，需要手工解析。

3.其他事件
WebSocket对象还有其他三个事件，在连接声明追的不同阶段触发
open：在成功建立连接时触发
error：在发生错误时触发，连接不能持续
close：在连接关闭时触发。
WevScket对象不支持DOM2级事件侦听器，因此必须使用DOM0级语法分别定义每个事件处理程序
```js
var socket = new WebSocket('wsurl')
socket.onopen = function() {
    alert('connect on')
}
socket.onerror = function() {
    alert('error')
}
socket.onclose = function() {
    alert('close')
}
```

### vue开发模式和生产模式下跨域
开发模式
找到并打开config文件夹下的index.js,做如下配置proxyTable：
```js
proxyTable: {
  '/api': {
    target: 'http://xxxxxxxx.com/api',
    changeOrigin: true,
    pathRewrite: {
      '^/api': '/api'
    }
  }
}
//说明配置中的target后面内容为后端人员提供的数据接口。
//原理就是类似vpn做了一个中转，Node替你去接口请求数据而已
//调用
this.$http.get('/api/login').then(function(data){
   console.log(data)
})
```
生产模式
将项目部署到nginx服务器，利用nginx做反向代理进行跨域，只需配置nginx文件
参考链接 https://www.cnblogs.com/web-record/p/9467258.html