---
title: 定位元素
tags:
---
这部分介绍盒模型，position和display属性以及如何浮动（float）和清除（clear）元素。以及flex属性。
所谓盒模型，就是浏览器为页面中的每个HTML元素生成的矩形盒子。这些盒子都要按照课件版式模型（visual formatting model）在页面上排布。可见的页面版式主要由三个属性控制：position属性、display属性和float属性。其中position属性控制页面上元素间的位置关系，display属性控制元素是堆叠并排还是根本不在页面上出现，float属性提供控制的方式，以便把元素组成成多栏布局。

## 理解盒模型
每个元素都会在页面上生成一个盒子。因此HTML页面实际上就是由一堆盒子组成的。
默认情况下，每个盒子的边框不可见，背景也是透明的，所以我们不能直接看到页面中盒子的结构。
每个元素盒子的属性可以分成三组：
1.边框（border）：可以设置边框的宽窄，样式和颜色。
2.内边框（padding）：可以设置盒子内容区与边框的间距。
3.外边距（margin）：可以设置盒子与相邻元素的间距。
盒子的边框内边距和外边距相关的属性有4个，分别是上（top），右（right），下（bottom），左（left）。

### 盒子边框
边框（border）有三个相关属性
1.宽度（border-width）：可以使用thin、medium、和thick等文本值，也可以使用除百分比和负值之外的任何绝对值。
2.样式（border-style）：有none、hidder、dashed、solid、double、groove、ridge、inset和outset等文本值。
3.颜色（border-color）：可以使用任意颜色值，包括RGB、HSL、十六进制颜色值和颜色关键字。

### 盒子内边距
内边距（padding）是盒子内容区和盒子边框之间的距离。

### 盒子外边距
外边距（margin）是盒子之间的距离。

### 叠加外边距
**垂直方向上的外边距会叠加**，假设有三个段落，前后相接，而且都应用以下规则：
```css
p {height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px; margin-bottom:30px;}
```
第一段和第二段之间的实际间距是50px。像这样上下外边距相遇时，就会相互重叠，直至一个外边距碰到另一个元素的边框。
**注意，叠加的只是垂直外边距，水平外边距不叠加。对于水平相邻的元素，它们的水平间距是相邻外边距之和。**

外边距合并问题：https://segmentfault.com/a/1190000009519546

## 盒子有多大
1.没有宽度的盒子
所谓没有宽度的盒子就是指没有显示地设置元素的width属性。如果不设置块级元素的width属性，那么这个属性的默认值是auto，结果会让元素的宽度扩展到与父元素同宽。
```HTML
<body> 
 <p>This element's width property is not set…</p> 
</body>
```
```css
body {font-family:helvetica, arial, sans-serif; font-size:1em; margin:0px; 
background-color:#caebff;} 
p {margin:0; background-color:#fff;}
```
body元素会填满浏览器窗口，而段落会填满body元素。
接下来用内边距给文本两侧添加一些空白：
```css
p {margin:0; background-color:#fff; padding:0 20px;}
```
添加了内边距后，文本块的宽度变成了 360 像素（两边各加了 20 像素内边距）。
接下来，我们再给段落左右两边各添加 6 像素宽的边框
```css
p {margin:0; background-color:#fff; padding:0 20px; 
border:solid red; border-width:0 6px 0 6px;}
```
为两边各添加 6 像素的边框和 20 像素的内边距后，内容区变成了 348 像素
最后，再给左右两边各加一些外边距
```css
p {margin:0 30px; background-color:#fff; padding:0 20px; border:solid red; border-width:0 6px 0 6px;}
```
外边距在元素盒子与窗口之间创造了空白，此时内容宽度变成了 288像素（400 – ( (20 + 6 + 30)× 2)）。而元素声明的总宽度并没有变，仍然是400像素。
**盒模型结论一：没有（就是没有设置 width 的）宽度的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。**
2.有宽度的盒子
```css
p {width:400px; background-color:#fff; margin:0;}
```
段落有了固定的宽度400像素。在没有内边距的情况下，内容区也是生命的宽度，因此文本与盒子接触。下面给这个元素添加20像素的内边距：
```css
p {width:400px; background-color:#fff; margin:0; padding:0 20px;}
```
在给盒子设定宽度后，添加内边距会导致元素比原来宽了 40 像素
再给盒子两边各添加 6 像素的边框
```css
p {width:400px; background-color:#fff; margin:0;padding:0 20px; border:solid red; border-width:0 6px 0 6px;}
```
盒子比刚才又宽了 12 像素
最后，再给元素左、右两边添加一些外边距
```css
p {width:400px; background-color:#fff; margin:0 30px; padding:0 20px; border:solid red; border-width:0 6px 0 6px;}
```
添加的这 30 像素外边距，进一步增大了元素占据的空间，目前总宽度已达到 512 像素（30 + 6 + 20 + 400 + 20 + 6 + 30 = 512）。
**盒模型结论二：为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占据的水平宽度。**

## 浮动与清除

浮动就是把元素从常规文档流中拿出来。浮动元素脱离了常规文档流之后，原来紧跟其后的元素就会在空间允许的情况下，向上提升到与浮动元素平起平坐。
如果浮动元素后面有两个段落，而之乡让第一段与浮动元素并列。这时候使用clear属性来“清除”第二段，然后钙元素就在浮动元素下面。

### 浮动

CSS设计float属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性也成了创建多兰布局最简单的方式。
1.文本绕排图片
为了实现文本绕排图片的浮动效果，必须在标记中先写图片，然后在写环绕它的文本。
```HTML
<img .../>
<p>the paragraph text ...</p>
```
```css
p {margin:0; border: 1px solid red;}
img{float:left; margin:0 4px 4px 0;}
```
以上规则会让图片浮动到左侧，而让文本绕排到右侧。
2.创建分栏
在上一部分的基础上创建多栏，只要再用一次float属性，只要给段落设定宽度然后也浮动它即可。
```css
p {
    float: left; margin: 0; weidth: 200px; border: 1px solid red;
}
img {
    float: left;margin: 0 4px 4px 0;
}
```
*这样同时浮动图片和“有宽度的”段落，会导致段落的文本绕排效果消失，而浮动的段落也会尽可能向左向上移动。就这样，这个段落就构成了紧挨着图片的一栏。这就是使用 float 属性创建多栏布局的原理。换句话说，如果几个相邻的元素都具有设定的宽度，都是浮动的，而且水平空间也足以容纳它们，它们就会并列排在一行。*

float脱离了normal flow但没脱离text flow
参考理解 https://www.zhihu.com/question/21911352

#### 围住浮动元素的三种方法
浮动元素脱离了文档流，其父元素也看不到它，因而也不会包围它。这种情况有时候并非我们想要的。
为了演示浮动元素的行为，这种行为对布局会产生什么影响，以及解决这个问题的三种方法，我们首先要从一张带标题的图片开始。图片和标签包含在一个 section元素中，而 section 元素后面跟着一个 footer 元素。可以把这个 footer 元素想象成很多网页底部都会有的与页面同宽的页脚。
```HTML
<section> 
 <img src="images/rubber_duck2.jpg"> 
 <p>It's fun to float.</p> 
</section> 
<footer> Here is the footer element that runs across the bottom of the 
page.</footer>
```
```css
section {border:1px solid blue; margin:0 0 10px 0;}
p {margin 0;}
footer {border:1px solid red;}
```
现在我们看到的是常规文档流，即块级元素包围着所有子元素，而且在页面中自上而下相互堆叠在一起。
使用浮动属性应用于图片
```css
section {border:1px solid blue; margin:0 0 10px 0;} 
img {float:left;} 
footer {border:1px solid red;}
```
这将会导致图片脱离section的包围，父元素section收缩到只包含文本的高度。为解决此问题，有三种方式：
方法一：为父元素添加overflow：hidden
这个方法很简单，缺点是不太直观，即为父元素应用overflow：hidden，以强制它包围浮动元素。
```css
section {border:1px solid blue; margin:0 0 10px 0; overflow:hidden;} 
img {float:left;} 
p {border:1px solid red;}
```
实际上，overflow:hidden 声明的真正用途是防止包含元素被超大内容撑大。应用overflow:hidden 之后，包含元素依然保持其设定的宽度，而超大的子内容则会被容器剪切掉。除此之外，overflow:hidden 还有另一个作用，即它能可靠地迫使父元素包含其浮动的子元素。
方法二：同时浮动父元素
第二种方法促使父元素包围其浮动元素的方法，是让父元素也浮动起来。
```css
section {border:1px solid blue; float:left; width:100%;} 
img {float:left;} 
footer {border:1px solid red; clear:left;}
```
浮动section以后，不管其子元素是否浮动，他都会仅仅地包围（也称收缩包裹）住它的子元素。因此需要用width:100%再让section和浏览器容器同宽。另外由于section现在也浮动了。所以footer会努力挤到它旁边去。为了强制footer依然待在section下方，要给footer应用clear:left。被清除的元素不会提升到浮动元素的旁边。
方法三：添加飞浮动的清楚元素
第三种强制父元素包含其浮动子元素的方法就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素。由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）附送元素的下方，因此包含元素一定会包含这个子元素-以及前民的浮动元素。包含元素最后添加子元素作为清除元素的方式有两种。
第一种方式:在 HTML 标记中添加一个子元素，并给它应用
clear 属性。
```html
<section> 
 <img src="images/rubber_duck.jpg"> 
 <p>It's fun to float.</p> 
 <div class="clear_me"></div> 
</section> 
<footer> Here is the footer element…</footer>
```
```css
section {border:1px solid blue;} 
img {float:left;} 
.clear_me {clear:left;} 
footer {border:1px solid red;}
```
第二种方式:用 CSS 来添加这个清除元素的方法,使用clearfix 规则
```html
<section class="clearfix"> 
 <img src="images/rubber_duck.jpg"> 
 <p>It's fun to float.</p> 
</section> 
<footer> Here is the footer element…</footer>
```
```css
.clearfix:after { 
 content:"."; 
 display:block; 
 height:0; 
 visibility:hidden; 
 clear:both; 
}
```

## 定位
CSS布局的核心是position属性，对元素盒子应用这个属性，可以相对于它常规文档六中的位置重新定位。position属性有四个值：static、relative、absolute、fixed，默认值为static。

### 静态定位
position:static。静态定位的情况下，每个元素处在常规文档流中。它们都是块级元素，所以酒会在页面中自上而下地堆叠起来。

### 相对定位
position:relative。相对是相对的它原来在文档流中的位置（或者默认位置）。通过设置top和left就可以实现位置的移动。
```css
p#specialpara {position:relative; top:25px; left:30px;}
```

### 绝对定位
position: absolute。绝对定位跟静态定位和相对定位比，绝对不一样。因为绝对定位会把元素彻底从文档流中拿出来。
```css
p#specialpara {position:absolute; top:25px; left:30px;}
```
关于定位上下文，首先我们要知道绝对定位元素默认的定位上下文是 body 元素。通过 top 和 left 设定的偏移值，决定了元素相对于 body 元素（标记层次中的祖先容器），而不是相对于它在文档流中的位置偏移多远——这一点与相对
定位的元素不同。
由于绝对定位元素的定位上下文是 body，所以在页面滚动的时候，为了维护与 body元素的相对位置关系，它也会相应地移动。

### 固定定位
position: fixed。从完全移出文档流的角度说，固定定位与绝对定位类似。
```css
p#specialpara {position:fixed; top:30px; left:20px;}
```
但不同之处在于，固定定位元素的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而移动。

### 定位上下文
把元素的 position 属性设定为 relative、absolute 或 fixed 后，继而可以使用 top、right、bottom 和 left 属性，相对于另一个元素移动该元素的位置。这里的“另一个元素”，就是该元素的定位上下文。
在讲绝对定位的时候，我们知道绝对定位元素默认的定位上下文是 body。这是因为body 是标记中所有元素唯一的祖先元素。而实际上，绝对定位元素的任何祖先元素都可以成为它的定位上下文，只要你把相应祖先元素的 position 设定为 relative 即可。
```html
<body> 
 <div id="outer"> 
 <div id="inner">This is text…</div> 
 </div> 
</body>
```
```css
div#outer {position:relative; width:250px; margin:50px 40px; border-top:3px solid red;}
div#inner {top:10px; left:20px; background:#ccc;}
```

## 显示属性
正如所有元素都有position属性，所有元素也都有display属性。尽管display属性的值有很多，但大多数元素display属性的默认值不是block，就是inline。
块级元素（block），比如段落，标题，列表等在浏览器中上下堆叠显示。
行内元素（inline），比如a、span和img，在浏览器中做鱼并排显示，只有前一行没有空间时才会显示到下一行。
把块级元素变成行内元素（或者相反）的方式如下：
```css
/*默认是block  */
p {display: inline}
/*默认是inline  */
a {display: block}
```
display 属性还有一个值有必要提一下，就是 none。把元素的 display 设定为 none，该元素及所有包含在其中的元素，都不会在页面中显示。它们原先占据的所有空间也都会被“回收”，就好像相关的标记根本不存在一样。与此相对的是 visibility属性，这个属性最常用的两个相对的值是 visible（默认值）和 hidden。把元素的visibility 设定为 hidden，元素会隐藏，但它占据的页面空间仍然“虚位以待”。

## 背景
背景支持为元素添加背景颜色和背景图片。CSS里每个元素盒子都可以想象成由两个图层组成。元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用试色填充（使用background-color属性），也可以包含任意多个背景图片（使用background-image属性），背景图片叠加在背景颜色之上。
在CSS3被浏览器实现之前，只能在背景颜色上添加一张背景图片。而现在，我们可以为背景图层添加多张图片（以及CSS3渐变）。

### CSS背景属性
css规定一下与背景相关属性。
background-color、background-image、background-repeat、background-position、background-size、background-attachment、background（简写属性）以及未被广泛支持的background-clip、background-origin、background-break。

### 背景颜色
background-color是北京属性中最简单的，通过它可以设定元素的颜色。然后元素就会以设定的颜色填充背景图层。
```css
body {background-color:#caebff;} 
p {/*盒子布局样式*/ 
 font-family:helvetica, arial, sans-serif; font-size:18px; 
 width:350px; margin:20px auto; padding:10px; 
 /*这个例子中讨论背景和前景样式*/ 
 background-color:#fff; color:#666; border:4px solid; 
}
```
这个例子除了演示怎么给元素添加背景色，还演示了前景色的作用范围，也就是前景色会影响元素的内容和边框。当然，有一个前提条件，就是在使用 border 设定边框的样式和宽度，而没有设定边框颜色（或者没有使用 border-color 单独设定边框颜色）的情况下，边框会使用 color 属性设定的字体颜色。默认颜色是黑色。如果你想让边框的颜色有别于文本，就需要单独设定。

### 背景图片
默认情况下背景图片会以元素左上角为起点，沿水平和垂直方向重复出现，最终填满整个背景区域。正是因为以元素左上角为原点，所以元素盒子底部和右侧的圆形图案都只显示了一部分。要注意的是，指定背景图片来源的方式，与 img标签中的方式不同，要这样：
```css
background-image:url(图片路径/图片文件名) 
```
图片地址两边不用加引号，当然加了也没问题。
要改变默认的水平和垂直重复效果，可以修改 background-repeat 属性；要改变背景图片的起点，可以修改 background-position 属性。

### 背景重复
控制背景重复的方式background-repeat属性有四个值。默认值是repeat，效果就是按水平和垂直方向都重复，直至填满元素的背景区域为止。另外三个值分别是只在水平方向重复的repeat-x、只在垂直方向上重复的repeat-y和在任意方向上都不重复（或者说只让背景图片显示一次）的no-repeat。
，CSS3 还规定另外两个值（但尚未得到浏览器支持），以
控制背景图片重复确切的次数，即所有图片都是完整的，不会出现半张图片的现象。
 background-repeat:round：为确保图片不被剪切，通过调整图片大小来适应背景
区域。
 background-repeat:space，为确保图片不被剪切，通过在图片间添加空白来适应
背景区域。

### 背景位置
用于控制背景位置的background-position属性，是所有背景属性中最复杂的。bancground-position属性有5个关键值，分别是top、left、bottom、right和center，这些关键字中的任意恋歌组合起来都可以作为该属性的值。比如，top right 表示把图片放在元素的右上角位置，center center 把图片放在元素的中心位置。
千万要注意，background-position 属性同时设定元素和图片的原点。原点决定了元素和图片中某一点的水平和垂直坐标。默认情况下，background-position 的原点位于左上角。换句话说，元素的左上角和图片的左上角是对齐的，随后图片向各个方向重复，都是以左上角为起点。

背景位置的值
设定背景位置时可以使用三种值：关键字、百分比、绝对或相对单位的数值。可以使用两个值分别设定水平和垂直位置。 
关键字指的顺序不重要，left bottom 和 bottom left 意思相同。为了设定的值在所有浏览器中都有效，最好不要混用关键字值与数字值。 
使用数值（比如 40% 30%）时，第一个值表示水平位置，第二个值表示垂直位置。要是只设定一个值，则将其用来设定水平位置，而垂直位置会被设为 center。 
在使用关键字和百分比值的情况下，设定的值同时应用于元素和图片。换句话说，如果设定了33% 33%，则图片水平 33%的位置与元素水平 33%的位置对齐。垂直方面也一样。图 3-37 所示也是一个例子，那是通过 center center 把图片的中心点定位在了元素的中心点。 
像素之类的绝对单位数值就不一样了。要是用像素单位来设定位置，那么图片的左上角会被放在距离元素左上角指定位置的地方。 
有意思的是，还可以使用负值。这样就可以把图片的左上角定位到元素外部，从而在元素中只能看到部分图片。当然，给图片设定足够大的正值，也可以把图片的右下角推到元素外部，从而在元素中也只能看到部分图片。位于元素外部的那部分图片不会显示。

### 背景尺寸
background-size是CSS3规定的属性，但却得到了浏览器很好的支持。这个属性用来控制背景图片的尺寸，可以给他设定的值及含义如下。
 50%：缩放图片，使其填充背景区的一半。
 100px 50px：把图片调整到 100 像素宽，50 像素高。
 cover：拉大图片，使其完全填满背景区；保持宽高比。
 contain：缩放图片，使其恰好适合背景区；保持宽高比。

### 背景粘附
background-attachment 属性控制滚动元素内的背景图片是否随元素滚动而移动。这个属性的默认值是 scroll，即背景图片随元素移动。如果把它的值改为 fixed，那么背景图片不会随元素滚动而移动。
background-attachment:fixed 最常用于给 body 元素中心位置添加淡色水印，让水印不随页面滚动而移动。

### 简写背景属性
background 属性可以用来设定所有背景相关的值。比如，前面那个 backgroundattachment 的例子使用简写的 background 属性，可以写成这样一条规则：body {background:url(images/watermark.png) center #fff no-repeat contain fixed;} 声明中少写了哪个属性的值（比如没写 no-repeat），就会使用相应属性的默认值（repeat）。

### 多背景图片
CSS3还可以给元素背景添加多个背景图片
```css
p { 
 height:150px; 
 width:348px; 
 border:2px solid #aaa; 
 margin:20px auto; 
 font:24px/150px helvetica, arial, sansserif; 
 text-align:center; 
 background: 
 url(images/turq_spiral.png) 30px -10px no-repeat, 
 url(images/pink_spiral.png) 145px 0px no-repeat, 
 url(images/gray_spiral.png) 140px -30px no-repeat, #ffbd75; 
}
```
在 CSS 中，我把每张图片的声明都单独放在了一行里，以逗号分隔，以便看清它们的位置、重复的设定值。为了防止图片加载失败时元素背景处于默认的透明状态，这里也在最后一条声明中加上了背景颜色（加粗的值）。要注意的是，代码中先列出的图片显示在上方，或者说，更接近前景。

### 背景渐变
渐变就是在一定长度内两种或多种颜色之间自然的过渡。渐变分两种，一种线性渐变，一种放射性渐变。线性渐变从元素的一端延伸到另一端，放射性渐变则从元素内一点向四周发散。
```html
<div class='gradient1'></div> 
<div class='gradient2'></div> 
<div class='gradient3'></div>
```
```css
/*为元素盒子添加样式*/ 
div { 
 height:150px; 
 width:200px; 
 border:1px solid #ccc; 
 float:left; 
 margin:16px; 
} 
/*例 1：默认为从上到下*/ 
.gradient1 { 
 background:linear-gradient(#e86a43, #fff); 
} 
/*例 2：从左到右*/
.gradient2 { 
 background:linear-gradient(left, #64d1dd, #fff); 
} 
/*例 3：左上到右下*/ 
.gradient3 { 
 background:linear-gradient(-45deg, #e86a43, #fff); 
}
```
1.渐变点
渐变点就是渐变方向上的点，可以在这些点上设定颜色和不透明度。通过设定下一个渐变点的颜色值，就可以控制渐变的效果。可以添加任意多个渐变点。渐变点的位置一般使用整个渐变宽度的百分比来表示。图 3-41 展示了使用渐变点后的四种渐变效果。
```css
/*例 1：50%处有一个渐变点*/ 
.gradient1 { 
 background:linear-gradient(#64d1dd, #fff 50%, #64d1dd); 
} 
/*例 2：20%和 80%处有两个渐变点*/ 
.gradient2 { 
 background:linear-gradient(#e86a43 20%, #fff 50%, #e86a43 80%); 
} 
/*例 3：25%、50%、75%处有三个渐变点*/ 
.gradient3 {
    background:linear-gradient(#64d1dd, #fff 25%, #64d1dd 50%, #fff 75%, 
#64d1dd); 
} 
/*例 4：为同一个渐变点设定两种颜色可以得到突变效果*/ 
.gradient4 { 
 background:linear-gradient(#e86a43, #fff 25%, #64d1dd 25%, #64d1dd 75%, 
#fff 75%, #e86a43); 
}
```
图 3-41 中的例 1 在 50%处包含一个渐变点，因此渐变效果是从开始颜色到渐变点颜色（白色），然后再从渐变点颜色到结束颜色。注意，开始和结束位置如果没有声明，则默认为 0%和 100%。
如果不是使用百分比或其他值声明渐变点的位置，则三种颜色会均匀分布于整个渐变，其实际位置是 0%、50%和 100%。
例 2 演示了起点和终点不是 0%和 100%时的情形。此时，在第一个渐变点（20%）之前，是第一个渐变点声明的实色，而在该点之后，则是从该颜色到下一个渐变点颜色的过渡。同样，在最后一个渐变点（80%）之后，该渐变点的颜色会以实色扩展到元素结束。
例 3 简单展示了相同颜色在几个渐变点之间变来变去的效果。例 4 展示了在同一个渐变点声明两种不同的颜色，能实现一种突变的效果。

2.放射性渐变
放射性渐变比线性渐变复杂那么一点点，因为可用的控制点多一些。如果你写过程序，从属性值中的括号就可以看出，渐变属性其实是函数。什么是函数？函数可以接收参数，然后根据这些参数来生成渐变。在创建放射性渐变时，可以使用参数指定形状、位置、尺寸、颜色和不透明度。
```css
.gradient1 { 
 background: -webkit-radial-gradient(#fff, #64d1dd, #70aa25); 
} 
.gradient2 { 
 background: -webkit-radial-gradient(circle, #fff, #64d1dd, #e86a43); 
} 
.gradient3 { 
 background: -webkit-radial-gradient(50px 30px, circle, #fff, #64d1dd, 
#4947ba); 
}
```
例 2 设定了形状关键字 circle，于是渐变的形状变得均匀，并在元素最近的边达到了终点，形成了圆形渐变。而长边剩下的区域则填充了终点的颜色。例 3 中的位置参数 50px 30px 把渐变的圆心放到了靠近左上角的位置。

### flex布局
flex是flexible box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。热和一个容器都可以指定为flex布局。
```css
.box {
    display: flex;
}
```
行内元素也可以使用flex布局。
```css
.box {
    display: inline-flex;
}
```
webkit内核的浏览器，必须加上-webkit前缀。
```css
.box {
    display: -webkit-flex;
    display: flex;
}
```
**注意，设为flex布局以后，子元素float、clear和veritical-align属性将失效。**

### 基本概念
采用flex布局的元素，成为flex容器（flex container），简称“容器”。它所有子元素自动成为容器成员，称为flex项目（flex item），简称“项目”。
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。
项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。

### 容器的属性
一下6个属性设置在容器上：
1.flex-direction
2.flex-wrap
3.flex-flow
4.justify-content
5.align-items
6.align-content

#### flex-direction属性
flex-direction属性决定株洲的方向（即项目的排列方向）。
```css
.box {
    flex-direction: row | row-reverse | column | column-reverse;
}
```
它可能有四个值
1.row（默认值）：主轴为水平方向，起点在左端。
2.row-reverse：主轴为水平方向，起点在右端。
3.column：主轴为垂直方向，起点在上沿。
4.column-reverse：主轴为垂直方向，起点在下沿。

#### flex-wrap属性
默认情况下，项目都排在一条线（又称“轴线”上）。flex-wrap属性定义，如果一条轴线排不下，如何换行
```css
.box {
    flex-wrap: nowrap | wrap | wrap-reverse;
}
```
它可能取三个值：
1.nowrap（默认）：不换行。
2.wrap：换行，第一行在上方。
3.wrap-reverse：换行，第一行在下方。

#### flex-flow
flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
```css
.box {
    flex-flow: <flex-direction> || <flex-wrap>
}
```

#### justify-content属性
justify-content属性定义了项目在主轴上的对齐方式。
```css
.box {
    justify-content: flex-start | flex-end | center | space-between | space-around;
}
```
它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。
1.flex-start（默认值）：左对齐
2.flex-end：右对齐
3.center： 居中
4.space-between：两端对齐，项目之间的间隔都相等。
5.space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

#### align-items属性
align-items属性定义项目在交叉轴上如何对齐。
```css
.box {
    align-items: flex-start | flex-end | center | baseline | stretch;
}
```
它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。

1.flex-start：交叉轴的起点对齐。
2.flex-end：交叉轴的终点对齐。
3.center：交叉轴的中点对齐。
4.baseline: 项目的第一行文字的基线对齐。
5.stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

#### align-content属性
align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
```css
.box {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```
该属性可能取6个值。

1.flex-start：与交叉轴的起点对齐。
2.flex-end：与交叉轴的终点对齐。
3.center：与交叉轴的中点对齐。
4.space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
5.space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
6.stretch（默认值）：轴线占满整个交叉轴。

### 项目的属性
以下6个属性设置在项目上
1.order
2.flex-grow
3.flex-shrink
4.flex-basis
5.flex
6.align-self

#### order属性
order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0.
```css
.item {
    order: <integer>;
}
```

#### flex-grow属性
flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
```css
.item {
    flex-grow: <number>;
}
```
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

#### flex-shrink属性
flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
```css
.item {
    flex-shrink: <number>;
}
```
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。

#### flex-basis属性
flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目本来的大小。
```css
.item {
    flex-basis: <length> | auto;
}
```
它可以设为跟width或height属性一样的值，则项目将占据固定空间。

#### flex属性

flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
```css
/* Basic values */
flex: auto;
flex: initial;
flex: none;
flex: 2;

/* One value, unitless number: flex-grow */
flex: 2;

/* One value, width/height: flex-basis */
flex: 10em;
flex: 30px;

/* Two values: flex-grow| flex-basis */
flex: 1 30px;

/* Tow values: flex-grow| flex-shrink */
flex: 2 2;

/* Three values: flex-grow| flex-shrink| flex-basis */
flex: 2 2 10%;

/* Global values */
flex: inherit;
flex: initial;
flex: unset;
```
flex属性可以指定1个，2个或3个值。
**单值语法**:
值必须为以下其中之一：
1.一个无单位数（<number>):它会被当做<flex-grow>的值。
2.一个有效的宽度（width）值：它会被当做<flex-basis>的值
3.关键字none，auto或initial

**双值语法**: 
第一个值必须为一个无单位数，并且它会被当作 <flex-grow> 的值。第二个值必须为以下之一：
1.一个无单位数：它会被当作 <flex-shrink> 的值。
2.一个有效的宽度值: 它会被当作 <flex-basis> 的值。

**三值语法**:
1.第一个值必须为一个无单位数，并且它会被当作 <flex-grow> 的值。
2.第二个值必须为一个无单位数，并且它会被当作  <flex-shrink> 的值。
3.第三个值必须为一个有效的宽度值， 并且它会被当作 <flex-basis> 的值。

#### align-self属性
align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
```css
.item {
    align-self: auto | flex-start | flex-end | baseline | stretch;
}
```